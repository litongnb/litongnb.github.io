<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>spring03</title>
      <link href="/2022/11/26/spring03/"/>
      <url>/2022/11/26/spring03/</url>
      
        <content type="html"><![CDATA[<h1 id="spring-03"><a href="#spring-03" class="headerlink" title="spring 03"></a>spring 03</h1><h2 id="1，AOP简介"><a href="#1，AOP简介" class="headerlink" title="1，AOP简介"></a>1，AOP简介</h2><p>前面我们在介绍Spring的时候说过，Spring有两个核心的概念，一个是<code>IOC/DI</code>，一个是<code>AOP</code>。</p><p>前面已经对<code>IOC/DI</code>进行了系统的学习，接下来要学习它的另一个核心内容，就是&#x3D;&#x3D;AOP&#x3D;&#x3D;。</p><p>对于AOP,我们前面提过一句话是:&#x3D;&#x3D;AOP是在不改原有代码的前提下对其进行增强。&#x3D;&#x3D;</p><p>对于下面的内容，我们主要就是围绕着这一句话进行展开学习，主要学习两方面内容<code>AOP核心概念</code>,<code>AOP作用</code>:</p><h3 id="1-1-什么是AOP"><a href="#1-1-什么是AOP" class="headerlink" title="1.1 什么是AOP?"></a>1.1 什么是AOP?</h3><ul><li>AOP(Aspect Oriented Programming)面向切面编程，一种编程范式，指导开发者如何组织程序结构。<ul><li>OOP(Object Oriented Programming)面向对象编程</li></ul></li></ul><p>我们都知道OOP是一种编程思想，那么AOP也是一种编程思想，编程思想主要的内容就是指导程序员该如何编写程序，所以它们两个是不同的<code>编程范式</code>。</p><h3 id="1-2-AOP作用"><a href="#1-2-AOP作用" class="headerlink" title="1.2 AOP作用"></a>1.2 AOP作用</h3><ul><li>作用:在不惊动原始设计的基础上为其进行功能增强，前面咱们有技术就可以实现这样的功能即代理模式。</li></ul><p>前面咱们有技术就可以实现这样的功能即<code>代理模式</code>。</p><h3 id="1-3-AOP核心概念"><a href="#1-3-AOP核心概念" class="headerlink" title="1.3 AOP核心概念"></a>1.3 AOP核心概念</h3><p>为了能更好的理解AOP的相关概念，我们准备了一个环境，整个环境的内容我们暂时可以不用关注，最主要的类为:<code>BookDaoImpl</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//记录程序当前执行执行（开始时间）</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//业务执行万次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;<span class="number">10000</span>;i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记录程序当前执行时间（结束时间）</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//计算时间差</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">totalTime</span> <span class="operator">=</span> endTime-startTime;</span><br><span class="line">        <span class="comment">//输出信息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;执行万次消耗时间：&quot;</span> + totalTime + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao update ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao delete ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao select ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码的内容相信大家都能够读懂，对于<code>save</code>方法中有计算万次执行消耗的时间。</p><p>当在App类中从容器中获取bookDao对象后，分别执行其<code>save</code>,<code>delete</code>,<code>update</code>和<code>select</code>方法后会有如下的打印结果:</p><p><img src="/2022/11/26/spring03/1630143927489.png" alt="1630143927489"></p><p>这个时候，我们就应该有些疑问?</p><ul><li>对于计算万次执行消耗的时间只有save方法有，为什么delete和update方法也会有呢?</li><li>delete和update方法有，那什么select方法为什么又没有呢?</li></ul><p>这个案例中其实就使用了Spring的AOP，在不惊动(改动)原有设计(代码)的前提下，想给谁添加功能就给谁添加。这个也就是Spring的理念：</p><ul><li>无入侵式&#x2F;无侵入式</li></ul><p>说了这么多，Spring到底是如何实现的呢?</p><p><img src="/2022/11/26/spring03/1630144353462.png" alt="1630144353462"></p><p>(1)前面一直在强调，Spring的AOP是对一个类的方法在不进行任何修改的前提下实现增强。对于上面的案例中BookServiceImpl中有<code>save</code>,<code>update</code>,<code>delete</code>和<code>select</code>方法,这些方法我们给起了一个名字叫&#x3D;&#x3D;连接点&#x3D;&#x3D;</p><p>(2)在BookServiceImpl的四个方法中，<code>update</code>和<code>delete</code>只有打印没有计算万次执行消耗时间，但是在运行的时候已经有该功能，那也就是说<code>update</code>和<code>delete</code>方法都已经被增强，所以对于需要增强的方法我们给起了一个名字叫&#x3D;&#x3D;切入点&#x3D;&#x3D;</p><p>(3)执行BookServiceImpl的update和delete方法的时候都被添加了一个计算万次执行消耗时间的功能，将这个功能抽取到一个方法中，换句话说就是存放共性功能的方法，我们给起了个名字叫&#x3D;&#x3D;通知&#x3D;&#x3D;</p><p>(4)通知是要增强的内容，会有多个，切入点是需要被增强的方法，也会有多个，那哪个切入点需要添加哪个通知，就需要提前将它们之间的关系描述清楚，那么对于通知和切入点之间的关系描述，我们给起了个名字叫&#x3D;&#x3D;切面&#x3D;&#x3D;</p><p>(5)通知是一个方法，方法不能独立存在需要被写在一个类中，这个类我们也给起了个名字叫&#x3D;&#x3D;通知类&#x3D;&#x3D;</p><p>至此AOP中的核心概念就已经介绍完了，总结下:</p><ul><li>连接点(JoinPoint)：程序执行过程中的任意位置，粒度为执行方法、抛出异常、设置变量等<ul><li>在SpringAOP中，理解为方法的执行</li></ul></li><li>切入点(Pointcut):匹配连接点的式子<ul><li>在SpringAOP中，一个切入点可以描述一个具体方法，也可也匹配多个方法<ul><li>一个具体的方法:如com.itheima.dao包下的BookDao接口中的无形参无返回值的save方法</li><li>匹配多个方法:所有的save方法，所有的get开头的方法，所有以Dao结尾的接口中的任意方法，所有带有一个参数的方法</li></ul></li><li>连接点范围要比切入点范围大，是切入点的方法也一定是连接点，但是是连接点的方法就不一定要被增强，所以可能不是切入点。</li></ul></li><li>通知(Advice):在切入点处执行的操作，也就是共性功能<ul><li>在SpringAOP中，功能最终以方法的形式呈现</li></ul></li><li>通知类：定义通知的类</li><li>切面(Aspect):描述通知与切入点的对应关系。</li></ul><p><strong>小结</strong></p><p>这一节中主要讲解了AOP的概念与作用，以及AOP中的核心概念，学完以后大家需要能说出:</p><ul><li>什么是AOP?</li><li>AOP的作用是什么?</li><li>AOP中核心概念分别指的是什么?<ul><li>连接点</li><li>切入点</li><li>通知</li><li>通知类</li><li>切面</li></ul></li></ul><h2 id="2，AOP入门案例"><a href="#2，AOP入门案例" class="headerlink" title="2，AOP入门案例"></a>2，AOP入门案例</h2><h3 id="2-1-需求分析"><a href="#2-1-需求分析" class="headerlink" title="2.1 需求分析"></a>2.1 需求分析</h3><p>案例设定：测算接口执行效率，但是这个案例稍微复杂了点，我们对其进行简化。</p><p>简化设定：在方法执行前输出当前系统时间。</p><p>对于SpringAOP的开发有两种方式，XML 和 &#x3D;&#x3D;注解&#x3D;&#x3D;，我们使用哪个呢?</p><p>因为现在注解使用的比较多，所以本次课程就采用注解完成AOP的开发。</p><p>总结需求为:使用SpringAOP的注解方式完成在方法执行的前打印出当前系统时间。</p><h3 id="2-2-思路分析"><a href="#2-2-思路分析" class="headerlink" title="2.2 思路分析"></a>2.2 思路分析</h3><p>需求明确后，具体该如何实现，都有哪些步骤，我们先来分析下:</p><blockquote><p>1.导入坐标(pom.xml)</p><p>2.制作连接点(原始操作，Dao接口与实现类)</p><p>3.制作共性功能(通知类与通知)</p><p>4.定义切入点</p><p>5.绑定切入点与通知关系(切面)</p></blockquote><h3 id="2-3-环境准备"><a href="#2-3-环境准备" class="headerlink" title="2.3 环境准备"></a>2.3 环境准备</h3><ul><li><p>创建一个Maven项目</p></li><li><p>pom.xml添加Spring依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>添加BookDao和BookDaoImpl类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao update ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建Spring的配置类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写App运行类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> ctx.getBean(BookDao.class);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>最终创建好的项目结构如下:</p><p><img src="/2022/11/26/spring03/1630167092142.png" alt="1630167092142"></p><p><strong>说明:</strong></p><ul><li>目前打印save方法的时候，因为方法中有打印系统时间，所以运行的时候是可以看到系统时间</li><li>对于update方法来说，就没有该功能</li><li>我们要使用SpringAOP的方式在不改变update方法的前提下让其具有打印系统时间的功能。</li></ul><h3 id="2-4-AOP实现步骤"><a href="#2-4-AOP实现步骤" class="headerlink" title="2.4 AOP实现步骤"></a>2.4 AOP实现步骤</h3><h4 id="步骤1-添加依赖"><a href="#步骤1-添加依赖" class="headerlink" title="步骤1:添加依赖"></a>步骤1:添加依赖</h4><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/2022/11/26/spring03/1630146885493.png" alt="1630146885493"></p><ul><li>因为<code>spring-context</code>中已经导入了<code>spring-aop</code>,所以不需要再单独导入<code>spring-aop</code></li><li>导入AspectJ的jar包,AspectJ是AOP思想的一个具体实现，Spring有自己的AOP实现，但是相比于AspectJ来说比较麻烦，所以我们直接采用Spring整合ApsectJ的方式进行AOP开发。</li></ul><h4 id="步骤2-定义接口与实现类"><a href="#步骤2-定义接口与实现类" class="headerlink" title="步骤2:定义接口与实现类"></a>步骤2:定义接口与实现类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">环境准备的时候，BookDaoImpl已经准备好，不需要做任何修改</span><br></pre></td></tr></table></figure><h4 id="步骤3-定义通知类和通知"><a href="#步骤3-定义通知类和通知" class="headerlink" title="步骤3:定义通知类和通知"></a>步骤3:定义通知类和通知</h4><p>通知就是将共性功能抽取出来后形成的方法，共性功能指的就是当前系统时间的打印。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类名和方法名没有要求，可以任意。</p><h4 id="步骤4-定义切入点"><a href="#步骤4-定义切入点" class="headerlink" title="步骤4:定义切入点"></a>步骤4:定义切入点</h4><p>BookDaoImpl中有两个方法，分别是save和update，我们要增强的是update方法，该如何定义呢?</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.itheima.dao.BookDao.update())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>切入点定义依托一个不具有实际意义的方法进行，即无参数、无返回值、方法体无实际逻辑。</li><li>execution及后面编写的内容，后面会有章节专门去学习。</li></ul><h4 id="步骤5-制作切面"><a href="#步骤5-制作切面" class="headerlink" title="步骤5:制作切面"></a>步骤5:制作切面</h4><p>切面是用来描述通知和切入点之间的关系，如何进行关系的绑定?</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.itheima.dao.BookDao.update())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Before(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绑定切入点与通知关系，并指定通知添加到原始连接点的具体执行&#x3D;&#x3D;位置&#x3D;&#x3D;</p><p><img src="/2022/11/26/spring03/1630148447689.png" alt="1630148447689"></p><p><strong>说明:</strong>@Before翻译过来是之前，也就是说通知会在切入点方法执行之前执行，除此之前还有其他四种类型，后面会讲。</p><h4 id="步骤6-将通知类配给容器并标识其为切面类"><a href="#步骤6-将通知类配给容器并标识其为切面类" class="headerlink" title="步骤6:将通知类配给容器并标识其为切面类"></a>步骤6:将通知类配给容器并标识其为切面类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.itheima.dao.BookDao.update())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Before(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="步骤7-开启注解格式AOP功能"><a href="#步骤7-开启注解格式AOP功能" class="headerlink" title="步骤7:开启注解格式AOP功能"></a>步骤7:开启注解格式AOP功能</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima&quot;)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="步骤8-运行程序"><a href="#步骤8-运行程序" class="headerlink" title="步骤8:运行程序"></a>步骤8:运行程序</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> ctx.getBean(BookDao.class);</span><br><span class="line">        bookDao.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到在执行update方法之前打印了系统时间戳，说明对原始方法进行了增强，AOP编程成功。</p><p><img src="/2022/11/26/spring03/1630147945888.png" alt="1630147945888"></p><h3 id="知识点1：-EnableAspectJAutoProxy"><a href="#知识点1：-EnableAspectJAutoProxy" class="headerlink" title="知识点1：@EnableAspectJAutoProxy"></a>知识点1：@EnableAspectJAutoProxy</h3><table><thead><tr><th>名称</th><th>@EnableAspectJAutoProxy</th></tr></thead><tbody><tr><td>类型</td><td>配置类注解</td></tr><tr><td>位置</td><td>配置类定义上方</td></tr><tr><td>作用</td><td>开启注解格式AOP功能</td></tr></tbody></table><h3 id="知识点2：-Aspect"><a href="#知识点2：-Aspect" class="headerlink" title="知识点2：@Aspect"></a>知识点2：@Aspect</h3><table><thead><tr><th>名称</th><th>@Aspect</th></tr></thead><tbody><tr><td>类型</td><td>类注解</td></tr><tr><td>位置</td><td>切面类定义上方</td></tr><tr><td>作用</td><td>设置当前类为AOP切面类</td></tr></tbody></table><h3 id="知识点3：-Pointcut"><a href="#知识点3：-Pointcut" class="headerlink" title="知识点3：@Pointcut"></a>知识点3：@Pointcut</h3><table><thead><tr><th>名称</th><th>@Pointcut</th></tr></thead><tbody><tr><td>类型</td><td>方法注解</td></tr><tr><td>位置</td><td>切入点方法定义上方</td></tr><tr><td>作用</td><td>设置切入点方法</td></tr><tr><td>属性</td><td>value（默认）：切入点表达式</td></tr></tbody></table><h3 id="知识点4：-Before"><a href="#知识点4：-Before" class="headerlink" title="知识点4：@Before"></a>知识点4：@Before</h3><table><thead><tr><th>名称</th><th>@Before</th></tr></thead><tbody><tr><td>类型</td><td>方法注解</td></tr><tr><td>位置</td><td>通知方法定义上方</td></tr><tr><td>作用</td><td>设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法前运行</td></tr></tbody></table><h2 id="3，AOP工作流程"><a href="#3，AOP工作流程" class="headerlink" title="3，AOP工作流程"></a>3，AOP工作流程</h2><p>AOP的入门案例已经完成，对于刚才案例的执行过程，我们就得来分析分析，这一节我们主要讲解两个知识点:<code>AOP工作流程</code>和<code>AOP核心概念</code>。其中核心概念是对前面核心概念的补充。</p><h3 id="3-1-AOP工作流程"><a href="#3-1-AOP工作流程" class="headerlink" title="3.1 AOP工作流程"></a>3.1 AOP工作流程</h3><p>由于AOP是基于Spring容器管理的bean做的增强，所以整个工作过程需要从Spring加载bean说起:</p><h4 id="流程1-Spring容器启动"><a href="#流程1-Spring容器启动" class="headerlink" title="流程1:Spring容器启动"></a>流程1:Spring容器启动</h4><ul><li>容器启动就需要去加载bean,哪些类需要被加载呢?</li><li>需要被增强的类，如:BookServiceImpl</li><li>通知类，如:MyAdvice</li><li>注意此时bean对象还没有创建成功</li></ul><h4 id="流程2-读取所有切面配置中的切入点"><a href="#流程2-读取所有切面配置中的切入点" class="headerlink" title="流程2:读取所有切面配置中的切入点"></a>流程2:读取所有切面配置中的切入点</h4><p><img src="/2022/11/26/spring03/1630151682428.png" alt="1630151682428"></p><ul><li>上面这个例子中有两个切入点的配置，但是第一个<code>ptx()</code>并没有被使用，所以不会被读取。</li></ul><h4 id="流程3-初始化bean，"><a href="#流程3-初始化bean，" class="headerlink" title="流程3:初始化bean，"></a>流程3:初始化bean，</h4><p>判定bean对应的类中的方法是否匹配到任意切入点</p><ul><li><p>注意第1步在容器启动的时候，bean对象还没有被创建成功。</p></li><li><p>要被实例化bean对象的类中的方法和切入点进行匹配</p><p><img src="/2022/11/26/spring03/1630152538083.png" alt="1630152538083"></p><ul><li>匹配失败，创建原始对象,如<code>UserDao</code><ul><li>匹配失败说明不需要增强，直接调用原始对象的方法即可。</li></ul></li><li>匹配成功，创建原始对象（&#x3D;&#x3D;目标对象&#x3D;&#x3D;）的&#x3D;&#x3D;代理&#x3D;&#x3D;对象,如:<code>BookDao</code><ul><li>匹配成功说明需要对其进行增强</li><li>对哪个类做增强，这个类对应的对象就叫做目标对象</li><li>因为要对目标对象进行功能增强，而采用的技术是动态代理，所以会为其创建一个代理对象</li><li>最终运行的是代理对象的方法，在该方法中会对原始方法进行功能增强</li></ul></li></ul></li></ul><h4 id="流程4-获取bean执行方法"><a href="#流程4-获取bean执行方法" class="headerlink" title="流程4:获取bean执行方法"></a>流程4:获取bean执行方法</h4><ul><li>获取的bean是原始对象时，调用方法并执行，完成操作</li><li>获取的bean是代理对象时，根据代理对象的运行模式运行原始方法与增强的内容，完成操作</li></ul><h4 id="验证容器中是否为代理对象"><a href="#验证容器中是否为代理对象" class="headerlink" title="验证容器中是否为代理对象"></a>验证容器中是否为代理对象</h4><p>为了验证IOC容器中创建的对象和我们刚才所说的结论是否一致，首先先把结论理出来:</p><ul><li>如果目标对象中的方法会被增强，那么容器中将存入的是目标对象的代理对象</li><li>如果目标对象中的方法不被增强，那么容器中将存入的是目标对象本身。</li></ul><h5 id="验证思路"><a href="#验证思路" class="headerlink" title="验证思路"></a>验证思路</h5><blockquote><p>1.要执行的方法，不被定义的切入点包含，即不要增强，打印当前类的getClass()方法</p><p>2.要执行的方法，被定义的切入点包含，即要增强，打印出当前类的getClass()方法</p><p>3.观察两次打印的结果</p></blockquote><h5 id="步骤1-修改App类-获取类的类型"><a href="#步骤1-修改App类-获取类的类型" class="headerlink" title="步骤1:修改App类,获取类的类型"></a>步骤1:修改App类,获取类的类型</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> ctx.getBean(BookDao.class);</span><br><span class="line">        System.out.println(bookDao);</span><br><span class="line">        System.out.println(bookDao.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="步骤2-修改MyAdvice类，不增强"><a href="#步骤2-修改MyAdvice类，不增强" class="headerlink" title="步骤2:修改MyAdvice类，不增强"></a>步骤2:修改MyAdvice类，不增强</h5><p>因为定义的切入点中，被修改成<code>update1</code>,所以BookDao中的update方法在执行的时候，就不会被增强，</p><p>所以容器中的对象应该是目标对象本身。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.itheima.dao.BookDao.update1())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Before(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="步骤3-运行程序"><a href="#步骤3-运行程序" class="headerlink" title="步骤3:运行程序"></a>步骤3:运行程序</h5><p><img src="/2022/11/26/spring03/1630154495165.png" alt="1630154495165"></p><h5 id="步骤4-修改MyAdvice类，增强"><a href="#步骤4-修改MyAdvice类，增强" class="headerlink" title="步骤4:修改MyAdvice类，增强"></a>步骤4:修改MyAdvice类，增强</h5><p>因为定义的切入点中，被修改成<code>update</code>,所以BookDao中的update方法在执行的时候，就会被增强，</p><p>所以容器中的对象应该是目标对象的代理对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.itheima.dao.BookDao.update())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Before(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="步骤5-运行程序"><a href="#步骤5-运行程序" class="headerlink" title="步骤5:运行程序"></a>步骤5:运行程序</h5><p><img src="/2022/11/26/spring03/1630154625564.png" alt="1630154625564"></p><p>至此对于刚才的结论，我们就得到了验证，这块大家需要注意的是:</p><p>不能直接打印对象，从上面两次结果中可以看出，直接打印对象走的是对象的toString方法，不管是不是代理对象打印的结果都是一样的，原因是内部对toString方法进行了重写。</p><h3 id="3-2-AOP核心概念"><a href="#3-2-AOP核心概念" class="headerlink" title="3.2 AOP核心概念"></a>3.2 AOP核心概念</h3><p>在上面介绍AOP的工作流程中，我们提到了两个核心概念，分别是:</p><ul><li>目标对象(Target)：原始功能去掉共性功能对应的类产生的对象，这种对象是无法直接完成最终工作的</li><li>代理(Proxy)：目标对象无法直接完成工作，需要对其进行功能回填，通过原始对象的代理对象实现</li></ul><p>上面这两个概念比较抽象，简单来说，</p><p>目标对象就是要增强的类[如:BookServiceImpl类]对应的对象，也叫原始对象，不能说它不能运行，只能说它在运行的过程中对于要增强的内容是缺失的。</p><p>SpringAOP是在不改变原有设计(代码)的前提下对其进行增强的，它的底层采用的是代理模式实现的，所以要对原始对象进行增强，就需要对原始对象创建代理对象，在代理对象中的方法把通知[如:MyAdvice中的method方法]内容加进去，就实现了增强,这就是我们所说的代理(Proxy)。</p><p><strong>小结</strong></p><p>通过这一节中，我们需要掌握的内容有：</p><ul><li>能说出AOP的工作流程</li><li>AOP的核心概念<ul><li>目标对象、连接点、切入点</li><li>通知类、通知</li><li>切面</li><li>代理</li></ul></li><li>SpringAOP的本质或者可以说底层实现是通过代理模式。</li></ul><h2 id="4，AOP配置管理"><a href="#4，AOP配置管理" class="headerlink" title="4，AOP配置管理"></a>4，AOP配置管理</h2><h3 id="4-1-AOP切入点表达式"><a href="#4-1-AOP切入点表达式" class="headerlink" title="4.1 AOP切入点表达式"></a>4.1 AOP切入点表达式</h3><p>前面的案例中，有涉及到如下内容:</p><p><img src="/2022/11/26/spring03/1630155937718.png" alt="1630155937718"></p><p>对于AOP中切入点表达式，我们总共会学习三个内容，分别是<code>语法格式</code>、<code>通配符</code>和<code>书写技巧</code>。</p><h4 id="4-1-1-语法格式"><a href="#4-1-1-语法格式" class="headerlink" title="4.1.1 语法格式"></a>4.1.1 语法格式</h4><p>首先我们先要明确两个概念:</p><ul><li>切入点:要进行增强的方法</li><li>切入点表达式:要进行增强的方法的描述方式</li></ul><p>对于切入点的描述，我们其实是有两中方式的，先来看下前面的例子</p><p><img src="/2022/11/26/spring03/1630156172790.png" alt="1630156172790"></p><p>描述方式一：执行com.itheima.dao包下的BookDao接口中的无参数update方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">execution(<span class="keyword">void</span> com.itheima.dao.BookDao.update())</span><br></pre></td></tr></table></figure><p>描述方式二：执行com.itheima.dao.impl包下的BookDaoImpl类中的无参数update方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">execution(void com.itheima.dao.impl.BookDaoImpl.update())</span><br></pre></td></tr></table></figure><p>因为调用接口方法的时候最终运行的还是其实现类的方法，所以上面两种描述方式都是可以的。</p><p>对于切入点表达式的语法为:</p><ul><li>切入点表达式标准格式：动作关键字(访问修饰符  返回值  包名.类&#x2F;接口名.方法名(参数) 异常名）</li></ul><p>对于这个格式，我们不需要硬记，通过一个例子，理解它:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">execution(public User com.itheima.service.UserService.findById(int))</span><br></pre></td></tr></table></figure><ul><li>execution：动作关键字，描述切入点的行为动作，例如execution表示执行到指定切入点</li><li>public:访问修饰符,还可以是public，private等，可以省略</li><li>User：返回值，写返回值类型</li><li>com.itheima.service：包名，多级包使用点连接</li><li>UserService:类&#x2F;接口名称</li><li>findById：方法名</li><li>int:参数，直接写参数的类型，多个类型用逗号隔开</li><li>异常名：方法定义中抛出指定异常，可以省略</li></ul><p>切入点表达式就是要找到需要增强的方法，所以它就是对一个具体方法的描述，但是方法的定义会有很多，所以如果每一个方法对应一个切入点表达式，想想这块就会觉得将来编写起来会比较麻烦，有没有更简单的方式呢?</p><p>就需要用到下面所学习的通配符。</p><h4 id="4-1-2-通配符"><a href="#4-1-2-通配符" class="headerlink" title="4.1.2 通配符"></a>4.1.2 通配符</h4><p>我们使用通配符描述切入点，主要的目的就是简化之前的配置，具体都有哪些通配符可以使用?</p><ul><li><p><code>*</code>:单个独立的任意符号，可以独立出现，也可以作为前缀或者后缀的匹配符出现</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">execution（public * com.itheima.*.UserService.find*(*))</span><br></pre></td></tr></table></figure><p>匹配com.itheima包下的任意包中的UserService类或接口中所有find开头的带有一个参数的方法</p></li><li><p><code>..</code>：多个连续的任意符号，可以独立出现，常用于简化包名与参数的书写</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">execution（public User com..UserService.findById(..))</span><br></pre></td></tr></table></figure><p>匹配com包下的任意包中的UserService类或接口中所有名称为findById的方法</p></li><li><p><code>+</code>：专用于匹配子类类型</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">execution(* *..*Service+.*(..))</span><br></pre></td></tr></table></figure><p>这个使用率较低，描述子类的，咱们做JavaEE开发，继承机会就一次，使用都很慎重，所以很少用它。*Service+，表示所有以Service结尾的接口的子类。</p></li></ul><p>接下来，我们把案例中使用到的切入点表达式来分析下:</p><p><img src="/2022/11/26/spring03/1630163744963.png" alt="1630163744963"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">execution(<span class="keyword">void</span> com.itheima.dao.BookDao.update())</span><br><span class="line">匹配接口，能匹配到</span><br><span class="line">execution(<span class="keyword">void</span> com.itheima.dao.impl.BookDaoImpl.update())</span><br><span class="line">匹配实现类，能匹配到</span><br><span class="line">execution(* com.itheima.dao.impl.BookDaoImpl.update())</span><br><span class="line">返回值任意，能匹配到</span><br><span class="line">execution(* com.itheima.dao.impl.BookDaoImpl.update(*))</span><br><span class="line">返回值任意，但是update方法必须要有一个参数，无法匹配，要想匹配需要在update接口和实现类添加参数</span><br><span class="line">execution(<span class="keyword">void</span> com.*.*.*.*.update())</span><br><span class="line">返回值为<span class="keyword">void</span>,com包下的任意包三层包下的任意类的update方法，匹配到的是实现类，能匹配</span><br><span class="line">execution(<span class="keyword">void</span> com.*.*.*.update())</span><br><span class="line">返回值为<span class="keyword">void</span>,com包下的任意两层包下的任意类的update方法，匹配到的是接口，能匹配</span><br><span class="line">execution(<span class="keyword">void</span> *..update())</span><br><span class="line">返回值为<span class="keyword">void</span>，方法名是update的任意包下的任意类，能匹配</span><br><span class="line">execution(* *..*(..))</span><br><span class="line">匹配项目中任意类的任意方法，能匹配，但是不建议使用这种方式，影响范围广</span><br><span class="line">execution(* *..u*(..))</span><br><span class="line">匹配项目中任意包任意类下只要以u开头的方法，update方法能满足，能匹配</span><br><span class="line">execution(* *..*e(..))</span><br><span class="line">匹配项目中任意包任意类下只要以e结尾的方法，update和save方法能满足，能匹配</span><br><span class="line">execution(<span class="keyword">void</span> com..*())</span><br><span class="line">返回值为<span class="keyword">void</span>，com包下的任意包任意类任意方法，能匹配，*代表的是方法</span><br><span class="line">execution(* com.itheima.*.*Service.find*(..))</span><br><span class="line">将项目中所有业务层方法的以find开头的方法匹配</span><br><span class="line">execution(* com.itheima.*.*Service.save*(..))</span><br><span class="line">将项目中所有业务层方法的以save开头的方法匹配</span><br></pre></td></tr></table></figure><p>后面两种更符合我们平常切入点表达式的编写规则</p><h4 id="4-1-3-书写技巧"><a href="#4-1-3-书写技巧" class="headerlink" title="4.1.3 书写技巧"></a>4.1.3 书写技巧</h4><p>对于切入点表达式的编写其实是很灵活的，那么在编写的时候，有没有什么好的技巧让我们用用:</p><ul><li>所有代码按照标准规范开发，否则以下技巧全部失效</li><li>描述切入点通**&#x3D;&#x3D;常描述接口&#x3D;&#x3D;**，而不描述实现类,如果描述到实现类，就出现紧耦合了</li><li>访问控制修饰符针对接口开发均采用public描述（**&#x3D;&#x3D;可省略访问控制修饰符描述&#x3D;&#x3D;**）</li><li>返回值类型对于增删改类使用精准类型加速匹配，对于查询类使用*通配快速描述</li><li>**&#x3D;&#x3D;包名&#x3D;&#x3D;<strong>书写</strong>&#x3D;&#x3D;尽量不使用..匹配&#x3D;&#x3D;**，效率过低，常用*做单个包描述匹配，或精准匹配</li><li>**&#x3D;&#x3D;接口名&#x2F;类名&#x3D;&#x3D;<strong>书写名称与模块相关的</strong>&#x3D;&#x3D;采用*匹配&#x3D;&#x3D;**，例如UserService书写成*Service，绑定业务层接口名</li><li>**&#x3D;&#x3D;方法名&#x3D;&#x3D;<strong>书写以</strong>&#x3D;&#x3D;动词&#x3D;&#x3D;<strong>进行</strong>&#x3D;&#x3D;精准匹配&#x3D;&#x3D;*<em>，名词采用</em>匹配，例如getById书写成getBy*,selectAll书写成selectAll</li><li>参数规则较为复杂，根据业务方法灵活调整</li><li>通常**&#x3D;&#x3D;不使用异常&#x3D;&#x3D;<strong>作为</strong>&#x3D;&#x3D;匹配&#x3D;&#x3D;**规则</li></ul><h3 id="4-2-AOP通知类型"><a href="#4-2-AOP通知类型" class="headerlink" title="4.2 AOP通知类型"></a>4.2 AOP通知类型</h3><p>前面的案例中，有涉及到如下内容:</p><p><img src="/2022/11/26/spring03/1630164718080.png" alt="1630164718080"></p><p>它所代表的含义是将<code>通知</code>添加到<code>切入点</code>方法执行的&#x3D;&#x3D;前面&#x3D;&#x3D;。</p><p>除了这个注解外，还有没有其他的注解，换个问题就是除了可以在前面加，能不能在其他的地方加?</p><h4 id="4-2-1-类型介绍"><a href="#4-2-1-类型介绍" class="headerlink" title="4.2.1 类型介绍"></a>4.2.1 类型介绍</h4><p>我们先来回顾下AOP通知:</p><ul><li>AOP通知描述了抽取的共性功能，根据共性功能抽取的位置不同，最终运行代码时要将其加入到合理的位置</li></ul><p>通知具体要添加到切入点的哪里?</p><p>共提供了5种通知类型:</p><ul><li>前置通知</li><li>后置通知</li><li><strong>&#x3D;&#x3D;环绕通知(重点)&#x3D;&#x3D;</strong></li><li>返回后通知(了解)</li><li>抛出异常后通知(了解)</li></ul><p>为了更好的理解这几种通知类型，我们来看一张图</p><p><img src="/2022/11/26/spring03/1630166147697.png" alt="1630166147697"></p><p>(1)前置通知，追加功能到方法执行前,类似于在代码1或者代码2添加内容</p><p>(2)后置通知,追加功能到方法执行后,不管方法执行的过程中有没有抛出异常都会执行，类似于在代码5添加内容</p><p>(3)返回后通知,追加功能到方法执行后，只有方法正常执行结束后才进行,类似于在代码3添加内容，如果方法执行抛出异常，返回后通知将不会被添加</p><p>(4)抛出异常后通知,追加功能到方法抛出异常后，只有方法执行出异常才进行,类似于在代码4添加内容，只有方法抛出异常后才会被添加</p><p>(5)环绕通知,环绕通知功能比较强大，它可以追加功能到方法执行的前后，这也是比较常用的方式，它可以实现其他四种通知类型的功能，具体是如何实现的，需要我们往下学习。</p><h4 id="4-2-2-环境准备"><a href="#4-2-2-环境准备" class="headerlink" title="4.2.2 环境准备"></a>4.2.2 环境准备</h4><ul><li><p>创建一个Maven项目</p></li><li><p>pom.xml添加Spring依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>添加BookDao和BookDaoImpl类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">select</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao update ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">select</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao select is running ...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建Spring的配置类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima&quot;)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建通知类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.itheima.dao.BookDao.update())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before advice ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after advice ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;around before advice ...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;around after advice ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterReturning advice ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterThrowing advice ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写App运行类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> ctx.getBean(BookDao.class);</span><br><span class="line">        bookDao.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>最终创建好的项目结构如下:</p><p><img src="/2022/11/26/spring03/1630167385146.png" alt="1630167385146"></p><h4 id="4-2-3-通知类型的使用"><a href="#4-2-3-通知类型的使用" class="headerlink" title="4.2.3 通知类型的使用"></a>4.2.3 通知类型的使用</h4><h5 id="前置通知"><a href="#前置通知" class="headerlink" title="前置通知"></a>前置通知</h5><p>修改MyAdvice,在before方法上添加<code>@Before注解</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.itheima.dao.BookDao.update())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Before(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="comment">//此处也可以写成 @Before(&quot;MyAdvice.pt()&quot;),不建议</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before advice ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/11/26/spring03/1630167805723.png" alt="1630167805723"></p><h5 id="后置通知"><a href="#后置通知" class="headerlink" title="后置通知"></a>后置通知</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.itheima.dao.BookDao.update())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Before(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before advice ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@After(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after advice ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/11/26/spring03/1630167887131.png" alt="1630167887131"></p><h5 id="环绕通知"><a href="#环绕通知" class="headerlink" title="环绕通知"></a>环绕通知</h5><h6 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.itheima.dao.BookDao.update())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Around(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;around before advice ...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;around after advice ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/11/26/spring03/1630167969051.png" alt="1630167969051"></p><p>运行结果中，通知的内容打印出来，但是原始方法的内容却没有被执行。</p><p>因为环绕通知需要在原始方法的前后进行增强，所以环绕通知就必须要能对原始操作进行调用，具体如何实现?</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.itheima.dao.BookDao.update())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Around(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;around before advice ...&quot;</span>);</span><br><span class="line">        <span class="comment">//表示对原始操作的调用</span></span><br><span class="line">        pjp.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;around after advice ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**说明:**proceed()为什么要抛出异常?</p><p>原因很简单，看下源码就知道了</p><p><img src="/2022/11/26/spring03/1630168248052.png" alt="1630168248052"></p><p>再次运行，程序可以看到原始方法已经被执行了</p><p><img src="/2022/11/26/spring03/1630168293492.png" alt="1630168293492"></p><h6 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h6><p>(1)原始方法有返回值的处理</p><ul><li>修改MyAdvice,对BookDao中的select方法添加环绕通知，</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.itheima.dao.BookDao.update())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(int com.itheima.dao.BookDao.select())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt2</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Around(&quot;pt2()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">aroundSelect</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;around before advice ...&quot;</span>);</span><br><span class="line">        <span class="comment">//表示对原始操作的调用</span></span><br><span class="line">        pjp.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;around after advice ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>修改App类，调用select方法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> ctx.getBean(BookDao.class);</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> bookDao.select();</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后会报错，错误内容为:</p><p>Exception in thread “main” org.springframework.aop.AopInvocationException: &#x3D;&#x3D;Null return value from advice does not match primitive return type for: public abstract int com.itheima.dao.BookDao.select()&#x3D;&#x3D;<br>    at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:226)<br>    at com.sun.proxy.$Proxy19.select(Unknown Source)<br>    at com.itheima.App.main(App.java:12)</p><p>错误大概的意思是:<code>空的返回不匹配原始方法的int返回</code></p><ul><li>void就是返回Null</li><li>原始方法就是BookDao下的select方法</li></ul><p>所以如果我们使用环绕通知的话，要根据原始方法的返回值来设置环绕通知的返回值，具体解决方案为:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.itheima.dao.BookDao.update())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(int com.itheima.dao.BookDao.select())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt2</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Around(&quot;pt2()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">aroundSelect</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;around before advice ...&quot;</span>);</span><br><span class="line">        <span class="comment">//表示对原始操作的调用</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;around after advice ...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><p>​    为什么返回的是Object而不是int的主要原因是Object类型更通用。</p><p>​    在环绕通知中是可以对原始方法返回值就行修改的。</p><h5 id="返回后通知"><a href="#返回后通知" class="headerlink" title="返回后通知"></a>返回后通知</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.itheima.dao.BookDao.update())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(int com.itheima.dao.BookDao.select())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt2</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@AfterReturning(&quot;pt2()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterReturning advice ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/11/26/spring03/1630169124446.png" alt="1630169124446"></p><p><strong>注意：</strong>返回后通知是需要在原始方法<code>select</code>正常执行后才会被执行，如果<code>select()</code>方法执行的过程中出现了异常，那么返回后通知是不会被执行。后置通知是不管原始方法有没有抛出异常都会被执行。这个案例大家下去可以自己练习验证下。</p><h5 id="异常后通知"><a href="#异常后通知" class="headerlink" title="异常后通知"></a>异常后通知</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.itheima.dao.BookDao.update())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(int com.itheima.dao.BookDao.select())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt2</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@AfterReturning(&quot;pt2()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterThrowing advice ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/11/26/spring03/1630169357146.png" alt="1630169357146"></p><p><strong>注意：</strong>异常后通知是需要原始方法抛出异常，可以在<code>select()</code>方法中添加一行代码<code>int i = 1/0</code>即可。如果没有抛异常，异常后通知将不会被执行。</p><p>学习完这5种通知类型，我们来思考下环绕通知是如何实现其他通知类型的功能的?</p><p>因为环绕通知是可以控制原始方法执行的，所以我们把增强的代码写在调用原始方法的不同位置就可以实现不同的通知类型的功能，如:</p><p><img src="/2022/11/26/spring03/1630170090945.png" alt="1630170090945"></p><h5 id="通知类型总结"><a href="#通知类型总结" class="headerlink" title="通知类型总结"></a>通知类型总结</h5><h6 id="知识点1：-After"><a href="#知识点1：-After" class="headerlink" title="知识点1：@After"></a>知识点1：@After</h6><table><thead><tr><th>名称</th><th>@After</th></tr></thead><tbody><tr><td>类型</td><td>方法注解</td></tr><tr><td>位置</td><td>通知方法定义上方</td></tr><tr><td>作用</td><td>设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法后运行</td></tr></tbody></table><h6 id="知识点2：-AfterReturning"><a href="#知识点2：-AfterReturning" class="headerlink" title="知识点2：@AfterReturning"></a>知识点2：@AfterReturning</h6><table><thead><tr><th>名称</th><th>@AfterReturning</th></tr></thead><tbody><tr><td>类型</td><td>方法注解</td></tr><tr><td>位置</td><td>通知方法定义上方</td></tr><tr><td>作用</td><td>设置当前通知方法与切入点之间绑定关系，当前通知方法在原始切入点方法正常执行完毕后执行</td></tr></tbody></table><h6 id="知识点3：-AfterThrowing"><a href="#知识点3：-AfterThrowing" class="headerlink" title="知识点3：@AfterThrowing"></a>知识点3：@AfterThrowing</h6><table><thead><tr><th>名称</th><th>@AfterThrowing</th></tr></thead><tbody><tr><td>类型</td><td>方法注解</td></tr><tr><td>位置</td><td>通知方法定义上方</td></tr><tr><td>作用</td><td>设置当前通知方法与切入点之间绑定关系，当前通知方法在原始切入点方法运行抛出异常后执行</td></tr></tbody></table><h6 id="知识点4：-Around"><a href="#知识点4：-Around" class="headerlink" title="知识点4：@Around"></a>知识点4：@Around</h6><table><thead><tr><th>名称</th><th>@Around</th></tr></thead><tbody><tr><td>类型</td><td>方法注解</td></tr><tr><td>位置</td><td>通知方法定义上方</td></tr><tr><td>作用</td><td>设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法前后运行</td></tr></tbody></table><p>&#x3D;&#x3D;<strong>环绕通知注意事项</strong>&#x3D;&#x3D;</p><ol><li>环绕通知必须依赖形参ProceedingJoinPoint才能实现对原始方法的调用，进而实现原始方法调用前后同时添加通知</li><li>通知中如果未使用ProceedingJoinPoint对原始方法进行调用将跳过原始方法的执行</li><li>对原始方法的调用可以不接收返回值，通知方法设置成void即可，如果接收返回值，最好设定为Object类型</li><li>原始方法的返回值如果是void类型，通知方法的返回值类型可以设置成void,也可以设置成Object</li><li>由于无法预知原始方法运行后是否会抛出异常，因此环绕通知方法必须要处理Throwable异常</li></ol><p>介绍完这么多种通知类型，具体该选哪一种呢?</p><p>我们可以通过一些案例加深下对通知类型的学习。</p><h3 id="4-3-业务层接口执行效率"><a href="#4-3-业务层接口执行效率" class="headerlink" title="4.3 业务层接口执行效率"></a>4.3 业务层接口执行效率</h3><h4 id="4-3-1-需求分析"><a href="#4-3-1-需求分析" class="headerlink" title="4.3.1 需求分析"></a>4.3.1 需求分析</h4><p>这个需求也比较简单，前面我们在介绍AOP的时候已经演示过:</p><ul><li>需求:任意业务层接口执行均可显示其执行效率（执行时长）</li></ul><p>这个案例的目的是查看每个业务层执行的时间，这样就可以监控出哪个业务比较耗时，将其查找出来方便优化。</p><p>具体实现的思路:</p><p>(1) 开始执行方法之前记录一个时间</p><p>(2) 执行方法</p><p>(3) 执行完方法之后记录一个时间</p><p>(4) 用后一个时间减去前一个时间的差值，就是我们需要的结果。</p><p>所以要在方法执行的前后添加业务，经过分析我们将采用<code>环绕通知</code>。</p><p>**说明:**原始方法如果只执行一次，时间太快，两个时间差可能为0，所以我们要执行万次来计算时间差。</p><h4 id="4-3-2-环境准备"><a href="#4-3-2-环境准备" class="headerlink" title="4.3.2 环境准备"></a>4.3.2 环境准备</h4><ul><li><p>创建一个Maven项目</p></li><li><p>pom.xml添加Spring依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>添加AccountService、AccountServiceImpl、AccountDao与Account类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Account account)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Account account)</span>;</span><br><span class="line">    List&lt;Account&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line">    Account <span class="title function_">findById</span><span class="params">(Integer id)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Account account)</span> &#123;</span><br><span class="line">        accountDao.save(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Account account)</span>&#123;</span><br><span class="line">        accountDao.update(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        accountDao.delete(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Account <span class="title function_">findById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accountDao.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Account&gt; <span class="title function_">findAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accountDao.findAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert(&quot;insert into tbl_account(name,money)values(#&#123;name&#125;,#&#123;money&#125;)&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Account account)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Delete(&quot;delete from tbl_account where id = #&#123;id&#125; &quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update(&quot;update tbl_account set name = #&#123;name&#125; , money = #&#123;money&#125; where id = #&#123;id&#125; &quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Account account)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from tbl_account&quot;)</span></span><br><span class="line">    List&lt;Account&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from tbl_account where id = #&#123;id&#125; &quot;)</span></span><br><span class="line">    Account <span class="title function_">findById</span><span class="params">(Integer id)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Double money;</span><br><span class="line">    <span class="comment">//setter..getter..toString方法省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>resources下提供一个jdbc.properties</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/spring_db?useSSL=false</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure></li><li><p>创建相关配置类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Spring配置类:SpringConfig</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="meta">@Import(&#123;JdbcConfig.class,MybatisConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//JdbcConfig配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(driver);</span><br><span class="line">        ds.setUrl(url);</span><br><span class="line">        ds.setUsername(userName);</span><br><span class="line">        ds.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//MybatisConfig配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactoryBean <span class="title function_">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">ssfb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        ssfb.setTypeAliasesPackage(<span class="string">&quot;com.itheima.domain&quot;</span>);</span><br><span class="line">        ssfb.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> ssfb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MapperScannerConfigurer <span class="title function_">mapperScannerConfigurer</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MapperScannerConfigurer</span> <span class="variable">msc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MapperScannerConfigurer</span>();</span><br><span class="line">        msc.setBasePackage(<span class="string">&quot;com.itheima.dao&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> msc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>编写Spring整合Junit的测试类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = SpringConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceTestCase</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountService accountService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFindById</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Account</span> <span class="variable">ac</span> <span class="operator">=</span> accountService.findById(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFindAll</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;Account&gt; all = accountService.findAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>最终创建好的项目结构如下:</p><p><img src="/2022/11/26/spring03/1630214631112.png" alt="1630214631112"></p><h4 id="4-3-3-功能开发"><a href="#4-3-3-功能开发" class="headerlink" title="4.3.3 功能开发"></a>4.3.3 功能开发</h4><h5 id="步骤1-开启SpringAOP的注解功能"><a href="#步骤1-开启SpringAOP的注解功能" class="headerlink" title="步骤1:开启SpringAOP的注解功能"></a>步骤1:开启SpringAOP的注解功能</h5><p>在Spring的主配置文件SpringConfig类中添加注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br></pre></td></tr></table></figure><h5 id="步骤2-创建AOP的通知类"><a href="#步骤2-创建AOP的通知类" class="headerlink" title="步骤2:创建AOP的通知类"></a>步骤2:创建AOP的通知类</h5><ul><li><p>该类要被Spring管理，需要添加@Component</p></li><li><p>要标识该类是一个AOP的切面类，需要添加@Aspect</p></li><li><p>配置切入点表达式，需要添加一个方法，并添加@Pointcut</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProjectAdvice</span> &#123;</span><br><span class="line">    <span class="comment">//配置业务层的所有方法</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.itheima.service.*Service.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">servicePt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runSpeed</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="步骤3-添加环绕通知"><a href="#步骤3-添加环绕通知" class="headerlink" title="步骤3:添加环绕通知"></a>步骤3:添加环绕通知</h5><p>在runSpeed()方法上添加@Around</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProjectAdvice</span> &#123;</span><br><span class="line">    <span class="comment">//配置业务层的所有方法</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.itheima.service.*Service.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">servicePt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//@Around(&quot;ProjectAdvice.servicePt()&quot;) 可以简写为下面的方式</span></span><br><span class="line">    <span class="meta">@Around(&quot;servicePt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">runSpeed</span><span class="params">(ProceedingJoinPoint pjp)</span>&#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**注意:**目前并没有做任何增强</p><h5 id="步骤4-完成核心业务，记录万次执行的时间"><a href="#步骤4-完成核心业务，记录万次执行的时间" class="headerlink" title="步骤4:完成核心业务，记录万次执行的时间"></a>步骤4:完成核心业务，记录万次执行的时间</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProjectAdvice</span> &#123;</span><br><span class="line">    <span class="comment">//配置业务层的所有方法</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.itheima.service.*Service.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">servicePt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//@Around(&quot;ProjectAdvice.servicePt()&quot;) 可以简写为下面的方式</span></span><br><span class="line">    <span class="meta">@Around(&quot;servicePt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runSpeed</span><span class="params">(ProceedingJoinPoint pjp)</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">           pjp.proceed();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;业务层接口万次执行时间: &quot;</span>+(end-start)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="步骤5-运行单元测试类"><a href="#步骤5-运行单元测试类" class="headerlink" title="步骤5:运行单元测试类"></a>步骤5:运行单元测试类</h5><p><img src="/2022/11/26/spring03/1630215355776.png" alt="1630215355776"></p><p>**注意:**因为程序每次执行的时长是不一样的，所以运行多次最终的结果是不一样的。</p><h5 id="步骤6-程序优化"><a href="#步骤6-程序优化" class="headerlink" title="步骤6:程序优化"></a>步骤6:程序优化</h5><p>目前程序所面临的问题是，多个方法一起执行测试的时候，控制台都打印的是:</p><p><code>业务层接口万次执行时间:xxxms</code></p><p>我们没有办法区分到底是哪个接口的哪个方法执行的具体时间，具体如何优化?</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProjectAdvice</span> &#123;</span><br><span class="line">    <span class="comment">//配置业务层的所有方法</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.itheima.service.*Service.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">servicePt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//@Around(&quot;ProjectAdvice.servicePt()&quot;) 可以简写为下面的方式</span></span><br><span class="line">    <span class="meta">@Around(&quot;servicePt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runSpeed</span><span class="params">(ProceedingJoinPoint pjp)</span>&#123;</span><br><span class="line">        <span class="comment">//获取执行签名信息</span></span><br><span class="line">        <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> pjp.getSignature();</span><br><span class="line">        <span class="comment">//通过签名获取执行操作名称(接口名)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> signature.getDeclaringTypeName();</span><br><span class="line">        <span class="comment">//通过签名获取执行操作名称(方法名)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> signature.getName();</span><br><span class="line">        </span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">           pjp.proceed();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;万次执行：&quot;</span>+ className+<span class="string">&quot;.&quot;</span>+methodName+<span class="string">&quot;----&gt;&quot;</span> +(end-start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="步骤7-运行单元测试类"><a href="#步骤7-运行单元测试类" class="headerlink" title="步骤7:运行单元测试类"></a>步骤7:运行单元测试类</h5><p><img src="/2022/11/26/spring03/1630215743444.png" alt="1630215743444"></p><p>&#x3D;&#x3D;补充说明&#x3D;&#x3D;</p><p>当前测试的接口执行效率仅仅是一个理论值，并不是一次完整的执行过程。</p><p>这块只是通过该案例把AOP的使用进行了学习，具体的实际值是有很多因素共同决定的。</p><h3 id="4-4-AOP通知获取数据"><a href="#4-4-AOP通知获取数据" class="headerlink" title="4.4 AOP通知获取数据"></a>4.4 AOP通知获取数据</h3><p>目前我们写AOP仅仅是在原始方法前后追加一些操作，接下来我们要说说AOP中数据相关的内容，我们将从<code>获取参数</code>、<code>获取返回值</code>和<code>获取异常</code>三个方面来研究切入点的相关信息。</p><p>前面我们介绍通知类型的时候总共讲了五种，那么对于这五种类型都会有参数，返回值和异常吗?</p><p>我们先来一个个分析下:</p><ul><li>获取切入点方法的参数，所有的通知类型都可以获取参数<ul><li>JoinPoint：适用于前置、后置、返回后、抛出异常后通知</li><li>ProceedingJoinPoint：适用于环绕通知</li></ul></li><li>获取切入点方法返回值，前置和抛出异常后通知是没有返回值，后置通知可有可无，所以不做研究<ul><li>返回后通知</li><li>环绕通知</li></ul></li><li>获取切入点方法运行异常信息，前置和返回后通知是不会有，后置通知可有可无，所以不做研究<ul><li>抛出异常后通知</li><li>环绕通知</li></ul></li></ul><h4 id="4-4-1-环境准备"><a href="#4-4-1-环境准备" class="headerlink" title="4.4.1 环境准备"></a>4.4.1 环境准备</h4><ul><li><p>创建一个Maven项目</p></li><li><p>pom.xml添加Spring依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>添加BookDao和BookDaoImpl类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findName</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findName</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;id:&quot;</span>+id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;itcast&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建Spring的配置类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima&quot;)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写通知类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.itheima.dao.BookDao.findName(..))&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before advice ...&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after advice ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">()</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@AfterReturning(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterReturning advice ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterThrowing advice ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写App运行类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> ctx.getBean(BookDao.class);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> bookDao.findName(<span class="number">100</span>);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>最终创建好的项目结构如下:</p><p><img src="/2022/11/26/spring03/1630233154992.png" alt="1630233154992"></p><h4 id="4-4-2-获取参数"><a href="#4-4-2-获取参数" class="headerlink" title="4.4.2 获取参数"></a>4.4.2 获取参数</h4><h5 id="非环绕通知获取方式"><a href="#非环绕通知获取方式" class="headerlink" title="非环绕通知获取方式"></a>非环绕通知获取方式</h5><p>在方法上添加JoinPoint,通过JoinPoint来获取参数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.itheima.dao.BookDao.findName(..))&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint jp)</span> </span><br><span class="line">        Object[] args = jp.getArgs();</span><br><span class="line">        System.out.println(Arrays.toString(args));</span><br><span class="line">        System.out.println(<span class="string">&quot;before advice ...&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//...其他的略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行App类，可以获取如下内容，说明参数100已经被获取</p><p><img src="/2022/11/26/spring03/1630233291929.png" alt="1630233291929"></p><p><strong>思考:方法的参数只有一个，为什么获取的是一个数组?</strong></p><p>因为参数的个数是不固定的，所以使用数组更通配些。</p><p>如果将参数改成两个会是什么效果呢?</p><p>(1)修改BookDao接口和BookDaoImpl实现类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findName</span><span class="params">(<span class="type">int</span> id,String password)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findName</span><span class="params">(<span class="type">int</span> id,String password)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;id:&quot;</span>+id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;itcast&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2)修改App类，调用方法传入多个参数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> ctx.getBean(BookDao.class);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> bookDao.findName(<span class="number">100</span>,<span class="string">&quot;itheima&quot;</span>);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(3)运行App，查看结果,说明两个参数都已经被获取到</p><p><img src="/2022/11/26/spring03/1630233548743.png" alt="1630233548743"></p><p><strong>说明:</strong></p><p>使用JoinPoint的方式获取参数适用于<code>前置</code>、<code>后置</code>、<code>返回后</code>、<code>抛出异常后</code>通知。剩下的大家自行去验证。</p><h5 id="环绕通知获取方式"><a href="#环绕通知获取方式" class="headerlink" title="环绕通知获取方式"></a>环绕通知获取方式</h5><p>环绕通知使用的是ProceedingJoinPoint，因为ProceedingJoinPoint是JoinPoint类的子类，所以对于ProceedingJoinPoint类中应该也会有对应的<code>getArgs()</code>方法，我们去验证下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.itheima.dao.BookDao.findName(..))&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span><span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        Object[] args = pjp.getArgs();</span><br><span class="line">        System.out.println(Arrays.toString(args));</span><br><span class="line">        <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//其他的略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行App后查看运行结果，说明ProceedingJoinPoint也是可以通过getArgs()获取参数</p><p><img src="/2022/11/26/spring03/1630233974310.png" alt="1630233974310"></p><p><strong>注意:</strong></p><ul><li><p>pjp.proceed()方法是有两个构造方法，分别是:</p><p><img src="/2022/11/26/spring03/1630234756123.png" alt="1630234756123"></p><ul><li><p>调用无参数的proceed，当原始方法有参数，会在调用的过程中自动传入参数</p></li><li><p>所以调用这两个方法的任意一个都可以完成功能</p></li><li><p>但是当需要修改原始方法的参数时，就只能采用带有参数的方法,如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.itheima.dao.BookDao.findName(..))&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">        Object[] args = pjp.getArgs();</span><br><span class="line">        System.out.println(Arrays.toString(args));</span><br><span class="line">        args[<span class="number">0</span>] = <span class="number">666</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed(args);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//其他的略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这个特性后，我们就可以在环绕通知中对原始方法的参数进行拦截过滤，避免由于参数的问题导致程序无法正确运行，保证代码的健壮性。</p></li></ul></li></ul><h4 id="4-4-3-获取返回值"><a href="#4-4-3-获取返回值" class="headerlink" title="4.4.3 获取返回值"></a>4.4.3 获取返回值</h4><p>对于返回值，只有返回后<code>AfterReturing</code>和环绕<code>Around</code>这两个通知类型可以获取，具体如何获取?</p><h5 id="环绕通知获取返回值"><a href="#环绕通知获取返回值" class="headerlink" title="环绕通知获取返回值"></a>环绕通知获取返回值</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.itheima.dao.BookDao.findName(..))&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">        Object[] args = pjp.getArgs();</span><br><span class="line">        System.out.println(Arrays.toString(args));</span><br><span class="line">        args[<span class="number">0</span>] = <span class="number">666</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed(args);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//其他的略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，<code>ret</code>就是方法的返回值，我们是可以直接获取，不但可以获取，如果需要还可以进行修改。</p><h5 id="返回后通知获取返回值"><a href="#返回后通知获取返回值" class="headerlink" title="返回后通知获取返回值"></a>返回后通知获取返回值</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.itheima.dao.BookDao.findName(..))&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(value = &quot;pt()&quot;,returning = &quot;ret&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">(Object ret)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterReturning advice ...&quot;</span>+ret);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//其他的略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;注意:&#x3D;&#x3D;</p><p>(1)参数名的问题</p><p><img src="/2022/11/26/spring03/1630237320870.png" alt="1630237320870"></p><p>(2)afterReturning方法参数类型的问题</p><p>参数类型可以写成String，但是为了能匹配更多的参数类型，建议写成Object类型</p><p>(3)afterReturning方法参数的顺序问题</p><p><img src="/2022/11/26/spring03/1630237586682.png" alt="1630237586682"></p><p>运行App后查看运行结果，说明返回值已经被获取到</p><p><img src="/2022/11/26/spring03/1630237372286.png" alt="1630237372286"></p><h4 id="4-4-4-获取异常"><a href="#4-4-4-获取异常" class="headerlink" title="4.4.4 获取异常"></a>4.4.4 获取异常</h4><p>对于获取抛出的异常，只有抛出异常后<code>AfterThrowing</code>和环绕<code>Around</code>这两个通知类型可以获取，具体如何获取?</p><h5 id="环绕通知获取异常"><a href="#环绕通知获取异常" class="headerlink" title="环绕通知获取异常"></a>环绕通知获取异常</h5><p>这块比较简单，以前我们是抛出异常，现在只需要将异常捕获，就可以获取到原始方法的异常信息了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.itheima.dao.BookDao.findName(..))&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span>&#123;</span><br><span class="line">        Object[] args = pjp.getArgs();</span><br><span class="line">        System.out.println(Arrays.toString(args));</span><br><span class="line">        args[<span class="number">0</span>] = <span class="number">666</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ret = pjp.proceed(args);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Throwable throwable)&#123;</span><br><span class="line">            t.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//其他的略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在catch方法中就可以获取到异常，至于获取到异常以后该如何处理，这个就和你的业务需求有关了。</p><h5 id="抛出异常后通知获取异常"><a href="#抛出异常后通知获取异常" class="headerlink" title="抛出异常后通知获取异常"></a>抛出异常后通知获取异常</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.itheima.dao.BookDao.findName(..))&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing(value = &quot;pt()&quot;,throwing = &quot;t&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterThrowing advice ...&quot;</span>+t);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//其他的略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何让原始方法抛出异常，方式有很多，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findName</span><span class="params">(<span class="type">int</span> id,String password)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;id:&quot;</span>+id);</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;itcast&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;注意:&#x3D;&#x3D;</p><p><img src="/2022/11/26/spring03/1630239939043.png" alt="1630239939043"></p><p>运行App后，查看控制台，就能看的异常信息被打印到控制台</p><p><img src="/2022/11/26/spring03/1630239997560.png" alt="1630239997560"></p><p>至此，AOP通知如何获取数据就已经讲解完了，数据中包含<code>参数</code>、<code>返回值</code>、<code>异常(了解)</code>。</p><h3 id="4-5-百度网盘密码数据兼容处理"><a href="#4-5-百度网盘密码数据兼容处理" class="headerlink" title="4.5 百度网盘密码数据兼容处理"></a>4.5 百度网盘密码数据兼容处理</h3><h4 id="4-5-1-需求分析"><a href="#4-5-1-需求分析" class="headerlink" title="4.5.1 需求分析"></a>4.5.1 需求分析</h4><p>需求: 对百度网盘分享链接输入密码时尾部多输入的空格做兼容处理。</p><p><img src="/2022/11/26/spring03/1630240203033.png" alt="1630240203033"></p><p>问题描述:</p><ul><li><p>点击链接，会提示，请输入提取码，如下图所示</p><p><img src="/2022/11/26/spring03/1630240528228.png" alt="1630240528228"></p></li><li><p>当我们从别人发给我们的内容中复制提取码的时候，有时候会多复制到一些空格，直接粘贴到百度的提取码输入框</p></li><li><p>但是百度那边记录的提取码是没有空格的</p></li><li><p>这个时候如果不做处理，直接对比的话，就会引发提取码不一致，导致无法访问百度盘上的内容</p></li><li><p>所以多输入一个空格可能会导致项目的功能无法正常使用。</p></li><li><p>此时我们就想能不能将输入的参数先帮用户去掉空格再操作呢?</p></li></ul><p>答案是可以的，我们只需要在业务方法执行之前对所有的输入参数进行格式处理——trim()</p><ul><li>是对所有的参数都需要去除空格么?</li></ul><p>也没有必要，一般只需要针对字符串处理即可。</p><ul><li>以后涉及到需要去除前后空格的业务可能会有很多，这个去空格的代码是每个业务都写么?</li></ul><p>可以考虑使用AOP来统一处理。</p><ul><li>AOP有五种通知类型，该使用哪种呢?</li></ul><p>我们的需求是将原始方法的参数处理后在参与原始方法的调用，能做这件事的就只有环绕通知。</p><p>综上所述，我们需要考虑两件事:<br>①：在业务方法执行之前对所有的输入参数进行格式处理——trim()<br>②：使用处理后的参数调用原始方法——环绕通知中存在对原始方法的调用</p><h4 id="4-5-2-环境准备"><a href="#4-5-2-环境准备" class="headerlink" title="4.5.2 环境准备"></a>4.5.2 环境准备</h4><ul><li><p>创建一个Maven项目</p></li><li><p>pom.xml添加Spring依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>添加ResourcesService，ResourcesServiceImpl,ResourcesDao和ResourcesDaoImpl类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ResourcesDao</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">readResources</span><span class="params">(String url, String password)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResourcesDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">ResourcesDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">readResources</span><span class="params">(String url, String password)</span> &#123;</span><br><span class="line">        <span class="comment">//模拟校验</span></span><br><span class="line">        <span class="keyword">return</span> password.equals(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ResourcesService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">openURL</span><span class="params">(String url ,String password)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResourcesServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">ResourcesService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ResourcesDao resourcesDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">openURL</span><span class="params">(String url, String password)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> resourcesDao.readResources(url,password);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>创建Spring的配置类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写App运行类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">ResourcesService</span> <span class="variable">resourcesService</span> <span class="operator">=</span> ctx.getBean(ResourcesService.class);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> resourcesService.openURL(<span class="string">&quot;http://pan.baidu.com/haha&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">        System.out.println(flag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>最终创建好的项目结构如下:</p><p><img src="/2022/11/26/spring03/1630241681697.png" alt="1630241681697"></p><p>现在项目的效果是，当输入密码为”root”控制台打印为true,如果密码改为”root  “控制台打印的是false</p><p>需求是使用AOP将参数进行统一处理，不管输入的密码<code>root</code>前后包含多少个空格，最终控制台打印的都是true。</p><h4 id="4-5-3-具体实现"><a href="#4-5-3-具体实现" class="headerlink" title="4.5.3 具体实现"></a>4.5.3 具体实现</h4><h5 id="步骤1-开启SpringAOP的注解功能-1"><a href="#步骤1-开启SpringAOP的注解功能-1" class="headerlink" title="步骤1:开启SpringAOP的注解功能"></a>步骤1:开启SpringAOP的注解功能</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima&quot;)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="步骤2-编写通知类"><a href="#步骤2-编写通知类" class="headerlink" title="步骤2:编写通知类"></a>步骤2:编写通知类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(boolean com.itheima.service.*Service.*(*,*))&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">servicePt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="步骤3-添加环绕通知-1"><a href="#步骤3-添加环绕通知-1" class="headerlink" title="步骤3:添加环绕通知"></a>步骤3:添加环绕通知</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(boolean com.itheima.service.*Service.*(*,*))&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">servicePt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Around(&quot;DataAdvice.servicePt()&quot;)</span></span><br><span class="line">    <span class="comment">// @Around(&quot;servicePt()&quot;)这两种写法都对</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">trimStr</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="步骤4-完成核心业务，处理参数中的空格"><a href="#步骤4-完成核心业务，处理参数中的空格" class="headerlink" title="步骤4:完成核心业务，处理参数中的空格"></a>步骤4:完成核心业务，处理参数中的空格</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(boolean com.itheima.service.*Service.*(*,*))&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">servicePt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Around(&quot;DataAdvice.servicePt()&quot;)</span></span><br><span class="line">    <span class="comment">// @Around(&quot;servicePt()&quot;)这两种写法都对</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">trimStr</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">//获取原始方法的参数</span></span><br><span class="line">        Object[] args = pjp.getArgs();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">            <span class="comment">//判断参数是不是字符串</span></span><br><span class="line">            <span class="keyword">if</span>(args[i].getClass().equals(String.class))&#123;</span><br><span class="line">                args[i] = args[i].toString().trim();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将修改后的参数传入到原始方法的执行中</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed(args);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="步骤5-运行程序-1"><a href="#步骤5-运行程序-1" class="headerlink" title="步骤5:运行程序"></a>步骤5:运行程序</h5><p>不管密码<code>root</code>前后是否加空格，最终控制台打印的都是true</p><h5 id="步骤6-优化测试"><a href="#步骤6-优化测试" class="headerlink" title="步骤6:优化测试"></a>步骤6:优化测试</h5><p>为了能更好的看出AOP已经生效，我们可以修改ResourcesImpl类，在方法中将密码的长度进行打印</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResourcesDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">ResourcesDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">readResources</span><span class="params">(String url, String password)</span> &#123;</span><br><span class="line">        System.out.println(password.length());</span><br><span class="line">        <span class="comment">//模拟校验</span></span><br><span class="line">        <span class="keyword">return</span> password.equals(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行成功，就可以根据最终打印的长度来看看，字符串的空格有没有被去除掉。</p><p><strong>注意：</strong></p><p><img src="/2022/11/26/spring03/1630242491831.png" alt="1630242491831"></p><h2 id="5，AOP总结"><a href="#5，AOP总结" class="headerlink" title="5，AOP总结"></a>5，AOP总结</h2><p>AOP的知识就已经讲解完了，接下来对于AOP的知识进行一个总结:</p><h3 id="5-1-AOP的核心概念"><a href="#5-1-AOP的核心概念" class="headerlink" title="5.1 AOP的核心概念"></a>5.1 AOP的核心概念</h3><ul><li>概念：AOP(Aspect Oriented Programming)面向切面编程，一种编程范式</li><li>作用：在不惊动原始设计的基础上为方法进行功能&#x3D;&#x3D;增强&#x3D;&#x3D;</li><li>核心概念<ul><li>代理（Proxy）：SpringAOP的核心本质是采用代理模式实现的</li><li>连接点（JoinPoint）：在SpringAOP中，理解为任意方法的执行</li><li>切入点（Pointcut）：匹配连接点的式子，也是具有共性功能的方法描述</li><li>通知（Advice）：若干个方法的共性功能，在切入点处执行，最终体现为一个方法</li><li>切面（Aspect）：描述通知与切入点的对应关系</li><li>目标对象（Target）：被代理的原始对象成为目标对象</li></ul></li></ul><h3 id="5-2-切入点表达式"><a href="#5-2-切入点表达式" class="headerlink" title="5.2 切入点表达式"></a>5.2 切入点表达式</h3><ul><li><p>切入点表达式标准格式：动作关键字(访问修饰符  返回值  包名.类&#x2F;接口名.方法名（参数）异常名)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">execution(* com.itheima.service.*Service.*(..))</span><br></pre></td></tr></table></figure></li><li><p>切入点表达式描述通配符：</p><ul><li>作用：用于快速描述，范围描述</li><li><code>*</code>：匹配任意符号（常用）</li><li><code>..</code> ：匹配多个连续的任意符号（常用）</li><li><code>+</code>：匹配子类类型</li></ul></li><li><p>切入点表达式书写技巧</p><p>1.按&#x3D;&#x3D;标准规范&#x3D;&#x3D;开发<br>2.查询操作的返回值建议使用*匹配<br>3.减少使用..的形式描述包<br>4.&#x3D;&#x3D;对接口进行描述&#x3D;&#x3D;，使用*表示模块名，例如UserService的匹配描述为*Service<br>5.方法名书写保留动词，例如get，使用*表示名词，例如getById匹配描述为getBy*<br>6.参数根据实际情况灵活调整</p></li></ul><h3 id="5-3-五种通知类型"><a href="#5-3-五种通知类型" class="headerlink" title="5.3 五种通知类型"></a>5.3 五种通知类型</h3><ul><li>前置通知</li><li>后置通知</li><li>环绕通知（重点）<ul><li>环绕通知依赖形参ProceedingJoinPoint才能实现对原始方法的调用</li><li>环绕通知可以隔离原始方法的调用执行</li><li>环绕通知返回值设置为Object类型</li><li>环绕通知中可以对原始方法调用过程中出现的异常进行处理</li></ul></li><li>返回后通知</li><li>抛出异常后通知</li></ul><h3 id="5-4-通知中获取参数"><a href="#5-4-通知中获取参数" class="headerlink" title="5.4 通知中获取参数"></a>5.4 通知中获取参数</h3><ul><li>获取切入点方法的参数，所有的通知类型都可以获取参数<ul><li>JoinPoint：适用于前置、后置、返回后、抛出异常后通知</li><li>ProceedingJoinPoint：适用于环绕通知</li></ul></li><li>获取切入点方法返回值，前置和抛出异常后通知是没有返回值，后置通知可有可无，所以不做研究<ul><li>返回后通知</li><li>环绕通知</li></ul></li><li>获取切入点方法运行异常信息，前置和返回后通知是不会有，后置通知可有可无，所以不做研究<ul><li>抛出异常后通知</li><li>环绕通知</li></ul></li></ul><h2 id="6，AOP事务管理"><a href="#6，AOP事务管理" class="headerlink" title="6，AOP事务管理"></a>6，AOP事务管理</h2><h3 id="6-1-Spring事务简介"><a href="#6-1-Spring事务简介" class="headerlink" title="6.1 Spring事务简介"></a>6.1 Spring事务简介</h3><h4 id="6-1-1-相关概念介绍"><a href="#6-1-1-相关概念介绍" class="headerlink" title="6.1.1 相关概念介绍"></a>6.1.1 相关概念介绍</h4><ul><li>事务作用：在数据层保障一系列的数据库操作同成功同失败</li><li>Spring事务作用：在数据层或**&#x3D;&#x3D;业务层&#x3D;&#x3D;**保障一系列的数据库操作同成功同失败</li></ul><p>数据层有事务我们可以理解，为什么业务层也需要处理事务呢?</p><p>举个简单的例子，</p><ul><li>转账业务会有两次数据层的调用，一次是加钱一次是减钱</li><li>把事务放在数据层，加钱和减钱就有两个事务</li><li>没办法保证加钱和减钱同时成功或者同时失败</li><li>这个时候就需要将事务放在业务层进行处理。</li></ul><p>Spring为了管理事务，提供了一个平台事务管理器<code>PlatformTransactionManager</code></p><p><img src="/2022/11/26/spring03/1630243651541.png" alt="1630243651541"></p><p>commit是用来提交事务，rollback是用来回滚事务。</p><p>PlatformTransactionManager只是一个接口，Spring还为其提供了一个具体的实现:</p><p><img src="/2022/11/26/spring03/1630243993380.png" alt="1630243993380"></p><p>从名称上可以看出，我们只需要给它一个DataSource对象，它就可以帮你去在业务层管理事务。其内部采用的是JDBC的事务。所以说如果你持久层采用的是JDBC相关的技术，就可以采用这个事务管理器来管理你的事务。而Mybatis内部采用的就是JDBC的事务，所以后期我们Spring整合Mybatis就采用的这个DataSourceTransactionManager事务管理器。</p><h4 id="6-1-2-转账案例-需求分析"><a href="#6-1-2-转账案例-需求分析" class="headerlink" title="6.1.2 转账案例-需求分析"></a>6.1.2 转账案例-需求分析</h4><p>接下来通过一个案例来学习下Spring是如何来管理事务的。</p><p>先来分析下需求:</p><p>需求: 实现任意两个账户间转账操作</p><p>需求微缩: A账户减钱，B账户加钱</p><p>为了实现上述的业务需求，我们可以按照下面步骤来实现下:<br>①：数据层提供基础操作，指定账户减钱（outMoney），指定账户加钱（inMoney）</p><p>②：业务层提供转账操作（transfer），调用减钱与加钱的操作</p><p>③：提供2个账号和操作金额执行转账操作</p><p>④：基于Spring整合MyBatis环境搭建上述操作</p><h4 id="6-1-3-转账案例-环境搭建"><a href="#6-1-3-转账案例-环境搭建" class="headerlink" title="6.1.3 转账案例-环境搭建"></a>6.1.3 转账案例-环境搭建</h4><h5 id="步骤1-准备数据库表"><a href="#步骤1-准备数据库表" class="headerlink" title="步骤1:准备数据库表"></a>步骤1:准备数据库表</h5><p>之前我们在整合Mybatis的时候已经创建了这个表,可以直接使用</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database spring_db <span class="type">character</span> <span class="keyword">set</span> utf8;</span><br><span class="line">use spring_db;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tbl_account(</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">35</span>),</span><br><span class="line">    money <span class="keyword">double</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tbl_account <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;Tom&#x27;</span>,<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tbl_account <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;Jerry&#x27;</span>,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><h5 id="步骤2-创建项目导入jar包"><a href="#步骤2-创建项目导入jar包" class="headerlink" title="步骤2:创建项目导入jar包"></a>步骤2:创建项目导入jar包</h5><p>项目的pom.xml添加相关依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="步骤3-根据表创建模型类"><a href="#步骤3-根据表创建模型类" class="headerlink" title="步骤3:根据表创建模型类"></a>步骤3:根据表创建模型类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Double money;</span><br><span class="line"><span class="comment">//setter...getter...toString...方法略    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="步骤4-创建Dao接口"><a href="#步骤4-创建Dao接口" class="headerlink" title="步骤4:创建Dao接口"></a>步骤4:创建Dao接口</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update(&quot;update tbl_account set money = money + #&#123;money&#125; where name = #&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">inMoney</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name, <span class="meta">@Param(&quot;money&quot;)</span> Double money)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update(&quot;update tbl_account set money = money - #&#123;money&#125; where name = #&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">outMoney</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name, <span class="meta">@Param(&quot;money&quot;)</span> Double money)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="步骤5-创建Service接口和实现类"><a href="#步骤5-创建Service接口和实现类" class="headerlink" title="步骤5:创建Service接口和实现类"></a>步骤5:创建Service接口和实现类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 转账操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> out 传出方</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> in 转入方</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money 金额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String out,String in ,Double money)</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String out,String in ,Double money)</span> &#123;</span><br><span class="line">        accountDao.outMoney(out,money);</span><br><span class="line">        accountDao.inMoney(in,money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="步骤6-添加jdbc-properties文件"><a href="#步骤6-添加jdbc-properties文件" class="headerlink" title="步骤6:添加jdbc.properties文件"></a>步骤6:添加jdbc.properties文件</h5><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/spring_db?useSSL=false</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure><h5 id="步骤7-创建JdbcConfig配置类"><a href="#步骤7-创建JdbcConfig配置类" class="headerlink" title="步骤7:创建JdbcConfig配置类"></a>步骤7:创建JdbcConfig配置类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(driver);</span><br><span class="line">        ds.setUrl(url);</span><br><span class="line">        ds.setUsername(userName);</span><br><span class="line">        ds.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="步骤8-创建MybatisConfig配置类"><a href="#步骤8-创建MybatisConfig配置类" class="headerlink" title="步骤8:创建MybatisConfig配置类"></a>步骤8:创建MybatisConfig配置类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactoryBean <span class="title function_">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">ssfb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        ssfb.setTypeAliasesPackage(<span class="string">&quot;com.itheima.domain&quot;</span>);</span><br><span class="line">        ssfb.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> ssfb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MapperScannerConfigurer <span class="title function_">mapperScannerConfigurer</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MapperScannerConfigurer</span> <span class="variable">msc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MapperScannerConfigurer</span>();</span><br><span class="line">        msc.setBasePackage(<span class="string">&quot;com.itheima.dao&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> msc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="步骤9-创建SpringConfig配置类"><a href="#步骤9-创建SpringConfig配置类" class="headerlink" title="步骤9:创建SpringConfig配置类"></a>步骤9:创建SpringConfig配置类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="meta">@Import(&#123;JdbcConfig.class,MybatisConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="步骤10-编写测试类"><a href="#步骤10-编写测试类" class="headerlink" title="步骤10:编写测试类"></a>步骤10:编写测试类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = SpringConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountService accountService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTransfer</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        accountService.transfer(<span class="string">&quot;Tom&quot;</span>,<span class="string">&quot;Jerry&quot;</span>,<span class="number">100D</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终创建好的项目结构如下:</p><p><img src="/2022/11/26/spring03/1630247220645.png" alt="1630247220645"></p><h4 id="6-1-4-事务管理"><a href="#6-1-4-事务管理" class="headerlink" title="6.1.4 事务管理"></a>6.1.4 事务管理</h4><p>上述环境，运行单元测试类，会执行转账操作，<code>Tom</code>的账户会减少100，<code>Jerry</code>的账户会加100。</p><p>这是正常情况下的运行结果，但是如果在转账的过程中出现了异常，如:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String out,String in ,Double money)</span> &#123;</span><br><span class="line">        accountDao.outMoney(out,money);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">        accountDao.inMoney(in,money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候就模拟了转账过程中出现异常的情况，正确的操作应该是转账出问题了，<code>Tom</code>应该还是900，<code>Jerry</code>应该还是1100，但是真正运行后会发现，并没有像我们想象的那样，<code>Tom</code>账户为800而<code>Jerry</code>还是1100,100块钱凭空消息了，银行乐疯了。如果把转账换个顺序，银行就该哭了。</p><p>不管哪种情况，都是不允许出现的，对刚才的结果我们做一个分析:</p><p>①：程序正常执行时，账户金额A减B加，没有问题</p><p>②：程序出现异常后，转账失败，但是异常之前操作成功，异常之后操作失败，整体业务失败</p><p>当程序出问题后，我们需要让事务进行回滚，而且这个事务应该是加在业务层上，而Spring的事务管理就是用来解决这类问题的。</p><p>Spring事务管理具体的实现步骤为:</p><h5 id="步骤1-在需要被事务管理的方法上添加注解"><a href="#步骤1-在需要被事务管理的方法上添加注解" class="headerlink" title="步骤1:在需要被事务管理的方法上添加注解"></a>步骤1:在需要被事务管理的方法上添加注解</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 转账操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> out 传出方</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> in 转入方</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money 金额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//配置当前接口方法具有事务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String out,String in ,Double money)</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String out,String in ,Double money)</span> &#123;</span><br><span class="line">        accountDao.outMoney(out,money);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">        accountDao.inMoney(in,money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;注意:&#x3D;&#x3D;</p><p>@Transactional可以写在接口类上、接口方法上、实现类上和实现类方法上</p><ul><li>写在接口类上，该接口的所有实现类的所有方法都会有事务</li><li>写在接口方法上，该接口的所有实现类的该方法都会有事务</li><li>写在实现类上，该类中的所有方法都会有事务</li><li>写在实现类方法上，该方法上有事务</li><li>&#x3D;&#x3D;建议写在实现类或实现类的方法上&#x3D;&#x3D;</li></ul><h5 id="步骤2-在JdbcConfig类中配置事务管理器"><a href="#步骤2-在JdbcConfig类中配置事务管理器" class="headerlink" title="步骤2:在JdbcConfig类中配置事务管理器"></a>步骤2:在JdbcConfig类中配置事务管理器</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(driver);</span><br><span class="line">        ds.setUrl(url);</span><br><span class="line">        ds.setUsername(userName);</span><br><span class="line">        ds.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置事务管理器，mybatis使用的是jdbc事务</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PlatformTransactionManager <span class="title function_">transactionManager</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">DataSourceTransactionManager</span> <span class="variable">transactionManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>();</span><br><span class="line">        transactionManager.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> transactionManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>事务管理器要根据使用技术进行选择，Mybatis框架使用的是JDBC事务，可以直接使用<code>DataSourceTransactionManager</code></p><h5 id="步骤3：开启事务注解"><a href="#步骤3：开启事务注解" class="headerlink" title="步骤3：开启事务注解"></a>步骤3：开启事务注解</h5><p>在SpringConfig的配置类中开启</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="meta">@Import(&#123;JdbcConfig.class,MybatisConfig.class</span></span><br><span class="line"><span class="meta">//开启注解式事务驱动</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">public class SpringConfig &#123;</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta"></span></span><br></pre></td></tr></table></figure><h5 id="步骤4-运行测试类"><a href="#步骤4-运行测试类" class="headerlink" title="步骤4:运行测试类"></a>步骤4:运行测试类</h5><p>会发现在转换的业务出现错误后，事务就可以控制回顾，保证数据的正确性。</p><h5 id="知识点1：-EnableTransactionManagement"><a href="#知识点1：-EnableTransactionManagement" class="headerlink" title="知识点1：@EnableTransactionManagement"></a>知识点1：@EnableTransactionManagement</h5><table><thead><tr><th>名称</th><th>@EnableTransactionManagement</th></tr></thead><tbody><tr><td>类型</td><td>配置类注解</td></tr><tr><td>位置</td><td>配置类定义上方</td></tr><tr><td>作用</td><td>设置当前Spring环境中开启注解式事务支持</td></tr></tbody></table><h5 id="知识点2：-Transactional"><a href="#知识点2：-Transactional" class="headerlink" title="知识点2：@Transactional"></a>知识点2：@Transactional</h5><table><thead><tr><th>名称</th><th>@Transactional</th></tr></thead><tbody><tr><td>类型</td><td>接口注解  类注解  方法注解</td></tr><tr><td>位置</td><td>业务层接口上方  业务层实现类上方  业务方法上方</td></tr><tr><td>作用</td><td>为当前业务层方法添加事务（如果设置在类或接口上方则类或接口中所有方法均添加事务）</td></tr></tbody></table><h3 id="6-2-Spring事务角色"><a href="#6-2-Spring事务角色" class="headerlink" title="6.2 Spring事务角色"></a>6.2 Spring事务角色</h3><p>这节中我们重点要理解两个概念，分别是<code>事务管理员</code>和<code>事务协调员</code>。</p><ol><li>未开启Spring事务之前:</li></ol><p><img src="/2022/11/26/spring03/1630248794837.png" alt="1630248794837"></p><ul><li>AccountDao的outMoney因为是修改操作，会开启一个事务T1</li><li>AccountDao的inMoney因为是修改操作，会开启一个事务T2</li><li>AccountService的transfer没有事务，<ul><li>运行过程中如果没有抛出异常，则T1和T2都正常提交，数据正确</li><li>如果在两个方法中间抛出异常，T1因为执行成功提交事务，T2因为抛异常不会被执行</li><li>就会导致数据出现错误</li></ul></li></ul><ol start="2"><li>开启Spring的事务管理后</li></ol><p><img src="/2022/11/26/spring03/1630249111055.png" alt="1630249111055"></p><ul><li>transfer上添加了@Transactional注解，在该方法上就会有一个事务T</li><li>AccountDao的outMoney方法的事务T1加入到transfer的事务T中</li><li>AccountDao的inMoney方法的事务T2加入到transfer的事务T中</li><li>这样就保证他们在同一个事务中，当业务层中出现异常，整个事务就会回滚，保证数据的准确性。</li></ul><p>通过上面例子的分析，我们就可以得到如下概念:</p><ul><li>事务管理员：发起事务方，在Spring中通常指代业务层开启事务的方法</li><li>事务协调员：加入事务方，在Spring中通常指代数据层方法，也可以是业务层方法</li></ul><p>&#x3D;&#x3D;注意:&#x3D;&#x3D;</p><p>目前的事务管理是基于<code>DataSourceTransactionManager</code>和<code>SqlSessionFactoryBean</code>使用的是同一个数据源。</p><h3 id="6-3-Spring事务属性"><a href="#6-3-Spring事务属性" class="headerlink" title="6.3 Spring事务属性"></a>6.3 Spring事务属性</h3><p>上一节我们介绍了两个概念，事务的管理员和事务的协同员，对于这两个概念具体做什么的，我们待会通过案例来使用下。除了这两个概念，还有就是事务的其他相关配置都有哪些，就是我们接下来要学习的内容。</p><p>在这一节中，我们主要学习三部分内容<code>事务配置</code>、<code>转账业务追加日志</code>、<code>事务传播行为</code>。</p><h4 id="6-3-1-事务配置"><a href="#6-3-1-事务配置" class="headerlink" title="6.3.1 事务配置"></a>6.3.1 事务配置</h4><p><img src="/2022/11/26/spring03/1630250069844.png" alt="1630250069844"></p><p>上面这些属性都可以在<code>@Transactional</code>注解的参数上进行设置。</p><ul><li><p>readOnly：true只读事务，false读写事务，增删改要设为false,查询设为true。</p></li><li><p>timeout:设置超时时间单位秒，在多长时间之内事务没有提交成功就自动回滚，-1表示不设置超时时间。</p></li><li><p>rollbackFor:当出现指定异常进行事务回滚</p></li><li><p>noRollbackFor:当出现指定异常不进行事务回滚</p><ul><li><p>思考:出现异常事务会自动回滚，这个是我们之前就已经知道的</p></li><li><p>noRollbackFor是设定对于指定的异常不回滚，这个好理解</p></li><li><p>rollbackFor是指定回滚异常，对于异常事务不应该都回滚么，为什么还要指定?</p><ul><li><p>这块需要更正一个知识点，并不是所有的异常都会回滚事务，比如下面的代码就不会回滚</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 转账操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> out 传出方</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> in 转入方</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money 金额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//配置当前接口方法具有事务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String out,String in ,Double money)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String out,String in ,Double money)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        accountDao.outMoney(out,money);</span><br><span class="line">        <span class="comment">//int i = 1/0; //这个异常事务会回滚</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(); <span class="comment">//这个异常事务就不会回滚</span></span><br><span class="line">        &#125;</span><br><span class="line">        accountDao.inMoney(in,money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>出现这个问题的原因是，Spring的事务只会对<code>Error异常</code>和<code>RuntimeException异常</code>及其子类进行事务回顾，其他的异常类型是不会回滚的，对应IOException不符合上述条件所以不回滚</p><ul><li><p>此时就可以使用rollbackFor属性来设置出现IOException异常不回滚</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"> <span class="meta">@Transactional(rollbackFor = &#123;IOException.class&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String out,String in ,Double money)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        accountDao.outMoney(out,money);</span><br><span class="line">        <span class="comment">//int i = 1/0; //这个异常事务会回滚</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(); <span class="comment">//这个异常事务就不会回滚</span></span><br><span class="line">        &#125;</span><br><span class="line">        accountDao.inMoney(in,money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>rollbackForClassName等同于rollbackFor,只不过属性为异常的类全名字符串</p></li><li><p>noRollbackForClassName等同于noRollbackFor，只不过属性为异常的类全名字符串</p></li><li><p>isolation设置事务的隔离级别</p><ul><li>DEFAULT   :默认隔离级别, 会采用数据库的隔离级别</li><li>READ_UNCOMMITTED : 读未提交</li><li>READ_COMMITTED : 读已提交</li><li>REPEATABLE_READ : 重复读取</li><li>SERIALIZABLE: 串行化</li></ul></li></ul><p>介绍完上述属性后，还有最后一个事务的传播行为，为了讲解该属性的设置，我们需要完成下面的案例。</p><h4 id="6-3-2-转账业务追加日志案例"><a href="#6-3-2-转账业务追加日志案例" class="headerlink" title="6.3.2 转账业务追加日志案例"></a>6.3.2 转账业务追加日志案例</h4><h5 id="6-3-2-1-需求分析"><a href="#6-3-2-1-需求分析" class="headerlink" title="6.3.2.1 需求分析"></a>6.3.2.1 需求分析</h5><p>在前面的转案例的基础上添加新的需求，完成转账后记录日志。</p><ul><li>需求：实现任意两个账户间转账操作，并对每次转账操作在数据库进行留痕</li><li>需求微缩：A账户减钱，B账户加钱，数据库记录日志</li></ul><p>基于上述的业务需求，我们来分析下该如何实现:</p><p>①：基于转账操作案例添加日志模块，实现数据库中记录日志</p><p>②：业务层转账操作（transfer），调用减钱、加钱与记录日志功能</p><p>需要注意一点就是，我们这个案例的预期效果为:</p><p>&#x3D;&#x3D;无论转账操作是否成功，均进行转账操作的日志留痕&#x3D;&#x3D;</p><h5 id="6-3-2-2-环境准备"><a href="#6-3-2-2-环境准备" class="headerlink" title="6.3.2.2 环境准备"></a>6.3.2.2 环境准备</h5><p>该环境是基于转账环境来完成的，所以环境的准备可以参考<code>6.1.3的环境搭建步骤</code>，在其基础上，我们继续往下写</p><h6 id="步骤1-创建日志表"><a href="#步骤1-创建日志表" class="headerlink" title="步骤1:创建日志表"></a>步骤1:创建日志表</h6><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tbl_log(</span><br><span class="line">   id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">   info <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">   createDate datetime</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h6 id="步骤2-添加LogDao接口"><a href="#步骤2-添加LogDao接口" class="headerlink" title="步骤2:添加LogDao接口"></a>步骤2:添加LogDao接口</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LogDao</span> &#123;</span><br><span class="line">    <span class="meta">@Insert(&quot;insert into tbl_log (info,createDate) values(#&#123;info&#125;,now())&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String info)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="步骤3-添加LogService接口与实现类"><a href="#步骤3-添加LogService接口与实现类" class="headerlink" title="步骤3:添加LogService接口与实现类"></a>步骤3:添加LogService接口与实现类</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LogService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String out, String in, Double money)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">LogService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LogDao logDao;</span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String out,String in,Double money )</span> &#123;</span><br><span class="line">        logDao.log(<span class="string">&quot;转账操作由&quot;</span>+out+<span class="string">&quot;到&quot;</span>+in+<span class="string">&quot;,金额：&quot;</span>+money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="步骤4-在转账的业务中添加记录日志"><a href="#步骤4-在转账的业务中添加记录日志" class="headerlink" title="步骤4:在转账的业务中添加记录日志"></a>步骤4:在转账的业务中添加记录日志</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 转账操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> out 传出方</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> in 转入方</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money 金额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//配置当前接口方法具有事务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String out,String in ,Double money)</span><span class="keyword">throws</span> IOException ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LogService logService;</span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String out,String in ,Double money)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            accountDao.outMoney(out,money);</span><br><span class="line">            accountDao.inMoney(in,money);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            logService.log(out,in,money);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="步骤5-运行程序-2"><a href="#步骤5-运行程序-2" class="headerlink" title="步骤5:运行程序"></a>步骤5:运行程序</h6><ul><li><p>当程序正常运行，tbl_account表中转账成功，tbl_log表中日志记录成功</p></li><li><p>当转账业务之间出现异常(int i &#x3D;1&#x2F;0),转账失败，tbl_account成功回滚，但是tbl_log表未添加数据</p></li><li><p>这个结果和我们想要的不一样，什么原因?该如何解决?</p></li><li><p>失败原因:日志的记录与转账操作隶属同一个事务，同成功同失败</p></li><li><p>最终效果:无论转账操作是否成功，日志必须保留</p></li></ul><h4 id="6-3-3-事务传播行为"><a href="#6-3-3-事务传播行为" class="headerlink" title="6.3.3 事务传播行为"></a>6.3.3 事务传播行为</h4><p><img src="/2022/11/26/spring03/1630253779575.png" alt="1630253779575"></p><p>对于上述案例的分析:</p><ul><li>log方法、inMoney方法和outMoney方法都属于增删改，分别有事务T1,T2,T3</li><li>transfer因为加了@Transactional注解，也开启了事务T</li><li>前面我们讲过Spring事务会把T1,T2,T3都加入到事务T中</li><li>所以当转账失败后，所有的事务都回滚，导致日志没有记录下来</li><li>这和我们的需求不符，这个时候我们就想能不能让log方法单独是一个事务呢?</li></ul><p>要想解决这个问题，就需要用到事务传播行为，所谓的事务传播行为指的是:</p><p>事务传播行为：事务协调员对事务管理员所携带事务的处理态度。</p><p>具体如何解决，就需要用到之前我们没有说的<code>propagation属性</code>。</p><h5 id="1-修改logService改变事务的传播行为"><a href="#1-修改logService改变事务的传播行为" class="headerlink" title="1.修改logService改变事务的传播行为"></a>1.修改logService改变事务的传播行为</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">LogService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LogDao logDao;</span><br><span class="line"><span class="comment">//propagation设置事务属性：传播行为设置为当前操作需要新事务</span></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String out,String in,Double money )</span> &#123;</span><br><span class="line">        logDao.log(<span class="string">&quot;转账操作由&quot;</span>+out+<span class="string">&quot;到&quot;</span>+in+<span class="string">&quot;,金额：&quot;</span>+money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后，就能实现我们想要的结果，不管转账是否成功，都会记录日志。</p><h5 id="2-事务传播行为的可选值"><a href="#2-事务传播行为的可选值" class="headerlink" title="2.事务传播行为的可选值"></a>2.事务传播行为的可选值</h5><p><img src="/2022/11/26/spring03/1630254257628.png" alt="1630254257628"></p><p>对于我们开发实际中使用的话，因为默认值需要事务是常态的。根据开发过程选择其他的就可以了，例如案例中需要新事务就需要手工配置。其实入账和出账操作上也有事务，采用的就是默认值。</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>spring02</title>
      <link href="/2022/11/26/spring02/"/>
      <url>/2022/11/26/spring02/</url>
      
        <content type="html"><![CDATA[<h1 id="spring-02"><a href="#spring-02" class="headerlink" title="spring 02"></a>spring 02</h1><h2 id="1，IOC-x2F-DI配置管理第三方bean"><a href="#1，IOC-x2F-DI配置管理第三方bean" class="headerlink" title="1，IOC&#x2F;DI配置管理第三方bean"></a>1，IOC&#x2F;DI配置管理第三方bean</h2><p>前面所讲的知识点都是基于我们自己写的类，现在如果有需求让我们去管理第三方jar包中的类，该如何管理?</p><h3 id="1-1-案例-数据源对象管理"><a href="#1-1-案例-数据源对象管理" class="headerlink" title="1.1 案例:数据源对象管理"></a>1.1 案例:数据源对象管理</h3><p>在这一节中，我们将通过一个案例来学习下对于第三方bean该如何进行配置管理。</p><p>以后我们会用到很多第三方的bean,本次案例将使用咱们前面提到过的数据源<code>Druid(德鲁伊)</code>和<code>C3P0</code>来配置学习下。</p><h4 id="1-1-1-环境准备"><a href="#1-1-1-环境准备" class="headerlink" title="1.1.1 环境准备"></a>1.1.1 环境准备</h4><p>学习之前，先来准备下案例环境:</p><ul><li><p>创建一个Maven项目</p><p><img src="/2022/11/26/spring02/1629860338328.png" alt="1629860338328"></p></li><li><p>pom.xml添加依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>resources下添加spring的配置文件applicationContext.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写一个运行类App</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-1-2-思路分析"><a href="#1-1-2-思路分析" class="headerlink" title="1.1.2 思路分析"></a>1.1.2 思路分析</h4><p>在上述环境下，我们来对数据源进行配置管理，先来分析下思路:</p><blockquote><p>需求:使用Spring的IOC容器来管理Druid连接池对象</p><p>1.使用第三方的技术，需要在pom.xml添加依赖</p><p>2.在配置文件中将【第三方的类】制作成一个bean，让IOC容器进行管理</p><p>3.数据库连接需要基础的四要素<code>驱动</code>、<code>连接</code>、<code>用户名</code>和<code>密码</code>，【如何注入】到对应的bean中</p><p>4.从IOC容器中获取对应的bean对象，将其打印到控制台查看结果</p></blockquote><p><strong>思考:</strong></p><ul><li>第三方的类指的是什么?</li><li>如何注入数据库连接四要素?</li></ul><h4 id="1-1-3-实现Druid管理"><a href="#1-1-3-实现Druid管理" class="headerlink" title="1.1.3 实现Druid管理"></a>1.1.3 实现Druid管理</h4><p>带着这两个问题，把下面的案例实现下:</p><h5 id="步骤1-导入druid的依赖"><a href="#步骤1-导入druid的依赖" class="headerlink" title="步骤1:导入druid的依赖"></a>步骤1:导入<code>druid</code>的依赖</h5><p>pom.xml中添加依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="步骤2-配置第三方bean"><a href="#步骤2-配置第三方bean" class="headerlink" title="步骤2:配置第三方bean"></a>步骤2:配置第三方bean</h5><p>在applicationContext.xml配置文件中添加<code>DruidDataSource</code>的配置</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--管理DruidDataSource对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/spring_db&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>driverClassName:数据库驱动</li><li>url:数据库连接地址</li><li>username:数据库连接用户名</li><li>password:数据库连接密码</li><li>数据库连接的四要素要和自己使用的数据库信息一致。</li></ul><h5 id="步骤3-从IOC容器中获取对应的bean对象"><a href="#步骤3-从IOC容器中获取对应的bean对象" class="headerlink" title="步骤3:从IOC容器中获取对应的bean对象"></a>步骤3:从IOC容器中获取对应的bean对象</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">       <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> (DataSource) ctx.getBean(<span class="string">&quot;dataSource&quot;</span>);</span><br><span class="line">       System.out.println(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="步骤4-运行程序"><a href="#步骤4-运行程序" class="headerlink" title="步骤4:运行程序"></a>步骤4:运行程序</h5><p>打印如下结果: 说明第三方bean对象已经被spring的IOC容器进行管理</p><p><img src="/2022/11/26/spring02/1629887733081.png" alt="1629887733081"></p><p>做完案例后，我们可以将刚才思考的两个问题答案说下:</p><ul><li><p>第三方的类指的是什么?</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DruidDataSource</span><br></pre></td></tr></table></figure></li><li><p>如何注入数据库连接四要素?</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setter注入</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-1-4-实现C3P0管理"><a href="#1-1-4-实现C3P0管理" class="headerlink" title="1.1.4 实现C3P0管理"></a>1.1.4 实现C3P0管理</h4><p>完成了DruidDataSource的管理，接下来我们再来加深下练习，这次我们来管理<code>C3P0</code>数据源，具体的实现步骤是什么呢?</p><blockquote><p>需求:使用Spring的IOC容器来管理C3P0连接池对象</p><p>实现方案和上面基本一致，重点要关注管理的是哪个bean对象&#96;?</p></blockquote><h5 id="步骤1-导入C3P0的依赖"><a href="#步骤1-导入C3P0的依赖" class="headerlink" title="步骤1:导入C3P0的依赖"></a>步骤1:导入<code>C3P0</code>的依赖</h5><p>pom.xml中添加依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>对于新的技术，不知道具体的坐标该如何查找?</strong></p><ul><li><p>直接百度搜索</p></li><li><p>从mvn的仓库<code>https://mvnrepository.com/</code>中进行搜索</p><p><img src="/2022/11/26/spring02/1629888540286.png" alt="1629888540286"></p></li></ul><h5 id="步骤2-配置第三方bean-1"><a href="#步骤2-配置第三方bean-1" class="headerlink" title="步骤2:配置第三方bean"></a>步骤2:配置第三方bean</h5><p>在applicationContext.xml配置文件中添加配置</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/spring_db&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1000&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>&#x3D;&#x3D;注意:&#x3D;&#x3D;</strong></p><ul><li>ComboPooledDataSource的属性是通过setter方式进行注入</li><li>想注入属性就需要在ComboPooledDataSource类或其上层类中有提供属性对应的setter方法</li><li>C3P0的四个属性和Druid的四个属性是不一样的</li></ul><h5 id="步骤3-运行程序"><a href="#步骤3-运行程序" class="headerlink" title="步骤3:运行程序"></a>步骤3:运行程序</h5><p>程序会报错，错误如下</p><p><img src="/2022/11/26/spring02/1629889170229.png" alt="1629889170229"></p><p>报的错为&#x3D;&#x3D;ClassNotFoundException&#x3D;&#x3D;,翻译出来是<code>类没有发现的异常</code>，具体的类为<code>com.mysql.jdbc.Driver</code>。错误的原因是缺少mysql的驱动包。</p><p>分析出错误的原因，具体的解决方案就比较简单，只需要在pom.xml把驱动包引入即可。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加完mysql的驱动包以后，再次运行App,就可以打印出结果:</p><p><img src="/2022/11/26/spring02/1629903845404.png" alt="1629903845404"></p><p><strong>注意：</strong></p><ul><li>数据连接池在配置属性的时候，除了可以注入数据库连接四要素外还可以配置很多其他的属性，具体都有哪些属性用到的时候再去查，一般配置基础的四个，其他都有自己的默认值</li><li>Druid和C3P0在没有导入mysql驱动包的前提下，一个没报错一个报错，说明Druid在初始化的时候没有去加载驱动，而C3P0刚好相反</li><li>Druid程序运行虽然没有报错，但是当调用DruidDataSource的getConnection()方法获取连接的时候，也会报找不到驱动类的错误</li></ul><h3 id="1-2-加载properties文件"><a href="#1-2-加载properties文件" class="headerlink" title="1.2 加载properties文件"></a>1.2 加载properties文件</h3><p>上节中我们已经完成两个数据源<code>druid</code>和<code>C3P0</code>的配置，但是其中包含了一些问题，我们来分析下:</p><ul><li>这两个数据源中都使用到了一些固定的常量如数据库连接四要素，把这些值写在Spring的配置文件中不利于后期维护</li><li>需要将这些值提取到一个外部的properties配置文件中</li><li>Spring框架如何从配置文件中读取属性值来配置就是接下来要解决的问题。</li></ul><p>问题提出来后，具体该如何实现?</p><h4 id="1-2-1-第三方bean属性优化"><a href="#1-2-1-第三方bean属性优化" class="headerlink" title="1.2.1 第三方bean属性优化"></a>1.2.1 第三方bean属性优化</h4><h5 id="1-2-1-1-实现思路"><a href="#1-2-1-1-实现思路" class="headerlink" title="1.2.1.1 实现思路"></a>1.2.1.1 实现思路</h5><blockquote><p>需求:将数据库连接四要素提取到properties配置文件，spring来加载配置信息并使用这些信息来完成属性注入。</p><p>1.在resources下创建一个jdbc.properties(文件的名称可以任意)</p><p>2.将数据库连接四要素配置到配置文件中</p><p>3.在Spring的配置文件中加载properties文件</p><p>4.使用加载到的值实现属性注入</p><p>其中第3，4步骤是需要大家重点关注，具体是如何实现。</p></blockquote><h5 id="1-2-1-2-实现步骤"><a href="#1-2-1-2-实现步骤" class="headerlink" title="1.2.1.2 实现步骤"></a>1.2.1.2 实现步骤</h5><h6 id="步骤1-准备properties配置文件"><a href="#步骤1-准备properties配置文件" class="headerlink" title="步骤1:准备properties配置文件"></a>步骤1:准备properties配置文件</h6><p>resources下创建一个jdbc.properties文件,并添加对应的属性键值对</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/spring_db</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure><h6 id="步骤2-开启context命名空间"><a href="#步骤2-开启context命名空间" class="headerlink" title="步骤2:开启context命名空间"></a>步骤2:开启<code>context</code>命名空间</h6><p>在applicationContext.xml中开<code>context</code>命名空间</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="步骤3-加载properties配置文件"><a href="#步骤3-加载properties配置文件" class="headerlink" title="步骤3:加载properties配置文件"></a>步骤3:加载properties配置文件</h6><p>在配置文件中使用<code>context</code>命名空间下的标签来加载properties配置文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;jdbc.properties&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h6 id="步骤4-完成属性注入"><a href="#步骤4-完成属性注入" class="headerlink" title="步骤4:完成属性注入"></a>步骤4:完成属性注入</h6><p>使用<code>$&#123;key&#125;</code>来读取properties配置文件中的内容并完成属性注入</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>至此，读取外部properties配置文件中的内容就已经完成。</p><h4 id="1-2-2-读取单个属性"><a href="#1-2-2-读取单个属性" class="headerlink" title="1.2.2 读取单个属性"></a>1.2.2 读取单个属性</h4><h5 id="1-2-2-1-实现思路"><a href="#1-2-2-1-实现思路" class="headerlink" title="1.2.2.1 实现思路"></a>1.2.2.1 实现思路</h5><p>对于上面的案例，效果不是很明显，我们可以换个案例来演示下:</p><blockquote><p>需求:从properties配置文件中读取key为name的值，并将其注入到BookDao中并在save方法中进行打印。</p><p>1.在项目中添加BookDao和BookDaoImpl类</p><p>2.为BookDaoImpl添加一个name属性并提供setter方法</p><p>3.在jdbc.properties中添加数据注入到bookDao中打印方便查询结果</p><p>4.在applicationContext.xml添加配置完成配置文件加载、属性注入(${key})</p></blockquote><h5 id="1-2-2-2-实现步骤"><a href="#1-2-2-2-实现步骤" class="headerlink" title="1.2.2.2 实现步骤"></a>1.2.2.2 实现步骤</h5><h6 id="步骤1-在项目中添对应的类"><a href="#步骤1-在项目中添对应的类" class="headerlink" title="步骤1:在项目中添对应的类"></a>步骤1:在项目中添对应的类</h6><p>BookDao和BookDaoImpl类，并在BookDaoImpl类中添加<code>name</code>属性与setter方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="步骤2-完成配置文件的读取与注入"><a href="#步骤2-完成配置文件的读取与注入" class="headerlink" title="步骤2:完成配置文件的读取与注入"></a>步骤2:完成配置文件的读取与注入</h6><p>在applicationContext.xml添加配置，<code>bean的配置管理</code>、<code>读取外部properties</code>、<code>依赖注入</code>:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="步骤3-运行程序-1"><a href="#步骤3-运行程序-1" class="headerlink" title="步骤3:运行程序"></a>步骤3:运行程序</h6><p>在App类中，从IOC容器中获取bookDao对象，调用方法，查看值是否已经被获取到并打印控制台</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookDao) ctx.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/11/26/spring02/1629975492444.png" alt="1629975492444"></p><h5 id="1-2-2-3-注意事项"><a href="#1-2-2-3-注意事项" class="headerlink" title="1.2.2.3 注意事项"></a>1.2.2.3 注意事项</h5><p>至此，读取properties配置文件中的内容就已经完成，但是在使用的时候，有些注意事项:</p><ul><li><p>问题一:键值对的key为<code>username</code>引发的问题</p><p>1.在properties中配置键值对的时候，如果key设置为<code>username</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username=root666</span><br></pre></td></tr></table></figure><p>2.在applicationContext.xml注入该属性</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3.运行后，在控制台打印的却不是<code>root666</code>，而是自己电脑的用户名</p><p><img src="/2022/11/26/spring02/1629975934694.png" alt="1629975934694"></p><p>4.出现问题的原因是<code>&lt;context:property-placeholder/&gt;</code>标签会加载系统的环境变量，而且环境变量的值会被优先加载，如何查看系统的环境变量?</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    Map&lt;String, String&gt; env = System.getenv();</span><br><span class="line">    System.out.println(env);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家可以自行运行，在打印出来的结果中会有一个USERNAME&#x3D;XXX[自己电脑的用户名称]</p><p>5.解决方案</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;jdbc.properties&quot;</span> <span class="attr">system-properties-mode</span>=<span class="string">&quot;NEVER&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>system-properties-mode:设置为NEVER,表示不加载系统属性，就可以解决上述问题。</p><p>当然还有一个解决方案就是避免使用<code>username</code>作为属性的<code>key</code>。</p></li><li><p>问题二:当有多个properties配置文件需要被加载，该如何配置?</p><p>1.调整下配置文件的内容，在resources下添加<code>jdbc.properties</code>,<code>jdbc2.properties</code>,内容如下:</p><p>jdbc.properties</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/spring_db</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure><p>jdbc2.properties</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">username</span>=<span class="string">root666</span></span><br></pre></td></tr></table></figure><p>2.修改applicationContext.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--方式一 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;jdbc.properties,jdbc2.properties&quot;</span> <span class="attr">system-properties-mode</span>=<span class="string">&quot;NEVER&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--方式二--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;*.properties&quot;</span> <span class="attr">system-properties-mode</span>=<span class="string">&quot;NEVER&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--方式三 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:*.properties&quot;</span> <span class="attr">system-properties-mode</span>=<span class="string">&quot;NEVER&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--方式四--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath*:*.properties&quot;</span> <span class="attr">system-properties-mode</span>=<span class="string">&quot;NEVER&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>方式一:可以实现，如果配置文件多的话，每个都需要配置</li><li>方式二:<code>*.properties</code>代表所有以properties结尾的文件都会被加载，可以解决方式一的问题，但是不标准</li><li>方式三:标准的写法，<code>classpath:</code>代表的是从根路径下开始查找，但是只能查询当前项目的根路径</li><li>方式四:不仅可以加载当前项目还可以加载当前项目所依赖的所有项目的根路径下的properties配置文件</li></ul></li></ul><h4 id="1-2-3-加载properties文件小结"><a href="#1-2-3-加载properties文件小结" class="headerlink" title="1.2.3 加载properties文件小结"></a>1.2.3 加载properties文件小结</h4><p>  本节主要讲解的是properties配置文件的加载，需要掌握的内容有:</p><ul><li><p>如何开启<code>context</code>命名空间</p><p><img src="/2022/11/26/spring02/1629980280952.png" alt="1629980280952"></p></li><li><p>如何加载properties配置文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;&quot;</span> <span class="attr">system-properties-mode</span>=<span class="string">&quot;NEVER&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>如何在applicationContext.xml引入properties配置文件中的值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;key&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2，核心容器"><a href="#2，核心容器" class="headerlink" title="2，核心容器"></a>2，核心容器</h2><p>前面已经完成bean与依赖注入的相关知识学习，接下来我们主要学习的是IOC容器中的&#x3D;&#x3D;核心容器&#x3D;&#x3D;。</p><p>这里所说的核心容器，大家可以把它简单的理解为<code>ApplicationContext</code>，前面虽然已经用到过，但是并没有系统的学习，接下来咱们从以下几个问题入手来学习下容器的相关知识:</p><ul><li>如何创建容器?</li><li>创建好容器后，如何从容器中获取bean对象?</li><li>容器类的层次结构是什么?</li><li>BeanFactory是什么?</li></ul><h3 id="2-1-环境准备"><a href="#2-1-环境准备" class="headerlink" title="2.1 环境准备"></a>2.1 环境准备</h3><p>在学习和解决上述问题之前，先来准备下案例环境:</p><ul><li><p>创建一个Maven项目</p></li><li><p>pom.xml添加Spring的依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>resources下添加applicationContext.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>添加BookDao和BookDaoImpl类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建运行类App</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookDao) ctx.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>最终创建好的项目结构如下:</p><p><img src="/2022/11/26/spring02/1629982672522.png" alt="1629982672522"></p><h3 id="2-2-容器"><a href="#2-2-容器" class="headerlink" title="2.2 容器"></a>2.2 容器</h3><h4 id="2-2-1-容器的创建方式"><a href="#2-2-1-容器的创建方式" class="headerlink" title="2.2.1 容器的创建方式"></a>2.2.1 容器的创建方式</h4><p>案例中创建<code>ApplicationContext</code>的方式为:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure><p>这种方式翻译为:&#x3D;&#x3D;类路径下的XML配置文件&#x3D;&#x3D;</p><p>除了上面这种方式，Spring还提供了另外一种创建方式为:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure><p>这种方式翻译为:&#x3D;&#x3D;文件系统下的XML配置文件&#x3D;&#x3D;</p><p>使用这种方式，运行，会出现如下错误:</p><p><img src="/2022/11/26/spring02/1629983245121.png" alt="1629983245121"></p><p>从错误信息中能发现，这种方式是从项目路径下开始查找<code>applicationContext.xml</code>配置文件的，所以需要将其修改为:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemXmlApplicationContext</span>(<span class="string">&quot;D:\\workspace\\spring\\spring_10_container\\src\\main\\resources\\applicationContext.xml&quot;</span>); </span><br></pre></td></tr></table></figure><p>**说明:**大家练习的时候，写自己的具体路径。</p><p>这种方式虽能实现，但是当项目的位置发生变化后,代码也需要跟着改,耦合度较高,不推荐使用。</p><h4 id="2-2-2-Bean的三种获取方式"><a href="#2-2-2-Bean的三种获取方式" class="headerlink" title="2.2.2 Bean的三种获取方式"></a>2.2.2 Bean的三种获取方式</h4><p>方式一，就是目前案例中获取的方式:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookDao) ctx.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br></pre></td></tr></table></figure><p>这种方式存在的问题是每次获取的时候都需要进行类型转换，有没有更简单的方式呢?</p><p>方式二：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BookDao bookDao = ctx.getBean(&quot;bookDao&quot;，BookDao.class);</span><br></pre></td></tr></table></figure><p>这种方式可以解决类型强转问题，但是参数又多加了一个，相对来说没有简化多少。</p><p>方式三:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BookDao bookDao = ctx.getBean(BookDao.class);</span><br></pre></td></tr></table></figure><p>这种方式就类似我们之前所学习依赖注入中的按类型注入。必须要确保IOC容器中该类型对应的bean对象只能有一个。</p><h4 id="2-2-3-容器类层次结构"><a href="#2-2-3-容器类层次结构" class="headerlink" title="2.2.3 容器类层次结构"></a>2.2.3 容器类层次结构</h4><p>(1)在IDEA中双击<code>shift</code>,输入BeanFactory</p><p><img src="/2022/11/26/spring02/1629985148294.png" alt="1629985148294"></p><p>(2)点击进入BeanFactory类，ctrl+h,就能查看到如下结构的层次关系</p><p><img src="/2022/11/26/spring02/1629984980781.png" alt="1629984980781"></p><p>从图中可以看出，容器类也是从无到有根据需要一层层叠加上来的，大家重点理解下这种设计思想。</p><h4 id="2-2-4-BeanFactory的使用"><a href="#2-2-4-BeanFactory的使用" class="headerlink" title="2.2.4 BeanFactory的使用"></a>2.2.4 BeanFactory的使用</h4><p>使用BeanFactory来创建IOC容器的具体实现方式为:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForBeanFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Resource</span> <span class="variable">resources</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">BeanFactory</span> <span class="variable">bf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanFactory</span>(resources);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> bf.getBean(BookDao.class);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了更好的看出<code>BeanFactory</code>和<code>ApplicationContext</code>之间的区别，在BookDaoImpl添加如下构造函数:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BookDaoImpl</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不去获取bean对象，打印会发现：</p><ul><li><p>BeanFactory是延迟加载，只有在获取bean对象的时候才会去创建</p></li><li><p>ApplicationContext是立即加载，容器加载的时候就会创建bean对象</p></li><li><p>ApplicationContext要想成为延迟加载，只需要按照如下方式进行配置</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>  <span class="attr">lazy-init</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>小结</strong></p><p>这一节中所讲的知识点包括:</p><ul><li><p>容器创建的两种方式</p><ul><li>ClassPathXmlApplicationContext[掌握]</li><li>FileSystemXmlApplicationContext[知道即可]</li></ul></li><li><p>获取Bean的三种方式</p><ul><li>getBean(“名称”):需要类型转换</li><li>getBean(“名称”,类型.class):多了一个参数</li><li>getBean(类型.class):容器中不能有多个该类的bean对象</li></ul><p>上述三种方式，各有各的优缺点，用哪个都可以。</p></li><li><p>容器类层次结构</p><ul><li>只需要知晓容器的最上级的父接口为 BeanFactory即可</li></ul></li><li><p>BeanFactory</p><ul><li>使用BeanFactory创建的容器是延迟加载</li><li>使用ApplicationContext创建的容器是立即加载</li><li>具体BeanFactory如何创建只需要了解即可。</li></ul></li></ul><h3 id="2-2-核心容器总结"><a href="#2-2-核心容器总结" class="headerlink" title="2.2 核心容器总结"></a>2.2 核心容器总结</h3><p>这节中没有新的知识点，只是对前面知识的一个大总结，共包含如下内容:</p><h4 id="2-2-1-容器相关"><a href="#2-2-1-容器相关" class="headerlink" title="2.2.1 容器相关"></a>2.2.1 容器相关</h4><ul><li>BeanFactory是IoC容器的顶层接口，初始化BeanFactory对象时，加载的bean延迟加载</li><li>ApplicationContext接口是Spring容器的核心接口，初始化时bean立即加载</li><li>ApplicationContext接口提供基础的bean操作相关方法，通过其他接口扩展其功能</li><li>ApplicationContext接口常用初始化类<ul><li><strong>&#x3D;&#x3D;ClassPathXmlApplicationContext(常用)&#x3D;&#x3D;</strong></li><li>FileSystemXmlApplicationContext</li></ul></li></ul><h4 id="2-2-2-bean相关"><a href="#2-2-2-bean相关" class="headerlink" title="2.2.2 bean相关"></a>2.2.2 bean相关</h4><p><img src="/2022/11/26/spring02/1629986510487.png" alt="1629986510487"></p><p>其实整个配置中最常用的就两个属性&#x3D;&#x3D;id&#x3D;&#x3D;和&#x3D;&#x3D;class&#x3D;&#x3D;。</p><p>把scope、init-method、destroy-method框起来的原因是，后面注解在讲解的时候还会用到，所以大家对这三个属性关注下。</p><h4 id="2-2-3-依赖注入相关"><a href="#2-2-3-依赖注入相关" class="headerlink" title="2.2.3 依赖注入相关"></a>2.2.3 依赖注入相关</h4><p><img src="/2022/11/26/spring02/1629986848563.png" alt="1629986848563"></p><h2 id="3，IOC-x2F-DI注解开发"><a href="#3，IOC-x2F-DI注解开发" class="headerlink" title="3，IOC&#x2F;DI注解开发"></a>3，IOC&#x2F;DI注解开发</h2><p>Spring的IOC&#x2F;DI对应的配置开发就已经讲解完成，但是使用起来相对来说还是比较复杂的，复杂的地方在&#x3D;&#x3D;配置文件&#x3D;&#x3D;。</p><p>前面咱们聊Spring的时候说过，Spring可以简化代码的开发，到现在并没有体会到。</p><p>所以Spring到底是如何简化代码开发的呢?</p><p>要想真正简化开发，就需要用到Spring的注解开发，Spring对注解支持的版本历程:</p><ul><li>2.0版开始支持注解</li><li>2.5版注解功能趋于完善</li><li>3.0版支持纯注解开发</li></ul><p>关于注解开发，我们会讲解两块内容<code>注解开发定义bean</code>和<code>纯注解开发</code>。</p><p>注解开发定义bean用的是2.5版提供的注解，纯注解开发用的是3.0版提供的注解。</p><h3 id="3-1-环境准备"><a href="#3-1-环境准备" class="headerlink" title="3.1 环境准备"></a>3.1 环境准备</h3><p>在学习注解开发之前，先来准备下案例环境:</p><ul><li><p>创建一个Maven项目</p></li><li><p>pom.xml添加Spring的依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>resources下添加applicationContext.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>添加BookDao、BookDaoImpl、BookService、BookServiceImpl类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>创建运行类App</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookDao) ctx.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>最终创建好的项目结构如下:</p><p><img src="/2022/11/26/spring02/1629989221808.png" alt="1629989221808"></p><h3 id="3-2-注解开发定义bean"><a href="#3-2-注解开发定义bean" class="headerlink" title="3.2 注解开发定义bean"></a>3.2 注解开发定义bean</h3><p>在上述环境的基础上，我们来学一学Spring是如何通过注解实现bean的定义开发?</p><h4 id="步骤1-删除原XML配置"><a href="#步骤1-删除原XML配置" class="headerlink" title="步骤1:删除原XML配置"></a>步骤1:删除原XML配置</h4><p>将配置文件中的<code>&lt;bean&gt;</code>标签删除掉</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="步骤2-Dao上添加注解"><a href="#步骤2-Dao上添加注解" class="headerlink" title="步骤2:Dao上添加注解"></a>步骤2:Dao上添加注解</h4><p>在BookDaoImpl类上添加<code>@Component</code>注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;bookDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;注意:@Component注解不可以添加在接口上，因为接口是无法创建对象的。&#x3D;&#x3D;</p><p>XML与注解配置的对应关系:</p><p><img src="/2022/11/26/spring02/1629990315619.png" alt="1629990315619"></p><h4 id="步骤3-配置Spring的注解包扫描"><a href="#步骤3-配置Spring的注解包扫描" class="headerlink" title="步骤3:配置Spring的注解包扫描"></a>步骤3:配置Spring的注解包扫描</h4><p>为了让Spring框架能够扫描到写在类上的注解，需要在配置文件上进行包扫描</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.itheima&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><p>component-scan</p><ul><li>component:组件,Spring将管理的bean视作自己的一个组件</li><li>scan:扫描</li></ul><p>base-package指定Spring框架扫描的包路径，它会扫描指定包及其子包中的所有类上的注解。</p><ul><li>包路径越多[如:com.itheima.dao.impl]，扫描的范围越小速度越快</li><li>包路径越少[如:com.itheima],扫描的范围越大速度越慢</li><li>一般扫描到项目的组织名称即Maven的groupId下[如:com.itheima]即可。</li></ul><h4 id="步骤4：运行程序"><a href="#步骤4：运行程序" class="headerlink" title="步骤4：运行程序"></a>步骤4：运行程序</h4><p>运行<code>App</code>类查看打印结果</p><p><img src="/2022/11/26/spring02/1630027590558.png" alt="1630027590558"></p><h4 id="步骤5-Service上添加注解"><a href="#步骤5-Service上添加注解" class="headerlink" title="步骤5:Service上添加注解"></a>步骤5:Service上添加注解</h4><p>在BookServiceImpl类上也添加<code>@Component</code>交给Spring框架管理</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="步骤6-运行程序"><a href="#步骤6-运行程序" class="headerlink" title="步骤6:运行程序"></a>步骤6:运行程序</h4><p>在App类中，从IOC容器中获取BookServiceImpl对应的bean对象，打印</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookDao) ctx.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line">        System.out.println(bookDao);</span><br><span class="line">        <span class="comment">//按类型获取bean</span></span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> ctx.getBean(BookService.class);</span><br><span class="line">        System.out.println(bookService);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印观察结果，两个bean对象都已经打印到控制台</p><p><img src="/2022/11/26/spring02/1630027743910.png" alt="1630027743910"></p><p><strong>说明:</strong></p><ul><li><p>BookServiceImpl类没有起名称，所以在App中是按照类型来获取bean对象</p></li><li><p>@Component注解如果不起名称，会有一个默认值就是<code>当前类名首字母小写</code>，所以也可以按照名称获取，如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> (BookService)ctx.getBean(<span class="string">&quot;bookServiceImpl&quot;</span>);</span><br><span class="line">System.out.println(bookService);</span><br></pre></td></tr></table></figure></li></ul><p>对于@Component注解，还衍生出了其他三个注解<code>@Controller</code>、<code>@Service</code>、<code>@Repository</code></p><p>通过查看源码会发现:</p><p><img src="/2022/11/26/spring02/1630028345074.png" alt="1630028345074"></p><p>这三个注解和@Component注解的作用是一样的，为什么要衍生出这三个呢?</p><p>方便我们后期在编写类的时候能很好的区分出这个类是属于<code>表现层</code>、<code>业务层</code>还是<code>数据层</code>的类。</p><h4 id="知识点1-Component等"><a href="#知识点1-Component等" class="headerlink" title="知识点1:@Component等"></a>知识点1:@Component等</h4><table><thead><tr><th>名称</th><th>@Component&#x2F;@Controller&#x2F;@Service&#x2F;@Repository</th></tr></thead><tbody><tr><td>类型</td><td>类注解</td></tr><tr><td>位置</td><td>类定义上方</td></tr><tr><td>作用</td><td>设置该类为spring管理的bean</td></tr><tr><td>属性</td><td>value（默认）：定义bean的id</td></tr></tbody></table><h3 id="3-2-纯注解开发模式"><a href="#3-2-纯注解开发模式" class="headerlink" title="3.2 纯注解开发模式"></a>3.2 纯注解开发模式</h3><p>上面已经可以使用注解来配置bean,但是依然有用到配置文件，在配置文件中对包进行了扫描，Spring在3.0版已经支持纯注解开发</p><ul><li>Spring3.0开启了纯注解开发模式，使用Java类替代配置文件，开启了Spring快速开发赛道</li></ul><p>具体如何实现?</p><h4 id="3-2-1-思路分析"><a href="#3-2-1-思路分析" class="headerlink" title="3.2.1 思路分析"></a>3.2.1 思路分析</h4><p>实现思路为: </p><ul><li>将配置文件applicationContext.xml删除掉，使用类来替换。</li></ul><h4 id="3-2-2-实现步骤"><a href="#3-2-2-实现步骤" class="headerlink" title="3.2.2 实现步骤"></a>3.2.2 实现步骤</h4><h5 id="步骤1-创建配置类"><a href="#步骤1-创建配置类" class="headerlink" title="步骤1:创建配置类"></a>步骤1:创建配置类</h5><p>创建一个配置类<code>SpringConfig</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="步骤2-标识该类为配置类"><a href="#步骤2-标识该类为配置类" class="headerlink" title="步骤2:标识该类为配置类"></a>步骤2:标识该类为配置类</h5><p>在配置类上添加<code>@Configuration</code>注解，将其标识为一个配置类,替换<code>applicationContext.xml</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="步骤3-用注解替换包扫描配置"><a href="#步骤3-用注解替换包扫描配置" class="headerlink" title="步骤3:用注解替换包扫描配置"></a>步骤3:用注解替换包扫描配置</h5><p>在配置类上添加包扫描注解<code>@ComponentScan</code>替换<code>&lt;context:component-scan base-package=&quot;&quot;/&gt;</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="步骤4-创建运行类并执行"><a href="#步骤4-创建运行类并执行" class="headerlink" title="步骤4:创建运行类并执行"></a>步骤4:创建运行类并执行</h5><p>创建一个新的运行类<code>AppForAnnotation</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForAnnotation</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookDao) ctx.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line">        System.out.println(bookDao);</span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> ctx.getBean(BookService.class);</span><br><span class="line">        System.out.println(bookService);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行AppForAnnotation,可以看到两个对象依然被获取成功</p><p><img src="/2022/11/26/spring02/1630029110506.png" alt="1630029110506"></p><p>至此，纯注解开发的方式就已经完成了，主要内容包括:</p><ul><li><p>Java类替换Spring核心配置文件</p><p><img src="/2022/11/26/spring02/1630029254372.png" alt="1630029254372"></p></li><li><p>@Configuration注解用于设定当前类为配置类</p></li><li><p>@ComponentScan注解用于设定扫描路径，此注解只能添加一次，多个数据请用数组格式</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ComponentScan(&#123;com.itheima.service&quot;,&quot;com.itheima.dao&quot;&#125;)</span><br></pre></td></tr></table></figure></li><li><p>读取Spring核心配置文件初始化容器对象切换为读取Java配置类初始化容器对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加载配置文件初始化容器</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"><span class="comment">//加载配置类初始化容器</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br></pre></td></tr></table></figure></li></ul><h4 id="知识点1：-Configuration"><a href="#知识点1：-Configuration" class="headerlink" title="知识点1：@Configuration"></a>知识点1：@Configuration</h4><table><thead><tr><th>名称</th><th>@Configuration</th></tr></thead><tbody><tr><td>类型</td><td>类注解</td></tr><tr><td>位置</td><td>类定义上方</td></tr><tr><td>作用</td><td>设置该类为spring配置类</td></tr><tr><td>属性</td><td>value（默认）：定义bean的id</td></tr></tbody></table><h4 id="知识点2：-ComponentScan"><a href="#知识点2：-ComponentScan" class="headerlink" title="知识点2：@ComponentScan"></a>知识点2：@ComponentScan</h4><table><thead><tr><th>名称</th><th>@ComponentScan</th></tr></thead><tbody><tr><td>类型</td><td>类注解</td></tr><tr><td>位置</td><td>类定义上方</td></tr><tr><td>作用</td><td>设置spring配置类扫描路径，用于加载使用注解格式定义的bean</td></tr><tr><td>属性</td><td>value（默认）：扫描路径，此路径可以逐层向下扫描</td></tr></tbody></table><p><strong>小结:</strong></p><p>这一节重点掌握的是使用注解完成Spring的bean管理，需要掌握的内容为:</p><ul><li>记住@Component、@Controller、@Service、@Repository这四个注解</li><li>applicationContext.xml中<code>&lt;context:component-san/&gt;</code>的作用是指定扫描包路径，注解为@ComponentScan</li><li>@Configuration标识该类为配置类，使用类替换applicationContext.xml文件</li><li>ClassPathXmlApplicationContext是加载XML配置文件</li><li>AnnotationConfigApplicationContext是加载配置类</li></ul><h3 id="3-3-注解开发bean作用范围与生命周期管理"><a href="#3-3-注解开发bean作用范围与生命周期管理" class="headerlink" title="3.3 注解开发bean作用范围与生命周期管理"></a>3.3 注解开发bean作用范围与生命周期管理</h3><p>使用注解已经完成了bean的管理，接下来按照前面所学习的内容，将通过配置实现的内容都换成对应的注解实现，包含两部分内容:<code>bean作用范围</code>和<code>bean生命周期</code>。</p><h4 id="3-3-1-环境准备"><a href="#3-3-1-环境准备" class="headerlink" title="3.3.1 环境准备"></a>3.3.1 环境准备</h4><p>老规矩，学习之前先来准备环境:</p><ul><li><p>创建一个Maven项目</p></li><li><p>pom.xml添加Spring的依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>添加一个配置类<code>SpringConfig</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>添加BookDao、BookDaoImpl类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建运行类App</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao1</span> <span class="operator">=</span> ctx.getBean(BookDao.class);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao2</span> <span class="operator">=</span> ctx.getBean(BookDao.class);</span><br><span class="line">        System.out.println(bookDao1);</span><br><span class="line">        System.out.println(bookDao2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>最终创建好的项目结构如下:</p><p><img src="/2022/11/26/spring02/1630031112993.png" alt="1630031112993"></p><h4 id="3-3-2-Bean的作用范围"><a href="#3-3-2-Bean的作用范围" class="headerlink" title="3.3.2 Bean的作用范围"></a>3.3.2 Bean的作用范围</h4><p>(1)先运行App类,在控制台打印两个一摸一样的地址，说明默认情况下bean是单例</p><p><img src="/2022/11/26/spring02/1630031192753.png" alt="1630031192753"></p><p>(2)要想将BookDaoImpl变成非单例，只需要在其类上添加<code>@scope</code>注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="comment">//@Scope设置bean的作用范围</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次执行App类，打印结果:</p><p><img src="/2022/11/26/spring02/1630031808947.png" alt="1630031808947"></p><h5 id="知识点1：-Scope"><a href="#知识点1：-Scope" class="headerlink" title="知识点1：@Scope"></a>知识点1：@Scope</h5><table><thead><tr><th>名称</th><th>@Scope</th></tr></thead><tbody><tr><td>类型</td><td>类注解</td></tr><tr><td>位置</td><td>类定义上方</td></tr><tr><td>作用</td><td>设置该类创建对象的作用范围<br>可用于设置创建出的bean是否为单例对象</td></tr><tr><td>属性</td><td>value（默认）：定义bean作用范围，<br>&#x3D;&#x3D;默认值singleton（单例），可选值prototype（非单例）&#x3D;&#x3D;</td></tr></tbody></table><h4 id="3-3-3-Bean的生命周期"><a href="#3-3-3-Bean的生命周期" class="headerlink" title="3.3.3 Bean的生命周期"></a>3.3.3 Bean的生命周期</h4><p>(1)在BookDaoImpl中添加两个方法，<code>init</code>和<code>destroy</code>,方法名可以任意</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destroy ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>(2)如何对方法进行标识，哪个是初始化方法，哪个是销毁方法?</p><p>只需要在对应的方法上添加<code>@PostConstruct</code>和<code>@PreDestroy</code>注解即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PostConstruct</span> <span class="comment">//在构造方法之后执行，替换 init-method</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PreDestroy</span> <span class="comment">//在销毁方法之前执行,替换 destroy-method</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destroy ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>(3)要想看到两个方法执行，需要注意的是<code>destroy</code>只有在容器关闭的时候，才会执行，所以需要修改App的类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao1</span> <span class="operator">=</span> ctx.getBean(BookDao.class);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao2</span> <span class="operator">=</span> ctx.getBean(BookDao.class);</span><br><span class="line">        System.out.println(bookDao1);</span><br><span class="line">        System.out.println(bookDao2);</span><br><span class="line">        ctx.close(); <span class="comment">//关闭容器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(4)运行App,类查看打印结果，证明init和destroy方法都被执行了。</p><p><img src="/2022/11/26/spring02/1630032385498.png" alt="1630032385498"></p><p>&#x3D;&#x3D;<strong>注意:</strong>@PostConstruct和@PreDestroy注解如果找不到，需要导入下面的jar包&#x3D;&#x3D;</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;javax.annotation&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;javax.annotation-api&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;<span class="number">1.3</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>找不到的原因是，从JDK9以后jdk中的javax.annotation包被移除了，这两个注解刚好就在这个包中。</p><h5 id="知识点1：-PostConstruct"><a href="#知识点1：-PostConstruct" class="headerlink" title="知识点1：@PostConstruct"></a>知识点1：@PostConstruct</h5><table><thead><tr><th>名称</th><th>@PostConstruct</th></tr></thead><tbody><tr><td>类型</td><td>方法注解</td></tr><tr><td>位置</td><td>方法上</td></tr><tr><td>作用</td><td>设置该方法为初始化方法</td></tr><tr><td>属性</td><td>无</td></tr></tbody></table><h5 id="知识点2：-PreDestroy"><a href="#知识点2：-PreDestroy" class="headerlink" title="知识点2：@PreDestroy"></a>知识点2：@PreDestroy</h5><table><thead><tr><th>名称</th><th>@PreDestroy</th></tr></thead><tbody><tr><td>类型</td><td>方法注解</td></tr><tr><td>位置</td><td>方法上</td></tr><tr><td>作用</td><td>设置该方法为销毁方法</td></tr><tr><td>属性</td><td>无</td></tr></tbody></table><p><strong>小结</strong></p><p><img src="/2022/11/26/spring02/1630033039358.png" alt="1630033039358"></p><h3 id="3-4-注解开发依赖注入"><a href="#3-4-注解开发依赖注入" class="headerlink" title="3.4 注解开发依赖注入"></a>3.4 注解开发依赖注入</h3><p>Spring为了使用注解简化开发，并没有提供<code>构造函数注入</code>、<code>setter注入</code>对应的注解，只提供了自动装配的注解实现。</p><h4 id="3-4-1-环境准备"><a href="#3-4-1-环境准备" class="headerlink" title="3.4.1 环境准备"></a>3.4.1 环境准备</h4><p>在学习之前，把案例环境介绍下:</p><ul><li><p>创建一个Maven项目</p></li><li><p>pom.xml添加Spring的依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>添加一个配置类<code>SpringConfig</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>添加BookDao、BookDaoImpl、BookService、BookServiceImpl类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建运行类App</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> ctx.getBean(BookService.class);</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>最终创建好的项目结构如下:</p><p><img src="/2022/11/26/spring02/1630033604129.png" alt="1630033604129"></p><p>环境准备好后，运行后会发现有问题</p><p><img src="/2022/11/26/spring02/1630033710052.png" alt="1630033710052"></p><p>出现问题的原因是，在BookServiceImpl类中添加了BookDao的属性，并提供了setter方法，但是目前是没有提供配置注入BookDao的，所以bookDao对象为Null,调用其save方法就会报<code>控指针异常</code>。</p><h4 id="3-4-2-注解实现按照类型注入"><a href="#3-4-2-注解实现按照类型注入" class="headerlink" title="3.4.2 注解实现按照类型注入"></a>3.4.2 注解实现按照类型注入</h4><p>对于这个问题使用注解该如何解决?</p><p>(1) 在BookServiceImpl类的bookDao属性上添加<code>@Autowired</code>注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//  public void setBookDao(BookDao bookDao) &#123;</span></span><br><span class="line"><span class="comment">//        this.bookDao = bookDao;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li>@Autowired可以写在属性上，也可也写在setter方法上，最简单的处理方式是<code>写在属性上并将setter方法删除掉</code></li><li>为什么setter方法可以删除呢?<ul><li>自动装配基于反射设计创建对象并通过暴力反射为私有属性进行设值</li><li>普通反射只能获取public修饰的内容</li><li>暴力反射除了获取public修饰的内容还可以获取private修改的内容</li><li>所以此处无需提供setter方法</li></ul></li></ul><p>(2)@Autowired是按照类型注入，那么对应BookDao接口如果有多个实现类，比如添加BookDaoImpl2</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl2</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候再次运行App，就会报错</p><p><img src="/2022/11/26/spring02/1630034272959.png" alt="1630034272959"></p><p>此时，按照类型注入就无法区分到底注入哪个对象，解决方案:<code>按照名称注入</code></p><ul><li><p>先给两个Dao类分别起个名称</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository(&quot;bookDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Repository(&quot;bookDao2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl2</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...2&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时就可以注入成功，但是得思考个问题: </p><ul><li><p>@Autowired是按照类型注入的，给BookDao的两个实现起了名称，它还是有两个bean对象，为什么不报错?</p></li><li><p>@Autowired默认按照类型自动装配，如果IOC容器中同类的Bean找到多个，就按照变量名和Bean的名称匹配。因为变量名叫<code>bookDao</code>而容器中也有一个<code>booDao</code>，所以可以成功注入。</p></li><li><p>分析下面这种情况是否能完成注入呢?</p><p><img src="/2022/11/26/spring02/1630036236150.png" alt="1630036236150"></p></li><li><p>不行，因为按照类型会找到多个bean对象，此时会按照<code>bookDao</code>名称去找，因为IOC容器只有名称叫<code>bookDao1</code>和<code>bookDao2</code>,所以找不到，会报<code>NoUniqueBeanDefinitionException</code></p></li></ul></li></ul><h4 id="3-4-3-注解实现按照名称注入"><a href="#3-4-3-注解实现按照名称注入" class="headerlink" title="3.4.3 注解实现按照名称注入"></a>3.4.3 注解实现按照名称注入</h4><p>当根据类型在容器中找到多个bean,注入参数的属性名又和容器中bean的名称不一致，这个时候该如何解决，就需要使用到<code>@Qualifier</code>来指定注入哪个名称的bean对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;bookDao1&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Qualifier注解后的值就是需要注入的bean的名称。</p><p>&#x3D;&#x3D;注意:@Qualifier不能独立使用，必须和@Autowired一起使用&#x3D;&#x3D;</p><h4 id="3-4-4-简单数据类型注入"><a href="#3-4-4-简单数据类型注入" class="headerlink" title="3.4.4 简单数据类型注入"></a>3.4.4 简单数据类型注入</h4><p>引用类型看完，简单类型注入就比较容易懂了。简单类型注入的是基本数据类型或者字符串类型，下面在<code>BookDaoImpl</code>类中添加一个<code>name</code>属性，用其进行简单类型注入</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository(&quot;bookDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据类型换了，对应的注解也要跟着换，这次使用<code>@Value</code>注解，将值写入注解的参数中就行了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository(&quot;bookDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;itheima&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意数据格式要匹配，如将”abc”注入给int值，这样程序就会报错。</p><p>介绍完后，会有一种感觉就是这个注解好像没什么用，跟直接赋值是一个效果，还没有直接赋值简单，所以这个注解存在的意义是什么?</p><h4 id="3-4-5-注解读取properties配置文件"><a href="#3-4-5-注解读取properties配置文件" class="headerlink" title="3.4.5 注解读取properties配置文件"></a>3.4.5 注解读取properties配置文件</h4><p><code>@Value</code>一般会被用在从properties配置文件中读取内容进行使用，具体如何实现?</p><h5 id="步骤1：resource下准备properties文件"><a href="#步骤1：resource下准备properties文件" class="headerlink" title="步骤1：resource下准备properties文件"></a>步骤1：resource下准备properties文件</h5><p>jdbc.properties</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">name</span>=<span class="string">itheima888</span></span><br></pre></td></tr></table></figure><h5 id="步骤2-使用注解加载properties配置文件"><a href="#步骤2-使用注解加载properties配置文件" class="headerlink" title="步骤2: 使用注解加载properties配置文件"></a>步骤2: 使用注解加载properties配置文件</h5><p>在配置类上添加<code>@PropertySource</code>注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="步骤3：使用-Value读取配置文件中的内容"><a href="#步骤3：使用-Value读取配置文件中的内容" class="headerlink" title="步骤3：使用@Value读取配置文件中的内容"></a>步骤3：使用@Value读取配置文件中的内容</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository(&quot;bookDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤4:运行程序</p><p>运行App类，查看运行结果，说明配置文件中的内容已经被加载到</p><p><img src="/2022/11/26/spring02/1630084683663.png" alt="1630084683663"></p><p><strong>注意:</strong></p><ul><li><p>如果读取的properties配置文件有多个，可以使用<code>@PropertySource</code>的属性来指定多个</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PropertySource(&#123;&quot;jdbc.properties&quot;,&quot;xxx.properties&quot;&#125;)</span></span><br></pre></td></tr></table></figure></li><li><p><code>@PropertySource</code>注解属性中不支持使用通配符<code>*</code>,运行会报错</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PropertySource(&#123;&quot;*.properties&quot;&#125;)</span></span><br></pre></td></tr></table></figure></li><li><p><code>@PropertySource</code>注解属性中可以把<code>classpath:</code>加上,代表从当前项目的根路径找文件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PropertySource(&#123;&quot;classpath:jdbc.properties&quot;&#125;)</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="知识点1：-Autowired"><a href="#知识点1：-Autowired" class="headerlink" title="知识点1：@Autowired"></a>知识点1：@Autowired</h4><table><thead><tr><th>名称</th><th>@Autowired</th></tr></thead><tbody><tr><td>类型</td><td>属性注解  或  方法注解（了解）  或  方法形参注解（了解）</td></tr><tr><td>位置</td><td>属性定义上方  或  标准set方法上方  或  类set方法上方  或  方法形参前面</td></tr><tr><td>作用</td><td>为引用类型属性设置值</td></tr><tr><td>属性</td><td>required：true&#x2F;false，定义该属性是否允许为null</td></tr></tbody></table><h4 id="知识点2：-Qualifier"><a href="#知识点2：-Qualifier" class="headerlink" title="知识点2：@Qualifier"></a>知识点2：@Qualifier</h4><table><thead><tr><th>名称</th><th>@Qualifier</th></tr></thead><tbody><tr><td>类型</td><td>属性注解  或  方法注解（了解）</td></tr><tr><td>位置</td><td>属性定义上方  或  标准set方法上方  或  类set方法上方</td></tr><tr><td>作用</td><td>为引用类型属性指定注入的beanId</td></tr><tr><td>属性</td><td>value（默认）：设置注入的beanId</td></tr></tbody></table><h4 id="知识点3：-Value"><a href="#知识点3：-Value" class="headerlink" title="知识点3：@Value"></a>知识点3：@Value</h4><table><thead><tr><th>名称</th><th>@Value</th></tr></thead><tbody><tr><td>类型</td><td>属性注解  或  方法注解（了解）</td></tr><tr><td>位置</td><td>属性定义上方  或  标准set方法上方  或  类set方法上方</td></tr><tr><td>作用</td><td>为  基本数据类型  或  字符串类型  属性设置值</td></tr><tr><td>属性</td><td>value（默认）：要注入的属性值</td></tr></tbody></table><h4 id="知识点4：-PropertySource"><a href="#知识点4：-PropertySource" class="headerlink" title="知识点4：@PropertySource"></a>知识点4：@PropertySource</h4><table><thead><tr><th>名称</th><th>@PropertySource</th></tr></thead><tbody><tr><td>类型</td><td>类注解</td></tr><tr><td>位置</td><td>类定义上方</td></tr><tr><td>作用</td><td>加载properties文件中的属性值</td></tr><tr><td>属性</td><td>value（默认）：设置加载的properties文件对应的文件名或文件名组成的数组</td></tr></tbody></table><h2 id="4，IOC-x2F-DI注解开发管理第三方bean"><a href="#4，IOC-x2F-DI注解开发管理第三方bean" class="headerlink" title="4，IOC&#x2F;DI注解开发管理第三方bean"></a>4，IOC&#x2F;DI注解开发管理第三方bean</h2><p>前面定义bean的时候都是在自己开发的类上面写个注解就完成了，但如果是第三方的类，这些类都是在jar包中，我们没有办法在类上面添加注解，这个时候该怎么办?</p><p>遇到上述问题，我们就需要有一种更加灵活的方式来定义bean,这种方式不能在原始代码上面书写注解，一样能定义bean,这就用到了一个全新的注解&#x3D;&#x3D;@Bean&#x3D;&#x3D;。</p><p>这个注解该如何使用呢?</p><p>咱们把之前使用配置方式管理的数据源使用注解再来一遍，通过这个案例来学习下@Bean的使用。</p><h3 id="4-1-环境准备"><a href="#4-1-环境准备" class="headerlink" title="4.1 环境准备"></a>4.1 环境准备</h3><p>学习@Bean注解之前先来准备环境:</p><ul><li><p>创建一个Maven项目</p></li><li><p>pom.xml添加Spring的依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>添加一个配置类<code>SpringConfig</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>添加BookDao、BookDaoImpl类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建运行类App</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>最终创建好的项目结构如下:</p><p><img src="/2022/11/26/spring02/1630122466404.png" alt="1630122466404"></p><h3 id="4-2-注解开发管理第三方bean"><a href="#4-2-注解开发管理第三方bean" class="headerlink" title="4.2 注解开发管理第三方bean"></a>4.2 注解开发管理第三方bean</h3><p>在上述环境中完成对<code>Druid</code>数据源的管理，具体的实现步骤为:</p><h4 id="步骤1-导入对应的jar包"><a href="#步骤1-导入对应的jar包" class="headerlink" title="步骤1:导入对应的jar包"></a>步骤1:导入对应的jar包</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="步骤2-在配置类中添加一个方法"><a href="#步骤2-在配置类中添加一个方法" class="headerlink" title="步骤2:在配置类中添加一个方法"></a>步骤2:在配置类中添加一个方法</h4><p>注意该方法的返回值就是要创建的Bean对象类型</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        ds.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/spring_db&quot;</span>);</span><br><span class="line">        ds.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        ds.setPassword(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="步骤3-在方法上添加-Bean注解"><a href="#步骤3-在方法上添加-Bean注解" class="headerlink" title="步骤3:在方法上添加@Bean注解"></a>步骤3:在方法上添加<code>@Bean</code>注解</h4><p>@Bean注解的作用是将方法的返回值制作为Spring管理的一个bean对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        ds.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/spring_db&quot;</span>);</span><br><span class="line">        ds.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        ds.setPassword(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意:不能使用<code>DataSource ds = new DruidDataSource()</code></strong></p><p>因为DataSource接口中没有对应的setter方法来设置属性。</p><h4 id="步骤4-从IOC容器中获取对象并打印"><a href="#步骤4-从IOC容器中获取对象并打印" class="headerlink" title="步骤4:从IOC容器中获取对象并打印"></a>步骤4:从IOC容器中获取对象并打印</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> ctx.getBean(DataSource.class);</span><br><span class="line">        System.out.println(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此使用@Bean来管理第三方bean的案例就已经完成。</p><p>如果有多个bean要被Spring管理，直接在配置类中多些几个方法，方法上添加@Bean注解即可。</p><h3 id="4-3-引入外部配置类"><a href="#4-3-引入外部配置类" class="headerlink" title="4.3 引入外部配置类"></a>4.3 引入外部配置类</h3><p>如果把所有的第三方bean都配置到Spring的配置类<code>SpringConfig</code>中，虽然可以，但是不利于代码阅读和分类管理，所有我们就想能不能按照类别将这些bean配置到不同的配置类中?</p><p>对于数据源的bean,我们新建一个<code>JdbcConfig</code>配置类，并把数据源配置到该类下。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        ds.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/spring_db&quot;</span>);</span><br><span class="line">        ds.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        ds.setPassword(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在的问题是，这个配置类如何能被Spring配置类加载到，并创建DataSource对象在IOC容器中?</p><p>针对这个问题，有两个解决方案:</p><h4 id="4-3-1-使用包扫描引入"><a href="#4-3-1-使用包扫描引入" class="headerlink" title="4.3.1 使用包扫描引入"></a>4.3.1 使用包扫描引入</h4><h5 id="步骤1-在Spring的配置类上添加包扫描"><a href="#步骤1-在Spring的配置类上添加包扫描" class="headerlink" title="步骤1:在Spring的配置类上添加包扫描"></a>步骤1:在Spring的配置类上添加包扫描</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima.config&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="步骤2-在JdbcConfig上添加配置注解"><a href="#步骤2-在JdbcConfig上添加配置注解" class="headerlink" title="步骤2:在JdbcConfig上添加配置注解"></a>步骤2:在JdbcConfig上添加配置注解</h5><p>JdbcConfig类要放入到<code>com.itheima.config</code>包下，需要被Spring的配置类扫描到即可</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        ds.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/spring_db&quot;</span>);</span><br><span class="line">        ds.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        ds.setPassword(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="步骤3-运行程序-2"><a href="#步骤3-运行程序-2" class="headerlink" title="步骤3:运行程序"></a>步骤3:运行程序</h5><p>依然能获取到bean对象并打印控制台。</p><p>这种方式虽然能够扫描到，但是不能很快的知晓都引入了哪些配置类，所有这种方式不推荐使用。</p><h4 id="4-3-2-使用-Import引入"><a href="#4-3-2-使用-Import引入" class="headerlink" title="4.3.2 使用@Import引入"></a>4.3.2 使用<code>@Import</code>引入</h4><p>方案一实现起来有点小复杂，Spring早就想到了这一点，于是又给我们提供了第二种方案。</p><p>这种方案可以不用加<code>@Configuration</code>注解，但是必须在Spring配置类上使用<code>@Import</code>注解手动引入需要加载的配置类</p><h5 id="步骤1-去除JdbcConfig类上的注解"><a href="#步骤1-去除JdbcConfig类上的注解" class="headerlink" title="步骤1:去除JdbcConfig类上的注解"></a>步骤1:去除JdbcConfig类上的注解</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        ds.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/spring_db&quot;</span>);</span><br><span class="line">        ds.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        ds.setPassword(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="步骤2-在Spring配置类中引入"><a href="#步骤2-在Spring配置类中引入" class="headerlink" title="步骤2:在Spring配置类中引入"></a>步骤2:在Spring配置类中引入</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//@ComponentScan(&quot;com.itheima.config&quot;)</span></span><br><span class="line"><span class="meta">@Import(&#123;JdbcConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li><p>扫描注解可以移除</p></li><li><p>@Import参数需要的是一个数组，可以引入多个配置类。</p></li><li><p>@Import注解在配置类中只能写一次，下面的方式是&#x3D;&#x3D;不允许的&#x3D;&#x3D;</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//@ComponentScan(&quot;com.itheima.config&quot;)</span></span><br><span class="line"><span class="meta">@Import(JdbcConfig.class)</span></span><br><span class="line"><span class="meta">@Import(Xxx.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="步骤3-运行程序-3"><a href="#步骤3-运行程序-3" class="headerlink" title="步骤3:运行程序"></a>步骤3:运行程序</h5><p>依然能获取到bean对象并打印控制台</p><h3 id="知识点1：-Bean"><a href="#知识点1：-Bean" class="headerlink" title="知识点1：@Bean"></a>知识点1：@Bean</h3><table><thead><tr><th>名称</th><th>@Bean</th></tr></thead><tbody><tr><td>类型</td><td>方法注解</td></tr><tr><td>位置</td><td>方法定义上方</td></tr><tr><td>作用</td><td>设置该方法的返回值作为spring管理的bean</td></tr><tr><td>属性</td><td>value（默认）：定义bean的id</td></tr></tbody></table><h3 id="知识点2：-Import"><a href="#知识点2：-Import" class="headerlink" title="知识点2：@Import"></a>知识点2：@Import</h3><table><thead><tr><th>名称</th><th>@Import</th></tr></thead><tbody><tr><td>类型</td><td>类注解</td></tr><tr><td>位置</td><td>类定义上方</td></tr><tr><td>作用</td><td>导入配置类</td></tr><tr><td>属性</td><td>value（默认）：定义导入的配置类类名，<br>当配置类有多个时使用数组格式一次性导入多个配置类</td></tr></tbody></table><h3 id="4-4-注解开发实现为第三方bean注入资源"><a href="#4-4-注解开发实现为第三方bean注入资源" class="headerlink" title="4.4 注解开发实现为第三方bean注入资源"></a>4.4 注解开发实现为第三方bean注入资源</h3><p>在使用@Bean创建bean对象的时候，如果方法在创建的过程中需要其他资源该怎么办?</p><p>这些资源会有两大类，分别是<code>简单数据类型</code> 和<code>引用数据类型</code>。</p><h4 id="4-4-1-简单数据类型"><a href="#4-4-1-简单数据类型" class="headerlink" title="4.4.1 简单数据类型"></a>4.4.1 简单数据类型</h4><h5 id="4-4-1-1-需求分析"><a href="#4-4-1-1-需求分析" class="headerlink" title="4.4.1.1 需求分析"></a>4.4.1.1 需求分析</h5><p>对于下面代码关于数据库的四要素不应该写死在代码中，应该是从properties配置文件中读取。如何来优化下面的代码?</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        ds.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/spring_db&quot;</span>);</span><br><span class="line">        ds.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        ds.setPassword(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-4-1-2-注入简单数据类型步骤"><a href="#4-4-1-2-注入简单数据类型步骤" class="headerlink" title="4.4.1.2 注入简单数据类型步骤"></a>4.4.1.2 注入简单数据类型步骤</h5><h6 id="步骤1-类中提供四个属性"><a href="#步骤1-类中提供四个属性" class="headerlink" title="步骤1:类中提供四个属性"></a>步骤1:类中提供四个属性</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        ds.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/spring_db&quot;</span>);</span><br><span class="line">        ds.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        ds.setPassword(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="步骤2-使用-Value注解引入值"><a href="#步骤2-使用-Value注解引入值" class="headerlink" title="步骤2:使用@Value注解引入值"></a>步骤2:使用<code>@Value</code>注解引入值</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;com.mysql.jdbc.Driver&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;jdbc:mysql://localhost:3306/spring_db&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;root&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="meta">@Value(&quot;password&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(driver);</span><br><span class="line">        ds.setUrl(url);</span><br><span class="line">        ds.setUsername(userName);</span><br><span class="line">        ds.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h6><p>现在的数据库连接四要素还是写在代码中，需要做的是将这些内容提</p><p>取到jdbc.properties配置文件，大家思考下该如何实现?</p><blockquote><p>1.resources目录下添加jdbc.properties</p><p>2.配置文件中提供四个键值对分别是数据库的四要素</p><p>3.使用@PropertySource加载jdbc.properties配置文件</p><p>4.修改@Value注解属性的值，将其修改为<code>$&#123;key&#125;</code>，key就是键值对中的键的值</p></blockquote><p>具体的实现就交由大家自行实现下。</p><h4 id="4-4-2-引用数据类型"><a href="#4-4-2-引用数据类型" class="headerlink" title="4.4.2 引用数据类型"></a>4.4.2 引用数据类型</h4><h5 id="4-4-2-1-需求分析"><a href="#4-4-2-1-需求分析" class="headerlink" title="4.4.2.1 需求分析"></a>4.4.2.1 需求分析</h5><p>假设在构建DataSource对象的时候，需要用到BookDao对象，该如何把BookDao对象注入进方法内让其使用呢?</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        ds.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/spring_db&quot;</span>);</span><br><span class="line">        ds.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        ds.setPassword(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-4-2-2-注入引用数据类型步骤"><a href="#4-4-2-2-注入引用数据类型步骤" class="headerlink" title="4.4.2.2 注入引用数据类型步骤"></a>4.4.2.2 注入引用数据类型步骤</h5><h6 id="步骤1-在SpringConfig中扫描BookDao"><a href="#步骤1-在SpringConfig中扫描BookDao" class="headerlink" title="步骤1:在SpringConfig中扫描BookDao"></a>步骤1:在SpringConfig中扫描BookDao</h6><p>扫描的目的是让Spring能管理到BookDao,也就是说要让IOC容器中有一个bookDao对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima.dao&quot;)</span></span><br><span class="line"><span class="meta">@Import(&#123;JdbcConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="步骤2-在JdbcConfig类的方法上添加参数"><a href="#步骤2-在JdbcConfig类的方法上添加参数" class="headerlink" title="步骤2:在JdbcConfig类的方法上添加参数"></a>步骤2:在JdbcConfig类的方法上添加参数</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">(BookDao bookDao)</span>&#123;</span><br><span class="line">    System.out.println(bookDao);</span><br><span class="line">    <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">    ds.setDriverClassName(driver);</span><br><span class="line">    ds.setUrl(url);</span><br><span class="line">    ds.setUsername(userName);</span><br><span class="line">    ds.setPassword(password);</span><br><span class="line">    <span class="keyword">return</span> ds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;引用类型注入只需要为bean定义方法设置形参即可，容器会根据类型自动装配对象。&#x3D;&#x3D;</p><h6 id="步骤3-运行程序-4"><a href="#步骤3-运行程序-4" class="headerlink" title="步骤3:运行程序"></a>步骤3:运行程序</h6><p><img src="/2022/11/26/spring02/1630125475609.png" alt="1630125475609"></p><h2 id="5，注解开发总结"><a href="#5，注解开发总结" class="headerlink" title="5，注解开发总结"></a>5，注解开发总结</h2><p>前面我们已经完成了XML配置和注解的开发实现，至于两者之间的差异，咱们放在一块去对比回顾下:</p><p><img src="/2022/11/26/spring02/1630134786448.png" alt="1630134786448"></p><h2 id="6，Spring整合"><a href="#6，Spring整合" class="headerlink" title="6，Spring整合"></a>6，Spring整合</h2><p>课程学习到这里，已经对Spring有一个简单的认识了，Spring有一个容器，叫做IoC容器，里面保存bean。在进行企业级开发的时候，其实除了将自己写的类让Spring管理之外，还有一部分重要的工作就是使用第三方的技术。前面已经讲了如何管理第三方bean了，下面结合IoC和DI，整合2个常用技术，进一步加深对Spring的使用理解。</p><h3 id="6-1-Spring整合Mybatis思路分析"><a href="#6-1-Spring整合Mybatis思路分析" class="headerlink" title="6.1 Spring整合Mybatis思路分析"></a>6.1 Spring整合Mybatis思路分析</h3><h4 id="6-1-1-环境准备"><a href="#6-1-1-环境准备" class="headerlink" title="6.1.1 环境准备"></a>6.1.1 环境准备</h4><p>在准备环境的过程中，我们也来回顾下Mybatis开发的相关内容:</p><h5 id="步骤1-准备数据库表"><a href="#步骤1-准备数据库表" class="headerlink" title="步骤1:准备数据库表"></a>步骤1:准备数据库表</h5><p>Mybatis是来操作数据库表，所以先创建一个数据库及表</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database spring_db <span class="type">character</span> <span class="keyword">set</span> utf8;</span><br><span class="line">use spring_db;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tbl_account(</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">35</span>),</span><br><span class="line">    money <span class="keyword">double</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="步骤2-创建项目导入jar包"><a href="#步骤2-创建项目导入jar包" class="headerlink" title="步骤2:创建项目导入jar包"></a>步骤2:创建项目导入jar包</h5><p>项目的pom.xml添加相关依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="步骤3-根据表创建模型类"><a href="#步骤3-根据表创建模型类" class="headerlink" title="步骤3:根据表创建模型类"></a>步骤3:根据表创建模型类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Double money;</span><br><span class="line"><span class="comment">//setter...getter...toString...方法略    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="步骤4-创建Dao接口"><a href="#步骤4-创建Dao接口" class="headerlink" title="步骤4:创建Dao接口"></a>步骤4:创建Dao接口</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert(&quot;insert into tbl_account(name,money)values(#&#123;name&#125;,#&#123;money&#125;)&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Account account)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Delete(&quot;delete from tbl_account where id = #&#123;id&#125; &quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update(&quot;update tbl_account set name = #&#123;name&#125; , money = #&#123;money&#125; where id = #&#123;id&#125; &quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Account account)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from tbl_account&quot;)</span></span><br><span class="line">    List&lt;Account&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from tbl_account where id = #&#123;id&#125; &quot;)</span></span><br><span class="line">    Account <span class="title function_">findById</span><span class="params">(Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="步骤5-创建Service接口和实现类"><a href="#步骤5-创建Service接口和实现类" class="headerlink" title="步骤5:创建Service接口和实现类"></a>步骤5:创建Service接口和实现类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Account account)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Account account)</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;Account&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    Account <span class="title function_">findById</span><span class="params">(Integer id)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Account account)</span> &#123;</span><br><span class="line">        accountDao.save(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Account account)</span>&#123;</span><br><span class="line">        accountDao.update(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        accountDao.delete(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Account <span class="title function_">findById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accountDao.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Account&gt; <span class="title function_">findAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accountDao.findAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="步骤6-添加jdbc-properties文件"><a href="#步骤6-添加jdbc-properties文件" class="headerlink" title="步骤6:添加jdbc.properties文件"></a>步骤6:添加jdbc.properties文件</h5><p>resources目录下添加，用于配置数据库连接四要素</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/spring_db?useSSL=false</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure><p>useSSL:关闭MySQL的SSL连接</p><h5 id="步骤7-添加Mybatis核心配置文件"><a href="#步骤7-添加Mybatis核心配置文件" class="headerlink" title="步骤7:添加Mybatis核心配置文件"></a>步骤7:添加Mybatis核心配置文件</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--读取外部properties配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbc.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--别名扫描的包路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.itheima.domain&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--数据源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--映射文件扫描包路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.itheima.dao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="步骤8-编写应用程序"><a href="#步骤8-编写应用程序" class="headerlink" title="步骤8:编写应用程序"></a>步骤8:编写应用程序</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1. 创建SqlSessionFactoryBuilder对象</span></span><br><span class="line">        <span class="type">SqlSessionFactoryBuilder</span> <span class="variable">sqlSessionFactoryBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>();</span><br><span class="line">        <span class="comment">// 2. 加载SqlMapConfig.xml配置文件</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;SqlMapConfig.xml.bak&quot;</span>);</span><br><span class="line">        <span class="comment">// 3. 创建SqlSessionFactory对象</span></span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(inputStream);</span><br><span class="line">        <span class="comment">// 4. 获取SqlSession</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">        <span class="comment">// 5. 执行SqlSession对象执行查询，获取结果User</span></span><br><span class="line">        <span class="type">AccountDao</span> <span class="variable">accountDao</span> <span class="operator">=</span> sqlSession.getMapper(AccountDao.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">Account</span> <span class="variable">ac</span> <span class="operator">=</span> accountDao.findById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(ac);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 释放资源</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="步骤9-运行程序"><a href="#步骤9-运行程序" class="headerlink" title="步骤9:运行程序"></a>步骤9:运行程序</h5><p><img src="/2022/11/26/spring02/1630136904087.png" alt="1630136904087"></p><h4 id="6-1-2-整合思路分析"><a href="#6-1-2-整合思路分析" class="headerlink" title="6.1.2 整合思路分析"></a>6.1.2 整合思路分析</h4><p>Mybatis的基础环境我们已经准备好了，接下来就得分析下在上述的内容中，哪些对象可以交给Spring来管理?</p><ul><li><p>Mybatis程序核心对象分析</p><p><img src="/2022/11/26/spring02/1630137189480.png" alt="1630137189480"></p><p>从图中可以获取到，真正需要交给Spring管理的是&#x3D;&#x3D;SqlSessionFactory&#x3D;&#x3D;</p></li><li><p>整合Mybatis，就是将Mybatis用到的内容交给Spring管理，分析下配置文件</p><p><img src="/2022/11/26/spring02/1630137388717.png" alt="1630137388717"></p><p><strong>说明:</strong></p><ul><li>第一行读取外部properties配置文件，Spring有提供具体的解决方案<code>@PropertySource</code>,需要交给Spring</li><li>第二行起别名包扫描，为SqlSessionFactory服务的，需要交给Spring</li><li>第三行主要用于做连接池，Spring之前我们已经整合了Druid连接池，这块也需要交给Spring</li><li>前面三行一起都是为了创建SqlSession对象用的，那么用Spring管理SqlSession对象吗?回忆下SqlSession是由SqlSessionFactory创建出来的，所以只需要将SqlSessionFactory交给Spring管理即可。</li><li>第四行是Mapper接口和映射文件[如果使用注解就没有该映射文件]，这个是在获取到SqlSession以后执行具体操作的时候用，所以它和SqlSessionFactory创建的时机都不在同一个时间，可能需要单独管理。</li></ul></li></ul><h3 id="6-2-Spring整合Mybatis"><a href="#6-2-Spring整合Mybatis" class="headerlink" title="6.2 Spring整合Mybatis"></a>6.2 Spring整合Mybatis</h3><p>前面我们已经分析了Spring与Mybatis的整合，大体需要做两件事，</p><p>第一件事是:Spring要管理MyBatis中的SqlSessionFactory</p><p>第二件事是:Spring要管理Mapper接口的扫描</p><p>具体该如何实现，具体的步骤为:</p><h4 id="步骤1-项目中导入整合需要的jar包"><a href="#步骤1-项目中导入整合需要的jar包" class="headerlink" title="步骤1:项目中导入整合需要的jar包"></a>步骤1:项目中导入整合需要的jar包</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--Spring操作数据库需要该jar包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">Spring与Mybatis整合的jar包</span></span><br><span class="line"><span class="comment">这个jar包mybatis在前面，是Mybatis提供的</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="步骤2-创建Spring的主配置类"><a href="#步骤2-创建Spring的主配置类" class="headerlink" title="步骤2:创建Spring的主配置类"></a>步骤2:创建Spring的主配置类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//配置类注解</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//包扫描，主要扫描的是项目中的AccountServiceImpl类</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="步骤3-创建数据源的配置类"><a href="#步骤3-创建数据源的配置类" class="headerlink" title="步骤3:创建数据源的配置类"></a>步骤3:创建数据源的配置类</h4><p>在配置类中完成数据源的创建</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(driver);</span><br><span class="line">        ds.setUrl(url);</span><br><span class="line">        ds.setUsername(userName);</span><br><span class="line">        ds.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="步骤4-主配置类中读properties并引入数据源配置类"><a href="#步骤4-主配置类中读properties并引入数据源配置类" class="headerlink" title="步骤4:主配置类中读properties并引入数据源配置类"></a>步骤4:主配置类中读properties并引入数据源配置类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="meta">@Import(JdbcConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="步骤5-创建Mybatis配置类并配置SqlSessionFactory"><a href="#步骤5-创建Mybatis配置类并配置SqlSessionFactory" class="headerlink" title="步骤5:创建Mybatis配置类并配置SqlSessionFactory"></a>步骤5:创建Mybatis配置类并配置SqlSessionFactory</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisConfig</span> &#123;</span><br><span class="line">    <span class="comment">//定义bean，SqlSessionFactoryBean，用于产生SqlSessionFactory对象</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactoryBean <span class="title function_">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">ssfb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        <span class="comment">//设置模型类的别名扫描</span></span><br><span class="line">        ssfb.setTypeAliasesPackage(<span class="string">&quot;com.itheima.domain&quot;</span>);</span><br><span class="line">        <span class="comment">//设置数据源</span></span><br><span class="line">        ssfb.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> ssfb;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义bean，返回MapperScannerConfigurer对象</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MapperScannerConfigurer <span class="title function_">mapperScannerConfigurer</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MapperScannerConfigurer</span> <span class="variable">msc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MapperScannerConfigurer</span>();</span><br><span class="line">        msc.setBasePackage(<span class="string">&quot;com.itheima.dao&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> msc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li><p>使用SqlSessionFactoryBean封装SqlSessionFactory需要的环境信息</p><p><img src="/2022/11/26/spring02/1630138835057.png" alt="1630138835057"></p><ul><li>SqlSessionFactoryBean是前面我们讲解FactoryBean的一个子类，在该类中将SqlSessionFactory的创建进行了封装，简化对象的创建，我们只需要将其需要的内容设置即可。</li><li>方法中有一个参数为dataSource,当前Spring容器中已经创建了Druid数据源，类型刚好是DataSource类型，此时在初始化SqlSessionFactoryBean这个对象的时候，发现需要使用DataSource对象，而容器中刚好有这么一个对象，就自动加载了DruidDataSource对象。</li></ul></li><li><p>使用MapperScannerConfigurer加载Dao接口，创建代理对象保存到IOC容器中</p><p><img src="/2022/11/26/spring02/1630138916939.png" alt="1630138916939"></p><ul><li>这个MapperScannerConfigurer对象也是MyBatis提供的专用于整合的jar包中的类，用来处理原始配置文件中的mappers相关配置，加载数据层的Mapper接口类</li><li>MapperScannerConfigurer有一个核心属性basePackage，就是用来设置所扫描的包路径</li></ul></li></ul><h4 id="步骤6-主配置类中引入Mybatis配置类"><a href="#步骤6-主配置类中引入Mybatis配置类" class="headerlink" title="步骤6:主配置类中引入Mybatis配置类"></a>步骤6:主配置类中引入Mybatis配置类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="meta">@Import(&#123;JdbcConfig.class,MybatisConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="步骤7-编写运行类"><a href="#步骤7-编写运行类" class="headerlink" title="步骤7:编写运行类"></a>步骤7:编写运行类</h4><p>在运行类中，从IOC容器中获取Service对象，调用方法获取结果</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">AccountService</span> <span class="variable">accountService</span> <span class="operator">=</span> ctx.getBean(AccountService.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">Account</span> <span class="variable">ac</span> <span class="operator">=</span> accountService.findById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(ac);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="步骤8-运行程序"><a href="#步骤8-运行程序" class="headerlink" title="步骤8:运行程序"></a>步骤8:运行程序</h4><p><img src="/2022/11/26/spring02/1630139036627.png" alt="1630139036627"></p><p>支持Spring与Mybatis的整合就已经完成了，其中主要用到的两个类分别是:</p><ul><li>&#x3D;&#x3D;SqlSessionFactoryBean&#x3D;&#x3D;</li><li>&#x3D;&#x3D;MapperScannerConfigurer&#x3D;&#x3D;</li></ul><h3 id="6-3-Spring整合Junit"><a href="#6-3-Spring整合Junit" class="headerlink" title="6.3 Spring整合Junit"></a>6.3 Spring整合Junit</h3><p>整合Junit与整合Druid和MyBatis差异比较大，为什么呢？Junit是一个搞单元测试用的工具，它不是我们程序的主体，也不会参加最终程序的运行，从作用上来说就和之前的东西不一样，它不是做功能的，看做是一个辅助工具就可以了。</p><h4 id="6-3-1-环境准备"><a href="#6-3-1-环境准备" class="headerlink" title="6.3.1 环境准备"></a>6.3.1 环境准备</h4><p>这块环境，大家可以直接使用Spring与Mybatis整合的环境即可。当然也可以重新创建一个，因为内容是一模一样，所以我们直接来看下项目结构即可:</p><p><img src="/2022/11/26/spring02/1630139720273.png" alt="1630139720273"></p><h4 id="6-3-2-整合Junit步骤"><a href="#6-3-2-整合Junit步骤" class="headerlink" title="6.3.2 整合Junit步骤"></a>6.3.2 整合Junit步骤</h4><p>在上述环境的基础上，我们来对Junit进行整合。</p><h5 id="步骤1-引入依赖"><a href="#步骤1-引入依赖" class="headerlink" title="步骤1:引入依赖"></a>步骤1:引入依赖</h5><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="步骤2-编写测试类"><a href="#步骤2-编写测试类" class="headerlink" title="步骤2:编写测试类"></a>步骤2:编写测试类</h5><p>在test\java下创建一个AccountServiceTest,这个名字任意</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置类运行器</span></span><br><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="comment">//设置Spring环境对应的配置类</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = &#123;SpringConfiguration.class&#125;)</span> <span class="comment">//加载配置类</span></span><br><span class="line"><span class="comment">//@ContextConfiguration(locations=&#123;&quot;classpath:applicationContext.xml&quot;&#125;)//加载配置文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceTest</span> &#123;</span><br><span class="line">    <span class="comment">//支持自动装配注入bean</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountService accountService;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFindById</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(accountService.findById(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFindAll</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(accountService.findAll());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li>单元测试，如果测试的是注解配置类，则使用<code>@ContextConfiguration(classes = 配置类.class)</code></li><li>单元测试，如果测试的是配置文件，则使用<code>@ContextConfiguration(locations=&#123;配置文件名,...&#125;)</code></li><li>Junit运行后是基于Spring环境运行的，所以Spring提供了一个专用的类运行器，这个务必要设置，这个类运行器就在Spring的测试专用包中提供的，导入的坐标就是这个东西<code>SpringJUnit4ClassRunner</code></li><li>上面两个配置都是固定格式，当需要测试哪个bean时，使用自动装配加载对应的对象，下面的工作就和以前做Junit单元测试完全一样了</li></ul><h4 id="知识点1：-RunWith"><a href="#知识点1：-RunWith" class="headerlink" title="知识点1：@RunWith"></a>知识点1：@RunWith</h4><table><thead><tr><th>名称</th><th>@RunWith</th></tr></thead><tbody><tr><td>类型</td><td>测试类注解</td></tr><tr><td>位置</td><td>测试类定义上方</td></tr><tr><td>作用</td><td>设置JUnit运行器</td></tr><tr><td>属性</td><td>value（默认）：运行所使用的运行期</td></tr></tbody></table><h4 id="知识点2：-ContextConfiguration"><a href="#知识点2：-ContextConfiguration" class="headerlink" title="知识点2：@ContextConfiguration"></a>知识点2：@ContextConfiguration</h4><table><thead><tr><th>名称</th><th>@ContextConfiguration</th></tr></thead><tbody><tr><td>类型</td><td>测试类注解</td></tr><tr><td>位置</td><td>测试类定义上方</td></tr><tr><td>作用</td><td>设置JUnit加载的Spring核心配置</td></tr><tr><td>属性</td><td>classes：核心配置类，可以使用数组的格式设定加载多个配置类<br>locations:配置文件，可以使用数组的格式设定加载多个配置文件名称</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>spring01</title>
      <link href="/2022/11/25/spring01/"/>
      <url>/2022/11/25/spring01/</url>
      
        <content type="html"><![CDATA[<h1 id="spring-01"><a href="#spring-01" class="headerlink" title="spring 01"></a>spring 01</h1><p><strong>今日目标</strong></p><blockquote><ul><li>掌握Spring相关概念</li><li>完成IOC&#x2F;DI的入门案例编写</li><li>掌握IOC的相关配置与使用</li><li>掌握DI的相关配置与使用</li></ul></blockquote><h2 id="1，课程介绍"><a href="#1，课程介绍" class="headerlink" title="1，课程介绍"></a>1，课程介绍</h2><p>对于一门新技术，我们需要从<code>为什么要学</code>、<code>学什么</code>以及<code>怎么学</code>这三个方向入手来学习。那对于Spring来说:</p><h3 id="1-1-为什么要学"><a href="#1-1-为什么要学" class="headerlink" title="1.1 为什么要学?"></a>1.1 为什么要学?</h3><ul><li><p>从使用和占有率看</p><ul><li><p>Spring在市场的占有率与使用率高</p></li><li><p>Spring在企业的技术选型命中率高</p></li><li><p>所以说,Spring技术是JavaEE开发必备技能，企业开发技术选型命中率&gt;&#x3D;&#x3D;90%&#x3D;&#x3D;</p><p><img src="/2022/11/25/spring01/image-20210729171139088.png" alt="image-20210729171139088"></p><p><strong>说明</strong>:对于未使用Spring的项目一般都是些比较老的项目，大多都处于维护阶段。</p></li></ul></li><li><p>从专业角度看</p><ul><li>随着时代发展，软件规模与功能都呈几何式增长，开发难度也在不断递增，该如何解决?<ul><li>Spring可以&#x3D;&#x3D;简化开发&#x3D;&#x3D;，降低企业级开发的复杂性，使开发变得更简单快捷</li></ul></li><li>随着项目规模与功能的增长,遇到的问题就会增多，为了解决问题会引入更多的框架，这些框架如何协调工作?<ul><li>Spring可以&#x3D;&#x3D;框架整合&#x3D;&#x3D;，高效整合其他技术，提高企业级应用开发与运行效率</li></ul></li></ul><p>综上所述，&#x3D;&#x3D;Spring是一款非常优秀而且功能强大的框架，不仅要学，而且还要学好。&#x3D;&#x3D;</p></li></ul><h3 id="1-2-学什么"><a href="#1-2-学什么" class="headerlink" title="1.2 学什么?"></a>1.2 学什么?</h3><p>从上面的介绍中，我们可以看到Spring框架主要的优势是在<code>简化开发</code>和<code>框架整合</code>上，至于如何实现就是咱们要学习Spring框架的主要内容:</p><ul><li><p>简化开发: Spring框架中提供了两个大的核心技术，分别是:</p><ul><li>&#x3D;&#x3D;IOC&#x3D;&#x3D;</li><li>&#x3D;&#x3D;AOP&#x3D;&#x3D;<ul><li>&#x3D;&#x3D;事务处理&#x3D;&#x3D;</li></ul></li></ul><p> 1.Spring的简化操作都是基于这两块内容,所以这也是Spring学习中最为重要的两个知识点。</p><p> 2.事务处理属于Spring中AOP的具体应用，可以简化项目中的事务管理，也是Spring技术中的一大亮点。</p></li><li><p>框架整合: Spring在框架整合这块已经做到了极致，它可以整合市面上几乎所有主流框架，比如:</p><ul><li>&#x3D;&#x3D;MyBatis&#x3D;&#x3D;</li><li>MyBatis-plus</li><li>Struts</li><li>Struts2</li><li>Hibernate</li><li>……</li></ul><p>这些框架中，我们目前只学习了MyBatis，所以在Spring框架的学习中，主要是学习如何整合MyBatis。</p><p>综上所述，对于Spring的学习，主要学习四块内容:</p><p>&#x3D;&#x3D;(1)IOC,(2)整合Mybatis(IOC的具体应用)，(3)AOP,(4)声明式事务(AOP的具体应用)&#x3D;&#x3D;</p></li></ul><h3 id="1-3-怎么学"><a href="#1-3-怎么学" class="headerlink" title="1.3 怎么学?"></a>1.3 怎么学?</h3><ul><li>学习Spring框架设计思想<ul><li>对于Spring来说，它能迅速占领全球市场，不只是说它的某个功能比较强大，更重要是在它的<code>思想</code>上。</li></ul></li><li>学习基础操作，思考操作与思想间的联系<ul><li>掌握了Spring的设计思想，然后就需要通过一些基础操作来思考操作与思想之间的关联关系</li></ul></li><li>学习案例，熟练应用操作的同时，体会思想<ul><li>会了基础操作后，就需要通过大量案例来熟练掌握框架的具体应用，加深对设计思想的理解。</li></ul></li></ul><p>介绍完<code>为什么要学</code>、<code>学什么</code>和<code>怎么学</code>Spring框架后，大家需要重点掌握的是:</p><ul><li>Spring很优秀，需要认真重点的学习</li><li>Spring的学习主线是IOC、AOP、声明式事务和整合MyBais</li></ul><p>接下来，咱们就开始进入Spring框架的学习。</p><h2 id="2，Spring相关概念"><a href="#2，Spring相关概念" class="headerlink" title="2，Spring相关概念"></a>2，Spring相关概念</h2><h3 id="2-1-初识Spring"><a href="#2-1-初识Spring" class="headerlink" title="2.1 初识Spring"></a>2.1 初识Spring</h3><p>在这一节，主要通过以下两个点来了解下Spring:</p><h4 id="2-1-1-Spring家族"><a href="#2-1-1-Spring家族" class="headerlink" title="2.1.1 Spring家族"></a>2.1.1 Spring家族</h4><ul><li><p>官网：<a href="https://spring.io，从官网我们可以大概了解到：">https://spring.io，从官网我们可以大概了解到：</a></p><ul><li>Spring能做什么:用以开发web、微服务以及分布式系统等,光这三块就已经占了JavaEE开发的九成多。</li><li>Spring并不是单一的一个技术，而是一个大家族，可以从官网的<code>Projects</code>中查看其包含的所有技术。</li></ul></li><li><p>Spring发展到今天已经形成了一种开发的生态圈,Spring提供了若干个项目,每个项目用于完成特定的功能。</p><ul><li><p>Spring已形成了完整的生态圈，也就是说我们可以完全使用Spring技术完成整个项目的构建、设计与开发。</p></li><li><p>Spring有若干个项目，可以根据需要自行选择，把这些个项目组合起来，起了一个名称叫&#x3D;&#x3D;全家桶&#x3D;&#x3D;，如下图所示</p><p><img src="/2022/11/25/spring01/image-20210729171850181.png" alt="image-20210729171850181"></p><p><strong>说明:</strong></p><p>图中的图标都代表什么含义，可以进入<code>https://spring.io/projects</code>网站进行对比查看。</p><p>这些技术并不是所有的都需要学习，额外需要重点关注<code>Spring Framework</code>、<code>SpringBoot</code>和<code>SpringCloud</code>:</p><p><img src="/2022/11/25/spring01/1629714811435.png" alt="1629714811435"></p><ul><li>Spring Framework:Spring框架，是Spring中最早最核心的技术，也是所有其他技术的基础。</li><li>SpringBoot:Spring是来简化开发，而SpringBoot是来帮助Spring在简化的基础上能更快速进行开发。</li><li>SpringCloud:这个是用来做分布式之微服务架构的相关开发。</li></ul><p>除了上面的这三个技术外，还有很多其他的技术，也比较流行，如SpringData,SpringSecurity等，这些都可以被应用在我们的项目中。我们今天所学习的Spring其实指的是&#x3D;&#x3D;Spring Framework&#x3D;&#x3D;。</p></li></ul></li></ul><h4 id="2-1-2-了解Spring发展史"><a href="#2-1-2-了解Spring发展史" class="headerlink" title="2.1.2 了解Spring发展史"></a>2.1.2 了解Spring发展史</h4><p> 接下来我们介绍下Spring Framework这个技术是如何来的呢?</p><p><img src="/2022/11/25/spring01/image-20210729171926576.png" alt="image-20210729171926576"></p><p>Spring发展史</p><ul><li>IBM(IT公司-国际商业机器公司)在1997年提出了EJB思想,早期的JAVAEE开发大都基于该思想。</li><li>Rod Johnson(Java和J2EE开发领域的专家)在2002年出版的<code>Expert One-on-One J2EE Design and Development</code>,书中有阐述在开发中使用EJB该如何做。</li><li>Rod Johnson在2004年出版的<code>Expert One-on-One J2EE Development without EJB</code>,书中提出了比EJB思想更高效的实现方案，并且在同年将方案进行了具体的落地实现，这个实现就是Spring1.0。</li><li>随着时间推移，版本不断更新维护，目前最新的是Spring5<ul><li>Spring1.0是纯配置文件开发</li><li>Spring2.0为了简化开发引入了注解开发，此时是配置文件加注解的开发方式</li><li>Spring3.0已经可以进行纯注解开发，使开发效率大幅提升，我们的课程会以注解开发为主</li><li>Spring4.0根据JDK的版本升级对个别API进行了调整</li><li>Spring5.0已经全面支持JDK8，现在Spring最新的是5系列所以建议大家把JDK安装成1.8版</li></ul></li></ul><p>本节介绍了Spring家族与Spring的发展史，需要大家重点掌握的是:</p><ul><li>今天所学的Spring其实是Spring家族中的Spring Framework</li><li>Spring Framework是Spring家族中其他框架的底层基础，学好Spring可以为其他Spring框架的学习打好基础</li></ul><h3 id="2-2-Spring系统架构"><a href="#2-2-Spring系统架构" class="headerlink" title="2.2 Spring系统架构"></a>2.2 Spring系统架构</h3><p>前面我们说spring指的是Spring Framework,那么它其中都包含哪些内容以及我们该如何学习这个框架?</p><p>针对这些问题，我们将从<code>系统架构图</code>和<code>课程学习路线</code>来进行说明:</p><h4 id="2-2-1-系统架构图"><a href="#2-2-1-系统架构图" class="headerlink" title="2.2.1 系统架构图"></a>2.2.1 系统架构图</h4><ul><li><p>Spring Framework是Spring生态圈中最基础的项目，是其他项目的根基。</p></li><li><p>Spring Framework的发展也经历了很多版本的变更，每个版本都有相应的调整</p><p><img src="/2022/11/25/spring01/image-20210729172153796.png" alt="image-20210729172153796"></p></li><li><p>Spring Framework的5版本目前没有最新的架构图，而最新的是4版本，所以接下来主要研究的是4的架构图</p><p><img src="/2022/11/25/spring01/1629720945720.png" alt="1629720945720"></p><p>(1)核心层</p><ul><li>Core Container:核心容器，这个模块是Spring最核心的模块，其他的都需要依赖该模块</li></ul><p>(2)AOP层</p><ul><li>AOP:面向切面编程，它依赖核心层容器，目的是&#x3D;&#x3D;在不改变原有代码的前提下对其进行功能增强&#x3D;&#x3D;</li><li>Aspects:AOP是思想,Aspects是对AOP思想的具体实现</li></ul><p>(3)数据层</p><ul><li>Data Access:数据访问，Spring全家桶中有对数据访问的具体实现技术</li><li>Data Integration:数据集成，Spring支持整合其他的数据层解决方案，比如Mybatis</li><li>Transactions:事务，Spring中事务管理是Spring AOP的一个具体实现，也是后期学习的重点内容</li></ul><p>(4)Web层</p><ul><li>这一层的内容将在SpringMVC框架具体学习</li></ul><p>(5)Test层</p><ul><li>Spring主要整合了Junit来完成单元测试和集成测试</li></ul></li></ul><h4 id="2-2-2-课程学习路线"><a href="#2-2-2-课程学习路线" class="headerlink" title="2.2.2 课程学习路线"></a>2.2.2 课程学习路线</h4><p>介绍完Spring的体系结构后，从中我们可以得出对于Spring的学习主要包含四部分内容，分别是:</p><ul><li>&#x3D;&#x3D;Spring的IOC&#x2F;DI&#x3D;&#x3D;</li><li>&#x3D;&#x3D;Spring的AOP&#x3D;&#x3D;</li><li>&#x3D;&#x3D;AOP的具体应用,事务管理&#x3D;&#x3D;</li><li>&#x3D;&#x3D;IOC&#x2F;DI的具体应用,整合Mybatis&#x3D;&#x3D;</li></ul><p><img src="/2022/11/25/spring01/1629722300996.png" alt="1629722300996"></p><p>对于这节的内容，大家重点要记住的是Spring需要学习的四部分内容。接下来就从第一部分开始学起。</p><h3 id="2-3-Spring核心概念"><a href="#2-3-Spring核心概念" class="headerlink" title="2.3 Spring核心概念"></a>2.3 Spring核心概念</h3><p>在Spring核心概念这部分内容中主要包含<code>IOC/DI</code>、<code>IOC容器</code>和<code>Bean</code>,那么问题就来了，这些都是什么呢?</p><h4 id="2-3-1-目前项目中的问题"><a href="#2-3-1-目前项目中的问题" class="headerlink" title="2.3.1 目前项目中的问题"></a>2.3.1 目前项目中的问题</h4><p>要想解答这个问题，就需要先分析下目前咱们代码在编写过程中遇到的问题:</p><p><img src="/2022/11/25/spring01/1629723232339.png" alt="1629723232339"></p><p>(1)业务层需要调用数据层的方法，就需要在业务层new数据层的对象</p><p>(2)如果数据层的实现类发生变化，那么业务层的代码也需要跟着改变，发生变更后，都需要进行编译打包和重部署</p><p>(3)所以，现在代码在编写的过程中存在的问题是：&#x3D;&#x3D;耦合度偏高&#x3D;&#x3D;</p><p>针对这个问题，该如何解决呢?</p><p><img src="/2022/11/25/spring01/1629724206002.png" alt="1629724206002"></p><p>我们就想，如果能把框中的内容给去掉，不就可以降低依赖了么，但是又会引入新的问题，去掉以后程序能运行么?</p><p>答案肯定是不行，因为bookDao没有赋值为Null，强行运行就会出空指针异常。</p><p>所以现在的问题就是，业务层不想new对象，运行的时候又需要这个对象，该咋办呢?</p><p>针对这个问题，Spring就提出了一个解决方案:</p><ul><li>使用对象时，在程序中不要主动使用new产生对象，转换为由&#x3D;&#x3D;外部&#x3D;&#x3D;提供对象</li></ul><p>这种实现思就是Spring的一个核心概念</p><h4 id="2-3-2-IOC、IOC容器、Bean、DI"><a href="#2-3-2-IOC、IOC容器、Bean、DI" class="headerlink" title="2.3.2 IOC、IOC容器、Bean、DI"></a>2.3.2 IOC、IOC容器、Bean、DI</h4><ol><li>&#x3D;&#x3D;IOC（Inversion of Control）控制反转&#x3D;&#x3D;</li></ol><p>(1)什么是控制反转呢？</p><ul><li>使用对象时，由主动new产生对象转换为由&#x3D;&#x3D;外部&#x3D;&#x3D;提供对象，此过程中对象创建控制权由程序转移到外部，此思想称为控制反转。<ul><li>业务层要用数据层的类对象，以前是自己<code>new</code>的</li><li>现在自己不new了，交给<code>别人[外部]</code>来创建对象</li><li><code>别人[外部]</code>就反转控制了数据层对象的创建权</li><li>这种思想就是控制反转</li><li>别人[外部]指定是什么呢?继续往下学</li></ul></li></ul><p>(2)Spring和IOC之间的关系是什么呢?</p><ul><li>Spring技术对IOC思想进行了实现</li><li>Spring提供了一个容器，称为&#x3D;&#x3D;IOC容器&#x3D;&#x3D;，用来充当IOC思想中的”外部”</li><li>IOC思想中的<code>别人[外部]</code>指的就是Spring的IOC容器</li></ul><p>(3)IOC容器的作用以及内部存放的是什么?</p><ul><li>IOC容器负责对象的创建、初始化等一系列工作，其中包含了数据层和业务层的类对象</li><li>被创建或被管理的对象在IOC容器中统称为&#x3D;&#x3D;Bean&#x3D;&#x3D;</li><li>IOC容器中放的就是一个个的Bean对象</li></ul><p>(4)当IOC容器中创建好service和dao对象后，程序能正确执行么?</p><ul><li>不行，因为service运行需要依赖dao对象</li><li>IOC容器中虽然有service和dao对象</li><li>但是service对象和dao对象没有任何关系</li><li>需要把dao对象交给service,也就是说要绑定service和dao对象之间的关系</li></ul><p>像这种在容器中建立对象与对象之间的绑定关系就要用到DI:</p><ol start="2"><li>&#x3D;&#x3D;DI（Dependency Injection）依赖注入&#x3D;&#x3D;</li></ol><p><img src="/2022/11/25/spring01/1629735078619.png" alt="1629735078619"></p><p>(1)什么是依赖注入呢?</p><ul><li>在容器中建立bean与bean之间的依赖关系的整个过程，称为依赖注入<ul><li>业务层要用数据层的类对象，以前是自己<code>new</code>的</li><li>现在自己不new了，靠<code>别人[外部其实指的就是IOC容器]</code>来给注入进来</li><li>这种思想就是依赖注入</li></ul></li></ul><p>(2)IOC容器中哪些bean之间要建立依赖关系呢?</p><ul><li>这个需要程序员根据业务需求提前建立好关系，如业务层需要依赖数据层，service就要和dao建立依赖关系</li></ul><p>介绍完Spring的IOC和DI的概念后，我们会发现这两个概念的最终目标就是:&#x3D;&#x3D;充分解耦&#x3D;&#x3D;，具体实现靠:</p><ul><li>使用IOC容器管理bean（IOC)</li><li>在IOC容器内将有依赖关系的bean进行关系绑定（DI）</li><li>最终结果为:使用对象时不仅可以直接从IOC容器中获取，并且获取到的bean已经绑定了所有的依赖关系.</li></ul><h4 id="2-3-3-核心概念小结"><a href="#2-3-3-核心概念小结" class="headerlink" title="2.3.3 核心概念小结"></a>2.3.3 核心概念小结</h4><p>这节比较重要，重点要理解<code>什么是IOC/DI思想</code>、<code>什么是IOC容器</code>和<code>什么是Bean</code>：</p><p>(1)什么IOC&#x2F;DI思想?</p><ul><li>IOC:控制反转，控制反转的是对象的创建权</li><li>DI:依赖注入，绑定对象与对象之间的依赖关系</li></ul><p>(2)什么是IOC容器?</p><p>Spring创建了一个容器用来存放所创建的对象，这个容器就叫IOC容器</p><p>(3)什么是Bean?</p><p>容器中所存放的一个个对象就叫Bean或Bean对象</p><h2 id="3，入门案例"><a href="#3，入门案例" class="headerlink" title="3，入门案例"></a>3，入门案例</h2><p>介绍完Spring的核心概念后，接下来我们得思考一个问题就是，Spring到底是如何来实现IOC和DI的，那接下来就通过一些简单的入门案例，来演示下具体实现过程:</p><h3 id="3-1-IOC入门案例"><a href="#3-1-IOC入门案例" class="headerlink" title="3.1 IOC入门案例"></a>3.1 IOC入门案例</h3><p>对于入门案例，我们得先<code>分析思路</code>然后再<code>代码实现</code>，</p><h4 id="3-1-1-入门案例思路分析"><a href="#3-1-1-入门案例思路分析" class="headerlink" title="3.1.1 入门案例思路分析"></a>3.1.1 入门案例思路分析</h4><p>(1)Spring是使用容器来管理bean对象的，那么管什么? </p><ul><li>主要管理项目中所使用到的类对象，比如(Service和Dao)</li></ul><p>(2)如何将被管理的对象告知IOC容器?</p><ul><li>使用配置文件</li></ul><p>(3)被管理的对象交给IOC容器，要想从容器中获取对象，就先得思考如何获取到IOC容器?</p><ul><li>Spring框架提供相应的接口</li></ul><p>(4)IOC容器得到后，如何从容器中获取bean?</p><ul><li>调用Spring框架提供对应接口中的方法</li></ul><p>(5)使用Spring导入哪些坐标?</p><ul><li>用别人的东西，就需要在pom.xml添加对应的依赖</li></ul><h4 id="3-1-2-入门案例代码实现"><a href="#3-1-2-入门案例代码实现" class="headerlink" title="3.1.2 入门案例代码实现"></a>3.1.2 入门案例代码实现</h4><blockquote><p>需求分析:将BookServiceImpl和BookDaoImpl交给Spring管理，并从容器中获取对应的bean对象进行方法调用。</p><p>1.创建Maven的java项目</p><p>2.pom.xml添加Spring的依赖jar包</p><p>3.创建BookService,BookServiceImpl，BookDao和BookDaoImpl四个类</p><p>4.resources下添加spring配置文件，并完成bean的配置</p><p>5.使用Spring提供的接口完成IOC容器的创建</p><p>6.从容器中获取对象进行方法调用</p></blockquote><h5 id="步骤1-创建Maven项目"><a href="#步骤1-创建Maven项目" class="headerlink" title="步骤1:创建Maven项目"></a>步骤1:创建Maven项目</h5><p><img src="/2022/11/25/spring01/1629734010072.png" alt="1629734010072"></p><h5 id="步骤2-添加Spring的依赖jar包"><a href="#步骤2-添加Spring的依赖jar包" class="headerlink" title="步骤2:添加Spring的依赖jar包"></a>步骤2:添加Spring的依赖jar包</h5><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="步骤3-添加案例中需要的类"><a href="#步骤3-添加案例中需要的类" class="headerlink" title="步骤3:添加案例中需要的类"></a>步骤3:添加案例中需要的类</h5><p>创建BookService,BookServiceImpl，BookDao和BookDaoImpl四个类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BookDaoImpl</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="步骤4-添加spring配置文件"><a href="#步骤4-添加spring配置文件" class="headerlink" title="步骤4:添加spring配置文件"></a>步骤4:添加spring配置文件</h5><p>resources下添加spring配置文件applicationContext.xml，并完成bean的配置</p><p><img src="/2022/11/25/spring01/1629734336440.png" alt="1629734336440"></p><h5 id="步骤5-在配置文件中完成bean的配置"><a href="#步骤5-在配置文件中完成bean的配置" class="headerlink" title="步骤5:在配置文件中完成bean的配置"></a>步骤5:在配置文件中完成bean的配置</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!--bean标签标示配置bean</span></span><br><span class="line"><span class="comment">    id属性标示给bean起名字</span></span><br><span class="line"><span class="comment">    class属性表示给bean定义类型</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>&#x3D;&#x3D;注意事项：bean定义时id属性在同一个上下文中(配置文件)不能重复&#x3D;&#x3D;</strong></p><h5 id="步骤6-获取IOC容器"><a href="#步骤6-获取IOC容器" class="headerlink" title="步骤6:获取IOC容器"></a>步骤6:获取IOC容器</h5><p>使用Spring提供的接口完成IOC容器的创建，创建App类，编写main方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取IOC容器</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="步骤7-从容器中获取对象进行方法调用"><a href="#步骤7-从容器中获取对象进行方法调用" class="headerlink" title="步骤7:从容器中获取对象进行方法调用"></a>步骤7:从容器中获取对象进行方法调用</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取IOC容器</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>); </span><br><span class="line"><span class="comment">//        BookDao bookDao = (BookDao) ctx.getBean(&quot;bookDao&quot;);</span></span><br><span class="line"><span class="comment">//        bookDao.save();</span></span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> (BookService) ctx.getBean(<span class="string">&quot;bookService&quot;</span>);</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="步骤8-运行程序"><a href="#步骤8-运行程序" class="headerlink" title="步骤8:运行程序"></a>步骤8:运行程序</h5><p>测试结果为：</p><p><img src="/2022/11/25/spring01/image-20210729184337603.png" alt="image-20210729184337603"></p><p>Spring的IOC入门案例已经完成，但是在<code>BookServiceImpl</code>的类中依然存在<code>BookDaoImpl</code>对象的new操作，它们之间的耦合度还是比较高，这块该如何解决，就需要用到下面的<code>DI:依赖注入</code>。</p><h3 id="3-2-DI入门案例"><a href="#3-2-DI入门案例" class="headerlink" title="3.2 DI入门案例"></a>3.2 DI入门案例</h3><p>对于DI的入门案例，我们依然先<code>分析思路</code>然后再<code>代码实现</code>，</p><h4 id="3-2-1-入门案例思路分析"><a href="#3-2-1-入门案例思路分析" class="headerlink" title="3.2.1 入门案例思路分析"></a>3.2.1 入门案例思路分析</h4><p>(1)要想实现依赖注入，必须要基于IOC管理Bean</p><ul><li>DI的入门案例要依赖于前面IOC的入门案例</li></ul><p>(2)Service中使用new形式创建的Dao对象是否保留?</p><ul><li>需要删除掉，最终要使用IOC容器中的bean对象</li></ul><p>(3)Service中需要的Dao对象如何进入到Service中?</p><ul><li>在Service中提供方法，让Spring的IOC容器可以通过该方法传入bean对象</li></ul><p>(4)Service与Dao间的关系如何描述?</p><ul><li>使用配置文件</li></ul><h4 id="3-2-2-入门案例代码实现"><a href="#3-2-2-入门案例代码实现" class="headerlink" title="3.2.2 入门案例代码实现"></a>3.2.2 入门案例代码实现</h4><blockquote><p>需求:基于IOC入门案例，在BookServiceImpl类中删除new对象的方式，使用Spring的DI完成Dao层的注入</p><p>1.删除业务层中使用new的方式创建的dao对象</p><p>2.在业务层提供BookDao的setter方法</p><p>3.在配置文件中添加依赖注入的配置</p><p>4.运行程序调用方法</p></blockquote><h5 id="步骤1-去除代码中的new"><a href="#步骤1-去除代码中的new" class="headerlink" title="步骤1: 去除代码中的new"></a>步骤1: 去除代码中的new</h5><p>在BookServiceImpl类中，删除业务层中使用new的方式创建的dao对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="comment">//删除业务层中使用new的方式创建的dao对象</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="步骤2-为属性提供setter方法"><a href="#步骤2-为属性提供setter方法" class="headerlink" title="步骤2:为属性提供setter方法"></a>步骤2:为属性提供setter方法</h5><p>在BookServiceImpl类中,为BookDao提供setter方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="comment">//删除业务层中使用new的方式创建的dao对象</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//提供对应的set方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="步骤3-修改配置完成注入"><a href="#步骤3-修改配置完成注入" class="headerlink" title="步骤3:修改配置完成注入"></a>步骤3:修改配置完成注入</h5><p>在配置文件中添加依赖注入的配置</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--bean标签标示配置bean</span></span><br><span class="line"><span class="comment">    id属性标示给bean起名字</span></span><br><span class="line"><span class="comment">    class属性表示给bean定义类型</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置server与dao的关系--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--property标签表示配置当前bean的属性</span></span><br><span class="line"><span class="comment">        name属性表示配置哪一个具体的属性</span></span><br><span class="line"><span class="comment">        ref属性表示参照哪一个bean</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;注意:配置中的两个bookDao的含义是不一样的&#x3D;&#x3D;</p><ul><li>name&#x3D;”bookDao”中<code>bookDao</code>的作用是让Spring的IOC容器在获取到名称后，将首字母大写，前面加set找对应的<code>setBookDao()</code>方法进行对象注入</li><li>ref&#x3D;”bookDao”中<code>bookDao</code>的作用是让Spring能在IOC容器中找到id为<code>bookDao</code>的Bean对象给<code>bookService</code>进行注入</li><li>综上所述，对应关系如下:</li></ul><p><img src="/2022/11/25/spring01/1629736314989.png" alt="1629736314989"></p><h5 id="步骤4-运行程序"><a href="#步骤4-运行程序" class="headerlink" title="步骤4:运行程序"></a>步骤4:运行程序</h5><p>运行，测试结果为：</p><p><img src="/2022/11/25/spring01/image-20210729184337603.png" alt="image-20210729184337603"></p><h2 id="4，IOC相关内容"><a href="#4，IOC相关内容" class="headerlink" title="4，IOC相关内容"></a>4，IOC相关内容</h2><p>通过前面两个案例，我们已经学习了<code>bean如何定义配置</code>，<code>DI如何定义配置</code>以及<code>容器对象如何获取</code>的内容，接下来主要是把这三块内容展开进行详细的讲解，深入的学习下这三部分的内容，首先是bean基础配置。</p><h3 id="4-1-bean基础配置"><a href="#4-1-bean基础配置" class="headerlink" title="4.1 bean基础配置"></a>4.1 bean基础配置</h3><p>对于bean的配置中，主要会讲解<code>bean基础配置</code>,<code>bean的别名配置</code>,<code>bean的作用范围配置</code>&#x3D;&#x3D;(重点)&#x3D;&#x3D;,这三部分内容：</p><h4 id="4-1-1-bean基础配置-id与class"><a href="#4-1-1-bean基础配置-id与class" class="headerlink" title="4.1.1 bean基础配置(id与class)"></a>4.1.1 bean基础配置(id与class)</h4><p>对于bean的基础配置，在前面的案例中已经使用过:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;&quot; class=&quot;&quot;/&gt;</span><br></pre></td></tr></table></figure><p>其中，bean标签的功能、使用方式以及id和class属性的作用，我们通过一张图来描述下</p><p><img src="/2022/11/25/spring01/image-20210729183500978.png" alt="image-20210729183500978"></p><p>这其中需要大家重点掌握的是:&#x3D;&#x3D;bean标签的id和class属性的使用&#x3D;&#x3D;。</p><p><strong>思考：</strong></p><ul><li>class属性能不能写接口如<code>BookDao</code>的类全名呢?</li></ul><p>答案肯定是不行，因为接口是没办法创建对象的。</p><ul><li>前面提过为bean设置id时，id必须唯一，但是如果由于命名习惯而产生了分歧后，该如何解决?</li></ul><p>在解决这个问题之前，我们需要准备下开发环境，对于开发环境我们可以有两种解决方案:</p><ul><li><p>使用前面IOC和DI的案例</p></li><li><p>重新搭建一个新的案例环境,目的是方便大家查阅代码</p><ul><li><p>搭建的内容和前面的案例是一样的，内容如下：</p><p><img src="/2022/11/25/spring01/1629769227068.png" alt="1629769227068"></p></li></ul></li></ul><h4 id="4-1-2-bean的name属性"><a href="#4-1-2-bean的name属性" class="headerlink" title="4.1.2 bean的name属性"></a>4.1.2 bean的name属性</h4><p>环境准备好后，接下来就可以在这个环境的基础上来学习下bean的别名配置，</p><p>首先来看下别名的配置说明:</p><p><img src="/2022/11/25/spring01/image-20210729183558051.png" alt="image-20210729183558051"></p><h5 id="步骤1：配置别名"><a href="#步骤1：配置别名" class="headerlink" title="步骤1：配置别名"></a>步骤1：配置别名</h5><p>打开spring的配置文件applicationContext.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--name:为bean指定别名，别名可以有多个，使用逗号，分号，空格进行分隔--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">name</span>=<span class="string">&quot;service service4 bookEbi&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--scope：为bean设置作用范围，可选值为单例singloton，非单例prototype--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">name</span>=<span class="string">&quot;dao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>说明:Ebi全称Enterprise Business Interface，翻译为企业业务接口</strong></p><h5 id="步骤2-根据名称容器中获取bean对象"><a href="#步骤2-根据名称容器中获取bean对象" class="headerlink" title="步骤2:根据名称容器中获取bean对象"></a>步骤2:根据名称容器中获取bean对象</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForName</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//此处根据bean标签的id属性和name属性的任意一个值来获取bean对象</span></span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> (BookService) ctx.getBean(<span class="string">&quot;service4&quot;</span>);</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="步骤3-运行程序"><a href="#步骤3-运行程序" class="headerlink" title="步骤3:运行程序"></a>步骤3:运行程序</h5><p>测试结果为：</p><p><img src="/2022/11/25/spring01/image-20210729184337603.png" alt="image-20210729184337603"></p><p>&#x3D;&#x3D;注意事项:&#x3D;&#x3D;</p><ul><li><p>bean依赖注入的ref属性指定bean，必须在容器中存在</p><p><img src="/2022/11/25/spring01/1629771744003.png" alt="1629771744003"></p></li><li><p>如果不存在,则会报错，如下:</p><p><img src="/2022/11/25/spring01/1629771880920.png" alt="1629771880920"></p><p>这个错误大家需要特别关注下:</p><p><img src="/2022/11/25/spring01/1629771972886.png" alt="1629771972886"></p><p>获取bean无论是通过id还是name获取，如果无法获取到，将抛出异常&#x3D;&#x3D;NoSuchBeanDefinitionException&#x3D;&#x3D;</p></li></ul><h4 id="4-1-3-bean作用范围scope配置"><a href="#4-1-3-bean作用范围scope配置" class="headerlink" title="4.1.3 bean作用范围scope配置"></a>4.1.3 bean作用范围scope配置</h4><p>关于bean的作用范围是bean属性配置的一个&#x3D;&#x3D;重点&#x3D;&#x3D;内容。</p><p>看到这个作用范围，我们就得思考bean的作用范围是来控制bean哪块内容的?</p><p>我们先来看下<code>bean作用范围的配置属性</code>:</p><p><img src="/2022/11/25/spring01/image-20210729183628138.png" alt="image-20210729183628138"></p><h5 id="4-1-3-1-验证IOC容器中对象是否为单例"><a href="#4-1-3-1-验证IOC容器中对象是否为单例" class="headerlink" title="4.1.3.1 验证IOC容器中对象是否为单例"></a>4.1.3.1 验证IOC容器中对象是否为单例</h5><h6 id="验证思路"><a href="#验证思路" class="headerlink" title="验证思路"></a>验证思路</h6><p>​    同一个bean获取两次，将对象打印到控制台，看打印出的地址值是否一致。</p><h6 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h6><ul><li><p>创建一个AppForScope的类，在其main方法中来验证</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForScope</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">            <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao1</span> <span class="operator">=</span> (BookDao) ctx.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao2</span> <span class="operator">=</span> (BookDao) ctx.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line">        System.out.println(bookDao1);</span><br><span class="line">        System.out.println(bookDao2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>打印，观察控制台的打印结果</p><p><img src="/2022/11/25/spring01/1629772538893.png" alt="1629772538893"></p></li><li><p>结论:默认情况下，Spring创建的bean对象都是单例的</p></li></ul><p>获取到结论后，问题就来了，那如果我想创建出来非单例的bean对象，该如何实现呢?</p><h5 id="4-1-3-2-配置bean为非单例"><a href="#4-1-3-2-配置bean为非单例" class="headerlink" title="4.1.3.2 配置bean为非单例"></a>4.1.3.2 配置bean为非单例</h5><p>在Spring配置文件中，配置scope属性来实现bean的非单例创建</p><ul><li><p>在Spring的配置文件中，修改<code>&lt;bean&gt;</code>的scope属性</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">name</span>=<span class="string">&quot;dao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>将scope设置为<code>singleton</code></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">name</span>=<span class="string">&quot;dao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>运行AppForScope，打印看结果</p><p><img src="/2022/11/25/spring01/1629772538893.png" alt="1629772538893"></p></li><li><p>将scope设置为<code>prototype</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;bookDao&quot; name=&quot;dao&quot; class=&quot;com.itheima.dao.impl.BookDaoImpl&quot; scope=&quot;prototype&quot;/&gt;</span><br></pre></td></tr></table></figure><p>运行AppForScope，打印看结果</p><p><img src="/2022/11/25/spring01/1629772928714.png" alt="1629772928714"></p></li><li><p>结论，使用bean的<code>scope</code>属性可以控制bean的创建是否为单例：</p><ul><li><code>singleton</code>默认为单例</li><li><code>prototype</code>为非单例</li></ul></li></ul><h5 id="4-1-3-3-scope使用后续思考"><a href="#4-1-3-3-scope使用后续思考" class="headerlink" title="4.1.3.3 scope使用后续思考"></a>4.1.3.3 scope使用后续思考</h5><p>介绍完<code>scope</code>属性以后，我们来思考几个问题:</p><ul><li>为什么bean默认为单例?<ul><li>bean为单例的意思是在Spring的IOC容器中只会有该类的一个对象</li><li>bean对象只有一个就避免了对象的频繁创建与销毁，达到了bean对象的复用，性能高</li></ul></li><li>bean在容器中是单例的，会不会产生线程安全问题?<ul><li>如果对象是有状态对象，即该对象有成员变量可以用来存储数据的，</li><li>因为所有请求线程共用一个bean对象，所以会存在线程安全问题。</li><li>如果对象是无状态对象，即该对象没有成员变量没有进行数据存储的，</li><li>因方法中的局部变量在方法调用完成后会被销毁，所以不会存在线程安全问题。</li></ul></li><li>哪些bean对象适合交给容器进行管理?<ul><li>表现层对象</li><li>业务层对象</li><li>数据层对象</li><li>工具对象</li></ul></li><li>哪些bean对象不适合交给容器进行管理?<ul><li>封装实例的域对象，因为会引发线程安全问题，所以不适合。</li></ul></li></ul><h4 id="4-14-bean基础配置小结"><a href="#4-14-bean基础配置小结" class="headerlink" title="4.14 bean基础配置小结"></a>4.14 bean基础配置小结</h4><p>关于bean的基础配置中，需要大家掌握以下属性:</p><p><img src="/2022/11/25/spring01/1631529887695.png" alt="1631529887695"></p><h3 id="4-2-bean实例化"><a href="#4-2-bean实例化" class="headerlink" title="4.2 bean实例化"></a>4.2 bean实例化</h3><p>对象已经能交给Spring的IOC容器来创建了，但是容器是如何来创建对象的呢?</p><p>就需要研究下<code>bean的实例化过程</code>，在这块内容中主要解决两部分内容，分别是</p><ul><li>bean是如何创建的</li><li>实例化bean的三种方式，<code>构造方法</code>,<code>静态工厂</code>和<code>实例工厂</code></li></ul><p>在讲解这三种创建方式之前，我们需要先确认一件事:</p><p>bean本质上就是对象，对象在new的时候会使用构造方法完成，那创建bean也是使用构造方法完成的。</p><p>基于这个知识点出发，我们来验证spring中bean的三种创建方式，</p><h4 id="4-2-1-环境准备"><a href="#4-2-1-环境准备" class="headerlink" title="4.2.1 环境准备"></a>4.2.1 环境准备</h4><p>为了方便大家阅读代码，重新准备个开发环境，</p><ul><li>创建一个Maven项目</li><li>pom.xml添加依赖</li><li>resources下添加spring的配置文件applicationContext.xml</li></ul><p>这些步骤和前面的都一致，大家可以快速的拷贝即可，最终项目的结构如下:</p><p><img src="/2022/11/25/spring01/1629775585694.png" alt="1629775585694"></p><h4 id="4-2-2-构造方法实例化"><a href="#4-2-2-构造方法实例化" class="headerlink" title="4.2.2 构造方法实例化"></a>4.2.2 构造方法实例化</h4><p>在上述的环境下，我们来研究下Spring中的第一种bean的创建方式<code>构造方法实例化</code>:</p><h5 id="步骤1-准备需要被创建的类"><a href="#步骤1-准备需要被创建的类" class="headerlink" title="步骤1:准备需要被创建的类"></a>步骤1:准备需要被创建的类</h5><p>准备一个BookDao和BookDaoImpl类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="步骤2-将类配置到Spring容器"><a href="#步骤2-将类配置到Spring容器" class="headerlink" title="步骤2:将类配置到Spring容器"></a>步骤2:将类配置到Spring容器</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="步骤3-编写运行程序"><a href="#步骤3-编写运行程序" class="headerlink" title="步骤3:编写运行程序"></a>步骤3:编写运行程序</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForInstanceBook</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">            <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookDao) ctx.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="步骤4-类中提供构造函数测试"><a href="#步骤4-类中提供构造函数测试" class="headerlink" title="步骤4:类中提供构造函数测试"></a>步骤4:类中提供构造函数测试</h5><p>在BookDaoImpl类中添加一个无参构造函数，并打印一句话，方便观察结果。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BookDaoImpl</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao constructor is running ....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，如果控制台有打印构造函数中的输出，说明Spring容器在创建对象的时候也走的是构造函数</p><p><img src="/2022/11/25/spring01/1629775972507.png" alt="1629775972507"></p><h5 id="步骤5-将构造函数改成private测试"><a href="#步骤5-将构造函数改成private测试" class="headerlink" title="步骤5:将构造函数改成private测试"></a>步骤5:将构造函数改成private测试</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">BookDaoImpl</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao constructor is running ....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，能执行成功,说明内部走的依然是构造函数,能访问到类中的私有构造方法,显而易见Spring底层用的是反射</p><p><img src="/2022/11/25/spring01/1629775972507.png" alt="1629775972507"></p><h5 id="步骤6-构造函数中添加一个参数测试"><a href="#步骤6-构造函数中添加一个参数测试" class="headerlink" title="步骤6:构造函数中添加一个参数测试"></a>步骤6:构造函数中添加一个参数测试</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">BookDaoImpl</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao constructor is running ....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，</p><p>程序会报错，说明Spring底层使用的是类的无参构造方法。</p><p><img src="/2022/11/25/spring01/1629776331499.png" alt="1629776331499"></p><h4 id="4-2-3-分析Spring的错误信息"><a href="#4-2-3-分析Spring的错误信息" class="headerlink" title="4.2.3 分析Spring的错误信息"></a>4.2.3 分析Spring的错误信息</h4><p>接下来，我们主要研究下Spring的报错信息来学一学如阅读。</p><ul><li>错误信息从下往上依次查看，因为上面的错误大都是对下面错误的一个包装，最核心错误是在最下面</li><li>Caused by: java.lang.NoSuchMethodException: com.itheima.dao.impl.BookDaoImpl.<code>&lt;init&gt;</code>()<ul><li>Caused by 翻译为<code>引起</code>，即出现错误的原因</li><li>java.lang.NoSuchMethodException:抛出的异常为<code>没有这样的方法异常</code></li><li>com.itheima.dao.impl.BookDaoImpl.<code>&lt;init&gt;</code>():哪个类的哪个方法没有被找到导致的异常，<code>&lt;init&gt;</code>()指定是类的构造方法，即该类的无参构造方法</li></ul></li></ul><p>如果最后一行错误获取不到错误信息，接下来查看第二层:</p><p>Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [com.itheima.dao.impl.BookDaoImpl]: No default constructor found; nested exception is java.lang.NoSuchMethodException: com.itheima.dao.impl.BookDaoImpl.<code>&lt;init&gt;</code>()</p><ul><li>nested:嵌套的意思，后面的异常内容和最底层的异常是一致的</li><li>Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [com.itheima.dao.impl.BookDaoImpl]: No default constructor found; <ul><li>Caused by: <code>引发</code></li><li>BeanInstantiationException:翻译为<code>bean实例化异常</code></li><li>No default constructor found:没有一个默认的构造函数被发现</li></ul></li></ul><p>看到这其实错误已经比较明显，给大家个练习，把倒数第三层的错误分析下吧:</p><p>Exception in thread “main” org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘bookDao’ defined in class path resource [applicationContext.xml]: Instantiation of bean failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [com.itheima.dao.impl.BookDaoImpl]: No default constructor found; nested exception is java.lang.NoSuchMethodException: com.itheima.dao.impl.BookDaoImpl.<code>&lt;init&gt;</code>()。</p><p>至此，关于Spring的构造方法实例化就已经学习完了，因为每一个类默认都会提供一个无参构造函数，所以其实真正在使用这种方式的时候，我们什么也不需要做。这也是我们以后比较常用的一种方式。</p><h4 id="4-2-4-静态工厂实例化"><a href="#4-2-4-静态工厂实例化" class="headerlink" title="4.2.4 静态工厂实例化"></a>4.2.4 静态工厂实例化</h4><p>接下来研究Spring中的第二种bean的创建方式<code>静态工厂实例化</code>:</p><h5 id="4-2-4-1-工厂方式创建bean"><a href="#4-2-4-1-工厂方式创建bean" class="headerlink" title="4.2.4.1 工厂方式创建bean"></a>4.2.4.1 工厂方式创建bean</h5><p>在讲这种方式之前，我们需要先回顾一个知识点是使用工厂来创建对象的方式:</p><p>(1)准备一个OrderDao和OrderDaoImpl类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">OrderDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;order dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2)创建一个工厂类OrderDaoFactory并提供一个&#x3D;&#x3D;静态方法&#x3D;&#x3D;</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态工厂创建对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderDaoFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> OrderDao <span class="title function_">getOrderDao</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OrderDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(3)编写AppForInstanceOrder运行类，在类中通过工厂获取对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForInstanceOrder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//通过静态工厂创建对象</span></span><br><span class="line">        <span class="type">OrderDao</span> <span class="variable">orderDao</span> <span class="operator">=</span> OrderDaoFactory.getOrderDao();</span><br><span class="line">        orderDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(4)运行后，可以查看到结果</p><p><img src="/2022/11/25/spring01/1629786862329.png" alt="1629786862329"></p><p>如果代码中对象是通过上面的这种方式来创建的，如何将其交给Spring来管理呢?</p><h5 id="4-2-4-2-静态工厂实例化"><a href="#4-2-4-2-静态工厂实例化" class="headerlink" title="4.2.4.2 静态工厂实例化"></a>4.2.4.2 静态工厂实例化</h5><p>这就要用到Spring中的静态工厂实例化的知识了，具体实现步骤为:</p><p>(1)在spring的配置文件application.properties中添加以下内容:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;orderDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.factory.OrderDaoFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getOrderDao&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>class:工厂类的类全名</p><p>factory-mehod:具体工厂类中创建对象的方法名</p><p>对应关系如下图:</p><p><img src="/2022/11/25/spring01/image-20210729195248948.png" alt="image-20210729195248948"></p><p>(2)在AppForInstanceOrder运行类，使用从IOC容器中获取bean的方法进行运行测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForInstanceOrder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">OrderDao</span> <span class="variable">orderDao</span> <span class="operator">=</span> (OrderDao) ctx.getBean(<span class="string">&quot;orderDao&quot;</span>);</span><br><span class="line"></span><br><span class="line">        orderDao.save();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(3)运行后，可以查看到结果</p><p><img src="/2022/11/25/spring01/1629786862329.png" alt="1629786862329"></p><p>看到这，可能有人会问了，你这种方式在工厂类中不也是直接new对象的，和我自己直接new没什么太大的区别，而且静态工厂的方式反而更复杂，这种方式的意义是什么?</p><p>主要的原因是:</p><ul><li>在工厂的静态方法中，我们除了new对象还可以做其他的一些业务操作，这些操作必不可少,如:</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderDaoFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> OrderDao <span class="title function_">getOrderDao</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;factory setup....&quot;</span>);<span class="comment">//模拟必要的业务操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OrderDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前new对象的方式就无法添加其他的业务内容，重新运行，查看结果:</p><p><img src="/2022/11/25/spring01/1629788036885.png" alt="1629788036885"></p><p>介绍完静态工厂实例化后，这种方式一般是用来兼容早期的一些老系统，所以&#x3D;&#x3D;了解为主&#x3D;&#x3D;。</p><h4 id="4-2-5-实例工厂与FactoryBean"><a href="#4-2-5-实例工厂与FactoryBean" class="headerlink" title="4.2.5 实例工厂与FactoryBean"></a>4.2.5 实例工厂与FactoryBean</h4><p>接下来继续来研究Spring的第三种bean的创建方式<code>实例工厂实例化</code>:</p><h5 id="4-2-3-1-环境准备"><a href="#4-2-3-1-环境准备" class="headerlink" title="4.2.3.1 环境准备"></a>4.2.3.1 环境准备</h5><p>(1)准备一个UserDao和UserDaoImpl类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2)创建一个工厂类OrderDaoFactory并提供一个普通方法，注意此处和静态工厂的工厂类不一样的地方是方法不是静态方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> UserDao <span class="title function_">getUserDao</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(3)编写AppForInstanceUser运行类，在类中通过工厂获取对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForInstanceUser</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建实例工厂对象</span></span><br><span class="line">        <span class="type">UserDaoFactory</span> <span class="variable">userDaoFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoFactory</span>();</span><br><span class="line">        <span class="comment">//通过实例工厂对象创建对象</span></span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> userDaoFactory.getUserDao();</span><br><span class="line">        userDao.save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(4)运行后，可以查看到结果</p><p><img src="/2022/11/25/spring01/1629788769436.png" alt="1629788769436"></p><p>对于上面这种实例工厂的方式如何交给Spring管理呢?</p><h5 id="4-2-3-2-实例工厂实例化"><a href="#4-2-3-2-实例工厂实例化" class="headerlink" title="4.2.3.2 实例工厂实例化"></a>4.2.3.2 实例工厂实例化</h5><p>具体实现步骤为:</p><p>(1)在spring的配置文件中添加以下内容:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.factory.UserDaoFactory&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getUserDao&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;userFactory&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>实例化工厂运行的顺序是:</p><ul><li><p>创建实例化工厂对象,对应的是第一行配置</p></li><li><p>调用对象中的方法来创建bean，对应的是第二行配置</p><ul><li><p>factory-bean:工厂的实例对象</p></li><li><p>factory-method:工厂对象中的具体创建对象的方法名,对应关系如下:</p><p><img src="/2022/11/25/spring01/image-20210729200203249.png" alt="image-20210729200203249"></p></li></ul></li></ul><p>factory-mehod:具体工厂类中创建对象的方法名</p><p>(2)在AppForInstanceUser运行类，使用从IOC容器中获取bean的方法进行运行测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForInstanceUser</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">            <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> (UserDao) ctx.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(3)运行后，可以查看到结果</p><p><img src="/2022/11/25/spring01/1629788769436.png" alt="1629788769436"></p><p>实例工厂实例化的方式就已经介绍完了，配置的过程还是比较复杂，所以Spring为了简化这种配置方式就提供了一种叫<code>FactoryBean</code>的方式来简化开发。</p><h5 id="4-2-3-3-FactoryBean的使用"><a href="#4-2-3-3-FactoryBean的使用" class="headerlink" title="4.2.3.3 FactoryBean的使用"></a>4.2.3.3 FactoryBean的使用</h5><p>具体的使用步骤为:</p><p>(1)创建一个UserDaoFactoryBean的类，实现FactoryBean接口，重写接口的方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;UserDao&gt; &#123;</span><br><span class="line">    <span class="comment">//代替原始实例工厂中创建对象的方法</span></span><br><span class="line">    <span class="keyword">public</span> UserDao <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回所创建类的Class对象</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> UserDao.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2)在Spring的配置文件中进行配置</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.factory.UserDaoFactoryBean&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>(3)AppForInstanceUser运行类不用做任何修改，直接运行</p><p><img src="/2022/11/25/spring01/1629788769436.png" alt="1629788769436"></p><p>这种方式在Spring去整合其他框架的时候会被用到，所以这种方式需要大家理解掌握。</p><p>查看源码会发现，FactoryBean接口其实会有三个方法，分别是:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">T <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; getObjectType();</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法一:getObject()，被重写后，在方法中进行对象的创建并返回</p><p>方法二:getObjectType(),被重写后，主要返回的是被创建类的Class对象</p><p>方法三:没有被重写，因为它已经给了默认值，从方法名中可以看出其作用是设置对象是否为单例，默认true，从意思上来看，我们猜想默认应该是单例，如何来验证呢?</p><p>思路很简单，就是从容器中获取该对象的多个值，打印到控制台，查看是否为同一个对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForInstanceUser</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">            <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao1</span> <span class="operator">=</span> (UserDao) ctx.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao2</span> <span class="operator">=</span> (UserDao) ctx.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">        System.out.println(userDao1);</span><br><span class="line">        System.out.println(userDao2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果，如下:</p><p><img src="/2022/11/25/spring01/1629790070607.png" alt="1629790070607"></p><p>通过验证，会发现默认是单例，那如果想改成单例具体如何实现?</p><p>只需要将isSingleton()方法进行重写，修改返回为false，即可</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//FactoryBean创建对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;UserDao&gt; &#123;</span><br><span class="line">    <span class="comment">//代替原始实例工厂中创建对象的方法</span></span><br><span class="line">    <span class="keyword">public</span> UserDao <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> UserDao.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新运行AppForInstanceUser，查看结果</p><p><img src="/2022/11/25/spring01/1629790197860.png" alt="1629790197860"></p><p>从结果中可以看出现在已经是非单例了，但是一般情况下我们都会采用单例，也就是采用默认即可。所以isSingleton()方法一般不需要进行重写。</p><h4 id="4-2-6-bean实例化小结"><a href="#4-2-6-bean实例化小结" class="headerlink" title="4.2.6 bean实例化小结"></a>4.2.6 bean实例化小结</h4><p>通过这一节的学习，需要掌握:</p><p>(1)bean是如何创建的呢?</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">构造方法</span><br></pre></td></tr></table></figure><p>(2)Spring的IOC实例化对象的三种方式分别是:</p><ul><li>构造方法(常用)</li><li>静态工厂(了解)</li><li>实例工厂(了解)<ul><li>FactoryBean(实用)</li></ul></li></ul><p>这些方式中，重点掌握<code>构造方法</code>和<code>FactoryBean</code>即可。</p><p>需要注意的一点是，构造方法在类中默认会提供，但是如果重写了构造方法，默认的就会消失，在使用的过程中需要注意，如果需要重写构造方法，最好把默认的构造方法也重写下。</p><h3 id="4-3-bean的生命周期"><a href="#4-3-bean的生命周期" class="headerlink" title="4.3 bean的生命周期"></a>4.3 bean的生命周期</h3><p>关于bean的相关知识还有最后一个是<code>bean的生命周期</code>,对于生命周期，我们主要围绕着<code>bean生命周期控制</code>来讲解:</p><ul><li>首先理解下什么是生命周期?<ul><li>从创建到消亡的完整过程,例如人从出生到死亡的整个过程就是一个生命周期。</li></ul></li><li>bean生命周期是什么?<ul><li>bean对象从创建到销毁的整体过程。</li></ul></li><li>bean生命周期控制是什么?<ul><li>在bean创建后到销毁前做一些事情。</li></ul></li></ul><p>现在我们面临的问题是如何在bean的创建之后和销毁之前把我们需要添加的内容添加进去。</p><h4 id="4-3-1-环境准备"><a href="#4-3-1-环境准备" class="headerlink" title="4.3.1 环境准备"></a>4.3.1 环境准备</h4><p>还是老规矩，为了方便大家后期代码的阅读，我们重新搭建下环境:</p><ul><li>创建一个Maven项目</li><li>pom.xml添加依赖</li><li>resources下添加spring的配置文件applicationContext.xml</li></ul><p>这些步骤和前面的都一致，大家可以快速的拷贝即可，最终项目的结构如下:</p><p><img src="/2022/11/25/spring01/1629791473409.png" alt="1629791473409"></p><p>(1)项目中添加BookDao、BookDaoImpl、BookService和BookServiceImpl类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2)resources下提供spring的配置文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>(3)编写AppForLifeCycle运行类，加载Spring的IOC容器，并从中获取对应的bean对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForLifeCycle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">        <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookDao) ctx.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-2-生命周期设置"><a href="#4-3-2-生命周期设置" class="headerlink" title="4.3.2 生命周期设置"></a>4.3.2 生命周期设置</h4><p>接下来，在上面这个环境中来为BookDao添加生命周期的控制方法，具体的控制有两个阶段:</p><ul><li>bean创建之后，想要添加内容，比如用来初始化需要用到资源</li><li>bean销毁之前，想要添加内容，比如用来释放用到的资源</li></ul><h5 id="步骤1-添加初始化和销毁方法"><a href="#步骤1-添加初始化和销毁方法" class="headerlink" title="步骤1:添加初始化和销毁方法"></a>步骤1:添加初始化和销毁方法</h5><p>针对这两个阶段，我们在BooDaoImpl类中分别添加两个方法，&#x3D;&#x3D;方法名任意&#x3D;&#x3D;</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//表示bean初始化对应的操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//表示bean销毁前对应的操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destory</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destory...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="步骤2-配置生命周期"><a href="#步骤2-配置生命周期" class="headerlink" title="步骤2:配置生命周期"></a>步骤2:配置生命周期</h5><p>在配置文件添加配置，如下:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destory&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h5 id="步骤3-运行程序-1"><a href="#步骤3-运行程序-1" class="headerlink" title="步骤3:运行程序"></a>步骤3:运行程序</h5><p>运行AppForLifeCycle打印结果为:</p><p><img src="/2022/11/25/spring01/1629792339889.png" alt="1629792339889"></p><p>从结果中可以看出，init方法执行了，但是destroy方法却未执行，这是为什么呢?</p><ul><li>Spring的IOC容器是运行在JVM中</li><li>运行main方法后,JVM启动,Spring加载配置文件生成IOC容器,从容器获取bean对象，然后调方法执行</li><li>main方法执行完后，JVM退出，这个时候IOC容器中的bean还没有来得及销毁就已经结束了</li><li>所以没有调用对应的destroy方法</li></ul><p>知道了出现问题的原因，具体该如何解决呢?</p><h4 id="4-3-3-close关闭容器"><a href="#4-3-3-close关闭容器" class="headerlink" title="4.3.3 close关闭容器"></a>4.3.3 close关闭容器</h4><ul><li><p>ApplicationContext中没有close方法</p></li><li><p>需要将ApplicationContext更换成ClassPathXmlApplicationContext</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ClassPathXmlApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">    <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>调用ctx的close()方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctx.close();</span><br></pre></td></tr></table></figure></li><li><p>运行程序，就能执行destroy方法的内容</p><p><img src="/2022/11/25/spring01/1629792857608.png" alt="1629792857608"></p></li></ul><h4 id="4-3-4-注册钩子关闭容器"><a href="#4-3-4-注册钩子关闭容器" class="headerlink" title="4.3.4 注册钩子关闭容器"></a>4.3.4 注册钩子关闭容器</h4><ul><li><p>在容器未关闭之前，提前设置好回调函数，让JVM在退出之前回调此函数来关闭容器</p></li><li><p>调用ctx的registerShutdownHook()方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctx.registerShutdownHook();</span><br></pre></td></tr></table></figure><p>**注意:**registerShutdownHook在ApplicationContext中也没有</p></li><li><p>运行后，查询打印结果</p><p><img src="/2022/11/25/spring01/1629792857608.png" alt="1629792857608"></p></li></ul><p>两种方式介绍完后，close和registerShutdownHook选哪个?</p><p>相同点:这两种都能用来关闭容器</p><p>不同点:close()是在调用的时候关闭，registerShutdownHook()是在JVM退出前调用关闭。</p><p>分析上面的实现过程，会发现添加初始化和销毁方法，即需要编码也需要配置，实现起来步骤比较多也比较乱。</p><p>Spring提供了两个接口来完成生命周期的控制，好处是可以不用再进行配置<code>init-method</code>和<code>destroy-method</code></p><p>接下来在BookServiceImpl完成这两个接口的使用:</p><p>修改BookServiceImpl类，添加两个接口<code>InitializingBean</code>， <code>DisposableBean</code>并实现接口中的两个方法<code>afterPropertiesSet</code>和<code>destroy</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>, InitializingBean, DisposableBean &#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;service destroy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;service init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新运行AppForLifeCycle类，</p><p><img src="/2022/11/25/spring01/1629794527419.png" alt="1629794527419"></p><p>那第二种方式的实现，我们也介绍完了。</p><p><strong>小细节</strong></p><ul><li><p>对于InitializingBean接口中的afterPropertiesSet方法，翻译过来为<code>属性设置之后</code>。</p></li><li><p>对于BookServiceImpl来说，bookDao是它的一个属性</p></li><li><p>setBookDao方法是Spring的IOC容器为其注入属性的方法</p></li><li><p>思考:afterPropertiesSet和setBookDao谁先执行?</p><ul><li><p>从方法名分析，猜想应该是setBookDao方法先执行</p></li><li><p>验证思路，在setBookDao方法中添加一句话</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;set .....&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>重新运行AppForLifeCycle，打印结果如下:</p><p><img src="/2022/11/25/spring01/1629794928636.png" alt="1629794928636"></p><p>验证的结果和我们猜想的结果是一致的，所以初始化方法会在类中属性设置之后执行。</p></li></ul></li></ul><h4 id="4-3-5-bean生命周期小结"><a href="#4-3-5-bean生命周期小结" class="headerlink" title="4.3.5 bean生命周期小结"></a>4.3.5 bean生命周期小结</h4><p>(1)关于Spring中对bean生命周期控制提供了两种方式:</p><ul><li>在配置文件中的bean标签中添加<code>init-method</code>和<code>destroy-method</code>属性</li><li>类实现<code>InitializingBean</code>与<code>DisposableBean</code>接口，这种方式了解下即可。</li></ul><p>(2)对于bean的生命周期控制在bean的整个生命周期中所处的位置如下:</p><ul><li>初始化容器<ul><li>1.创建对象(内存分配)</li><li>2.执行构造方法</li><li>3.执行属性注入(set操作)</li><li>&#x3D;&#x3D;4.执行bean初始化方法&#x3D;&#x3D;</li></ul></li><li>使用bean<ul><li>1.执行业务操作</li></ul></li><li>关闭&#x2F;销毁容器<ul><li>&#x3D;&#x3D;1.执行bean销毁方法&#x3D;&#x3D;</li></ul></li></ul><p>(3)关闭容器的两种方式:</p><ul><li>ConfigurableApplicationContext是ApplicationContext的子类<ul><li>close()方法</li><li>registerShutdownHook()方法</li></ul></li></ul><h2 id="5，DI相关内容"><a href="#5，DI相关内容" class="headerlink" title="5，DI相关内容"></a>5，DI相关内容</h2><p>前面我们已经完成了bean相关操作的讲解，接下来就进入第二个大的模块<code>DI依赖注入</code>，首先来介绍下Spring中有哪些注入方式?</p><p>我们先来思考</p><ul><li>向一个类中传递数据的方式有几种?<ul><li>普通方法(set方法)</li><li>构造方法</li></ul></li><li>依赖注入描述了在容器中建立bean与bean之间的依赖关系的过程，如果bean运行需要的是数字或字符串呢?<ul><li>引用类型</li><li>简单类型(基本数据类型与String)</li></ul></li></ul><p>Spring就是基于上面这些知识点，为我们提供了两种注入方式，分别是:</p><ul><li>setter注入<ul><li>简单类型</li><li>&#x3D;&#x3D;引用类型&#x3D;&#x3D;</li></ul></li><li>构造器注入<ul><li>简单类型</li><li>引用类型</li></ul></li></ul><p>依赖注入的方式已经介绍完，接下来挨个学习下:</p><h3 id="5-1-setter注入"><a href="#5-1-setter注入" class="headerlink" title="5.1 setter注入"></a>5.1 setter注入</h3><ol><li>对于setter方式注入引用类型的方式之前已经学习过，快速回顾下:</li></ol><ul><li>在bean中定义引用类型属性，并提供可访问的&#x3D;&#x3D;set&#x3D;&#x3D;方法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>配置中使用&#x3D;&#x3D;property&#x3D;&#x3D;标签&#x3D;&#x3D;ref&#x3D;&#x3D;属性注入引用类型对象</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.imipl.BookDaoImpl&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="5-1-1-环境准备"><a href="#5-1-1-环境准备" class="headerlink" title="5.1.1 环境准备"></a>5.1.1 环境准备</h4><p>为了更好的学习下面内容，我们依旧准备一个新环境:</p><ul><li>创建一个Maven项目</li><li>pom.xml添加依赖</li><li>resources下添加spring的配置文件</li></ul><p>这些步骤和前面的都一致，大家可以快速的拷贝即可，最终项目的结构如下:</p><p><img src="/2022/11/25/spring01/1629799214191.png" alt="1629799214191"></p><p>(1)项目中添加BookDao、BookDaoImpl、UserDao、UserDaoImpl、BookService和BookServiceImpl类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2)resources下提供spring的配置文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>(3)编写AppForDISet运行类，加载Spring的IOC容器，并从中获取对应的bean对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForDISet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> (BookService) ctx.getBean(<span class="string">&quot;bookService&quot;</span>);</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，在上面这个环境中来完成setter注入的学习:</p><h4 id="5-1-2-注入引用数据类型"><a href="#5-1-2-注入引用数据类型" class="headerlink" title="5.1.2 注入引用数据类型"></a>5.1.2 注入引用数据类型</h4><blockquote><p>需求:在bookServiceImpl对象中注入userDao</p><p>1.在BookServiceImpl中声明userDao属性</p><p>2.为userDao属性提供setter方法</p><p>3.在配置文件中使用property标签注入</p></blockquote><h5 id="步骤1-声明属性并提供setter方法"><a href="#步骤1-声明属性并提供setter方法" class="headerlink" title="步骤1:声明属性并提供setter方法"></a>步骤1:声明属性并提供setter方法</h5><p>在BookServiceImpl中声明userDao属性，并提供setter方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="步骤2-配置文件中进行注入配置"><a href="#步骤2-配置文件中进行注入配置" class="headerlink" title="步骤2:配置文件中进行注入配置"></a>步骤2:配置文件中进行注入配置</h5><p>在applicationContext.xml配置文件中使用property标签注入</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="步骤3-运行程序-2"><a href="#步骤3-运行程序-2" class="headerlink" title="步骤3:运行程序"></a>步骤3:运行程序</h5><p>运行AppForDISet类，查看结果，说明userDao已经成功注入。</p><p><img src="/2022/11/25/spring01/1629799873386.png" alt="1629799873386"></p><h4 id="5-1-3-注入简单数据类型"><a href="#5-1-3-注入简单数据类型" class="headerlink" title="5.1.3 注入简单数据类型"></a>5.1.3 注入简单数据类型</h4><blockquote><p>需求：给BookDaoImpl注入一些简单数据类型的数据</p><p>参考引用数据类型的注入，我们可以推出具体的步骤为:</p><p>1.在BookDaoImpl类中声明对应的简单数据类型的属性</p><p>2.为这些属性提供对应的setter方法</p><p>3.在applicationContext.xml中配置</p></blockquote><p><strong>思考:</strong></p><p>引用类型使用的是<code>&lt;property name=&quot;&quot; ref=&quot;&quot;/&gt;</code>,简单数据类型还是使用ref么?</p><p>ref是指向Spring的IOC容器中的另一个bean对象的，对于简单数据类型，没有对应的bean对象，该如何配置?</p><h5 id="步骤1-声明属性并提供setter方法-1"><a href="#步骤1-声明属性并提供setter方法-1" class="headerlink" title="步骤1:声明属性并提供setter方法"></a>步骤1:声明属性并提供setter方法</h5><p>在BookDaoImpl类中声明对应的简单数据类型的属性,并提供对应的setter方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String databaseName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> connectionNum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setConnectionNum</span><span class="params">(<span class="type">int</span> connectionNum)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.connectionNum = connectionNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDatabaseName</span><span class="params">(String databaseName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.databaseName = databaseName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>+databaseName+<span class="string">&quot;,&quot;</span>+connectionNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="步骤2-配置文件中进行注入配置-1"><a href="#步骤2-配置文件中进行注入配置-1" class="headerlink" title="步骤2:配置文件中进行注入配置"></a>步骤2:配置文件中进行注入配置</h5><p>在applicationContext.xml配置文件中使用property标签注入</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;databaseName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connectionNum&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><p>value:后面跟的是简单数据类型，对于参数类型，Spring在注入的时候会自动转换，但是不能写成</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connectionNum&quot;</span> <span class="attr">value</span>=<span class="string">&quot;abc&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>这样的话，spring在将<code>abc</code>转换成int类型的时候就会报错。</p><h5 id="步骤3-运行程序-3"><a href="#步骤3-运行程序-3" class="headerlink" title="步骤3:运行程序"></a>步骤3:运行程序</h5><p>运行AppForDISet类，查看结果，说明userDao已经成功注入。</p><p><img src="/2022/11/25/spring01/1629800324721.png" alt="1629800324721"></p><p>**注意:**两个property注入标签的顺序可以任意。</p><p>对于setter注入方式的基本使用就已经介绍完了，</p><ul><li>对于引用数据类型使用的是<code>&lt;property name=&quot;&quot; ref=&quot;&quot;/&gt;</code></li><li>对于简单数据类型使用的是<code>&lt;property name=&quot;&quot; value=&quot;&quot;/&gt;</code></li></ul><h3 id="5-2-构造器注入"><a href="#5-2-构造器注入" class="headerlink" title="5.2 构造器注入"></a>5.2 构造器注入</h3><h4 id="5-2-1-环境准备"><a href="#5-2-1-环境准备" class="headerlink" title="5.2.1 环境准备"></a>5.2.1 环境准备</h4><p>构造器注入也就是构造方法注入，学习之前，还是先准备下环境:</p><ul><li>创建一个Maven项目</li><li>pom.xml添加依赖</li><li>resources下添加spring的配置文件</li></ul><p>这些步骤和前面的都一致，大家可以快速的拷贝即可，最终项目的结构如下:</p><p><img src="/2022/11/25/spring01/1629800748639.png" alt="1629800748639"></p><p>(1)项目中添加BookDao、BookDaoImpl、UserDao、UserDaoImpl、BookService和BookServiceImpl类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String databaseName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> connectionNum;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2)resources下提供spring的配置文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>(3)编写AppForDIConstructor运行类，加载Spring的IOC容器，并从中获取对应的bean对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForDIConstructor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> (BookService) ctx.getBean(<span class="string">&quot;bookService&quot;</span>);</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-2-构造器注入引用数据类型"><a href="#5-2-2-构造器注入引用数据类型" class="headerlink" title="5.2.2 构造器注入引用数据类型"></a>5.2.2 构造器注入引用数据类型</h4><p>接下来，在上面这个环境中来完成构造器注入的学习:</p><blockquote><p>需求：将BookServiceImpl类中的bookDao修改成使用构造器的方式注入。</p><p>1.将bookDao的setter方法删除掉</p><p>2.添加带有bookDao参数的构造方法</p><p>3.在applicationContext.xml中配置</p></blockquote><h5 id="步骤1-删除setter方法并提供构造方法"><a href="#步骤1-删除setter方法并提供构造方法" class="headerlink" title="步骤1:删除setter方法并提供构造方法"></a>步骤1:删除setter方法并提供构造方法</h5><p>在BookServiceImpl类中将bookDao的setter方法删除掉,并添加带有bookDao参数的构造方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BookServiceImpl</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="步骤2-配置文件中进行配置构造方式注入"><a href="#步骤2-配置文件中进行配置构造方式注入" class="headerlink" title="步骤2:配置文件中进行配置构造方式注入"></a>步骤2:配置文件中进行配置构造方式注入</h5><p>在applicationContext.xml中配置</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><p>标签<constructor-arg>中</constructor-arg></p><ul><li><p>name属性对应的值为构造函数中方法形参的参数名，必须要保持一致。</p></li><li><p>ref属性指向的是spring的IOC容器中其他bean对象。</p></li></ul><h5 id="步骤3：运行程序"><a href="#步骤3：运行程序" class="headerlink" title="步骤3：运行程序"></a>步骤3：运行程序</h5><p>运行AppForDIConstructor类，查看结果，说明bookDao已经成功注入。</p><p><img src="/2022/11/25/spring01/1629802656916.png" alt="1629802656916"></p><h4 id="5-2-3-构造器注入多个引用数据类型"><a href="#5-2-3-构造器注入多个引用数据类型" class="headerlink" title="5.2.3 构造器注入多个引用数据类型"></a>5.2.3 构造器注入多个引用数据类型</h4><blockquote><p>需求:在BookServiceImpl使用构造函数注入多个引用数据类型，比如userDao</p><p>1.声明userDao属性</p><p>2.生成一个带有bookDao和userDao参数的构造函数</p><p>3.在applicationContext.xml中配置注入</p></blockquote><h5 id="步骤1-提供多个属性的构造函数"><a href="#步骤1-提供多个属性的构造函数" class="headerlink" title="步骤1:提供多个属性的构造函数"></a>步骤1:提供多个属性的构造函数</h5><p>在BookServiceImpl声明userDao并提供多个参数的构造函数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BookServiceImpl</span><span class="params">(BookDao bookDao,UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤2:配置文件中配置多参数注入</p><p>在applicationContext.xml中配置注入</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>**说明:**这两个<code>&lt;contructor-arg&gt;</code>的配置顺序可以任意</p><h5 id="步骤3-运行程序-4"><a href="#步骤3-运行程序-4" class="headerlink" title="步骤3:运行程序"></a>步骤3:运行程序</h5><p>运行AppForDIConstructor类，查看结果，说明userDao已经成功注入。</p><p><img src="/2022/11/25/spring01/1629802697318.png" alt="1629802697318"></p><h4 id="5-2-4-构造器注入多个简单数据类型"><a href="#5-2-4-构造器注入多个简单数据类型" class="headerlink" title="5.2.4 构造器注入多个简单数据类型"></a>5.2.4 构造器注入多个简单数据类型</h4><blockquote><p>需求:在BookDaoImpl中，使用构造函数注入databaseName和connectionNum两个参数。</p><p>参考引用数据类型的注入，我们可以推出具体的步骤为:</p><p>1.提供一个包含这两个参数的构造方法</p><p>2.在applicationContext.xml中进行注入配置</p></blockquote><h5 id="步骤1-添加多个简单属性并提供构造方法"><a href="#步骤1-添加多个简单属性并提供构造方法" class="headerlink" title="步骤1:添加多个简单属性并提供构造方法"></a>步骤1:添加多个简单属性并提供构造方法</h5><p>修改BookDaoImpl类，添加构造方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String databaseName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> connectionNum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BookDaoImpl</span><span class="params">(String databaseName, <span class="type">int</span> connectionNum)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.databaseName = databaseName;</span><br><span class="line">        <span class="built_in">this</span>.connectionNum = connectionNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>+databaseName+<span class="string">&quot;,&quot;</span>+connectionNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="步骤2-配置完成多个属性构造器注入"><a href="#步骤2-配置完成多个属性构造器注入" class="headerlink" title="步骤2:配置完成多个属性构造器注入"></a>步骤2:配置完成多个属性构造器注入</h5><p>在applicationContext.xml中进行注入配置</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;databaseName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;connectionNum&quot;</span> <span class="attr">value</span>=<span class="string">&quot;666&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>**说明:**这两个<code>&lt;contructor-arg&gt;</code>的配置顺序可以任意</p><h5 id="步骤3-运行程序-5"><a href="#步骤3-运行程序-5" class="headerlink" title="步骤3:运行程序"></a>步骤3:运行程序</h5><p>运行AppForDIConstructor类，查看结果</p><p><img src="/2022/11/25/spring01/1629803111769.png" alt="1629803111769"></p><p>上面已经完成了构造函数注入的基本使用，但是会存在一些问题:</p><p><img src="/2022/11/25/spring01/1629803529598.png" alt="1629803529598"></p><ul><li>当构造函数中方法的参数名发生变化后，配置文件中的name属性也需要跟着变</li><li>这两块存在紧耦合，具体该如何解决?</li></ul><p>在解决这个问题之前，需要提前说明的是，这个参数名发生变化的情况并不多，所以上面的还是比较主流的配置方式，下面介绍的，大家都以了解为主。</p><p>方式一:删除name属性，添加type属性，按照类型注入</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;int&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>这种方式可以解决构造函数形参名发生变化带来的耦合问题</li><li>但是如果构造方法参数中有类型相同的参数，这种方式就不太好实现了</li></ul><p>方式二:删除type属性，添加index属性，按照索引下标注入，下标从0开始</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>这种方式可以解决参数类型重复问题</li><li>但是如果构造方法参数顺序发生变化后，这种方式又带来了耦合问题</li></ul><p>介绍完两种参数的注入方式，具体我们该如何选择呢?</p><ol><li>强制依赖使用构造器进行，使用setter注入有概率不进行注入导致null对象出现<ul><li>强制依赖指对象在创建的过程中必须要注入指定的参数</li></ul></li><li>可选依赖使用setter注入进行，灵活性强<ul><li>可选依赖指对象在创建过程中注入的参数可有可无</li></ul></li><li>Spring框架倡导使用构造器，第三方框架内部大多数采用构造器注入的形式进行数据初始化，相对严谨</li><li>如果有必要可以两者同时使用，使用构造器注入完成强制依赖的注入，使用setter注入完成可选依赖的注入</li><li>实际开发过程中还要根据实际情况分析，如果受控对象没有提供setter方法就必须使用构造器注入</li><li><strong>&#x3D;&#x3D;自己开发的模块推荐使用setter注入&#x3D;&#x3D;</strong></li></ol><p>这节中主要讲解的是Spring的依赖注入的实现方式:</p><ul><li><p>setter注入</p><ul><li><p>简单数据类型</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">...</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>引用数据类型</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">...</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>构造器注入</p><ul><li><p>简单数据类型</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">...</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">index</span>=<span class="string">&quot;&quot;</span> <span class="attr">type</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>引用数据类型</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">...</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">index</span>=<span class="string">&quot;&quot;</span> <span class="attr">type</span>=<span class="string">&quot;&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>依赖注入的方式选择上</p><ul><li>建议使用setter注入</li><li>第三方技术根据情况选择</li></ul></li></ul><h3 id="5-3-自动配置"><a href="#5-3-自动配置" class="headerlink" title="5.3 自动配置"></a>5.3 自动配置</h3><p>前面花了大量的时间把Spring的注入去学习了下，总结起来就一个字&#x3D;&#x3D;麻烦&#x3D;&#x3D;。</p><p>问:麻烦在哪?</p><p>答:配置文件的编写配置上。</p><p>问:有更简单方式么?</p><p>答:有，自动配置</p><p>什么是自动配置以及如何实现自动配置，就是接下来要学习的内容：</p><h4 id="5-3-1-什么是依赖自动装配"><a href="#5-3-1-什么是依赖自动装配" class="headerlink" title="5.3.1 什么是依赖自动装配?"></a>5.3.1 什么是依赖自动装配?</h4><ul><li>IoC容器根据bean所依赖的资源在容器中自动查找并注入到bean中的过程称为自动装配</li></ul><h4 id="5-3-2-自动装配方式有哪些"><a href="#5-3-2-自动装配方式有哪些" class="headerlink" title="5.3.2 自动装配方式有哪些?"></a>5.3.2 自动装配方式有哪些?</h4><ul><li>&#x3D;&#x3D;按类型（常用）&#x3D;&#x3D;</li><li>按名称</li><li>按构造方法</li><li>不启用自动装配</li></ul><h4 id="5-3-3-准备下案例环境"><a href="#5-3-3-准备下案例环境" class="headerlink" title="5.3.3 准备下案例环境"></a>5.3.3 准备下案例环境</h4><ul><li>创建一个Maven项目</li><li>pom.xml添加依赖</li><li>resources下添加spring的配置文件</li></ul><p>这些步骤和前面的都一致，大家可以快速的拷贝即可，最终项目的结构如下:</p><p><img src="/2022/11/25/spring01/1629805387647.png" alt="1629805387647"></p><p>(1)项目中添加BookDao、BookDaoImpl、BookService和BookServiceImpl类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String databaseName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> connectionNum;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2)resources下提供spring的配置文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>(3)编写AppForAutoware运行类，加载Spring的IOC容器，并从中获取对应的bean对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForAutoware</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> (BookService) ctx.getBean(<span class="string">&quot;bookService&quot;</span>);</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-3-4-完成自动装配的配置"><a href="#5-3-4-完成自动装配的配置" class="headerlink" title="5.3.4 完成自动装配的配置"></a>5.3.4 完成自动装配的配置</h4><p>接下来，在上面这个环境中来完成<code>自动装配</code>的学习:</p><p>自动装配只需要修改applicationContext.xml配置文件即可:</p><p>(1)将<code>&lt;property&gt;</code>标签删除</p><p>(2)在<code>&lt;bean&gt;</code>标签中添加autowire属性</p><p>首先来实现按照类型注入的配置</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--autowire属性：开启自动装配，通常使用按类型装配--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;注意事项:&#x3D;&#x3D;</p><ul><li>需要注入属性的类中对应属性的setter方法不能省略</li><li>被注入的对象必须要被Spring的IOC容器管理</li><li>按照类型在Spring的IOC容器中如果找到多个对象，会报<code>NoUniqueBeanDefinitionException</code></li></ul><p>一个类型在IOC中有多个对象，还想要注入成功，这个时候就需要按照名称注入，配置方式为:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--autowire属性：开启自动装配，通常使用按类型装配--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;注意事项:&#x3D;&#x3D;</p><ul><li><p>按照名称注入中的名称指的是什么?</p><p><img src="/2022/11/25/spring01/1629806856156.png" alt="1629806856156"></p><ul><li>bookDao是private修饰的，外部类无法直接方法</li><li>外部类只能通过属性的set方法进行访问</li><li>对外部类来说，setBookDao方法名，去掉set后首字母小写是其属性名<ul><li>为什么是去掉set首字母小写?</li><li>这个规则是set方法生成的默认规则，set方法的生成是把属性名首字母大写前面加set形成的方法名</li></ul></li><li>所以按照名称注入，其实是和对应的set方法有关，但是如果按照标准起名称，属性名和set对应的名是一致的</li></ul></li><li><p>如果按照名称去找对应的bean对象，找不到则注入Null</p></li><li><p>当某一个类型在IOC容器中有多个对象，按照名称注入只找其指定名称对应的bean对象，不会报错</p></li></ul><p>两种方式介绍完后，以后用的更多的是&#x3D;&#x3D;按照类型&#x3D;&#x3D;注入。</p><p>最后对于依赖注入，需要注意一些其他的配置特征:</p><ol><li>自动装配用于引用类型依赖注入，不能对简单类型进行操作</li><li>使用按类型装配时（byType）必须保障容器中相同类型的bean唯一，推荐使用</li><li>使用按名称装配时（byName）必须保障容器中具有指定名称的bean，因变量名与配置耦合，不推荐使用</li><li>自动装配优先级低于setter注入与构造器注入，同时出现时自动装配配置失效</li></ol><h3 id="5-4-集合注入"><a href="#5-4-集合注入" class="headerlink" title="5.4 集合注入"></a>5.4 集合注入</h3><p>前面我们已经能完成引入数据类型和简单数据类型的注入，但是还有一种数据类型&#x3D;&#x3D;集合&#x3D;&#x3D;，集合中既可以装简单数据类型也可以装引用数据类型，对于集合，在Spring中该如何注入呢?</p><p>先来回顾下，常见的集合类型有哪些?</p><ul><li>数组</li><li>List</li><li>Set</li><li>Map</li><li>Properties</li></ul><p>针对不同的集合类型，该如何实现注入呢?</p><h4 id="5-4-1-环境准备"><a href="#5-4-1-环境准备" class="headerlink" title="5.4.1 环境准备"></a>5.4.1 环境准备</h4><ul><li>创建一个Maven项目</li><li>pom.xml添加依赖</li><li>resources下添加spring的配置文件applicationContext.xml</li></ul><p>这些步骤和前面的都一致，大家可以快速的拷贝即可，最终项目的结构如下:</p><p><img src="/2022/11/25/spring01/1629807579330.png" alt="1629807579330"></p><p>(1)项目中添加添加BookDao、BookDaoImpl类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; set;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Properties properties;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;遍历数组:&quot;</span> + Arrays.toString(array));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;遍历List&quot;</span> + list);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;遍历Set&quot;</span> + set);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;遍历Map&quot;</span> + map);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;遍历Properties&quot;</span> + properties);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//setter....方法省略，自己使用工具生成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2)resources下提供spring的配置文件，applicationContext.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>(3)编写AppForDICollection运行类，加载Spring的IOC容器，并从中获取对应的bean对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForDICollection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookDao) ctx.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，在上面这个环境中来完成<code>集合注入</code>的学习:</p><p>下面的所以配置方式，都是在bookDao的bean标签中使用<property>进行注入</property></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="5-4-2-注入数组类型数据"><a href="#5-4-2-注入数组类型数据" class="headerlink" title="5.4.2 注入数组类型数据"></a>5.4.2 注入数组类型数据</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;array&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>100<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>200<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>300<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="5-4-3-注入List类型数据"><a href="#5-4-3-注入List类型数据" class="headerlink" title="5.4.3 注入List类型数据"></a>5.4.3 注入List类型数据</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>itcast<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>itheima<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>boxuegu<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>chuanzhihui<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="5-4-4-注入Set类型数据"><a href="#5-4-4-注入Set类型数据" class="headerlink" title="5.4.4 注入Set类型数据"></a>5.4.4 注入Set类型数据</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;set&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>itcast<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>itheima<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>boxuegu<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>boxuegu<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="5-4-5-注入Map类型数据"><a href="#5-4-5-注入Map类型数据" class="headerlink" title="5.4.5 注入Map类型数据"></a>5.4.5 注入Map类型数据</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;country&quot;</span> <span class="attr">value</span>=<span class="string">&quot;china&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;province&quot;</span> <span class="attr">value</span>=<span class="string">&quot;henan&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;city&quot;</span> <span class="attr">value</span>=<span class="string">&quot;kaifeng&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="5-4-6-注入Properties类型数据"><a href="#5-4-6-注入Properties类型数据" class="headerlink" title="5.4.6 注入Properties类型数据"></a>5.4.6 注入Properties类型数据</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;properties&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;country&quot;</span>&gt;</span>china<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;province&quot;</span>&gt;</span>henan<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;city&quot;</span>&gt;</span>kaifeng<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置完成后，运行下看结果:</p><p><img src="/2022/11/25/spring01/1629808046783.png" alt="1629808046783"></p><p><strong>说明：</strong></p><ul><li>property标签表示setter方式注入，构造方式注入constructor-arg标签内部也可以写<code>&lt;array&gt;</code>、<code>&lt;list&gt;</code>、<code>&lt;set&gt;</code>、<code>&lt;map&gt;</code>、<code>&lt;props&gt;</code>标签</li><li>List的底层也是通过数组实现的，所以<code>&lt;list&gt;</code>和<code>&lt;array&gt;</code>标签是可以混用</li><li>集合中要添加引用类型，只需要把<code>&lt;value&gt;</code>标签改成<code>&lt;ref&gt;</code>标签，这种方式用的比较少</li></ul>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>css特效</title>
      <link href="/2022/11/24/css%E7%89%B9%E6%95%8801/"/>
      <url>/2022/11/24/css%E7%89%B9%E6%95%8801/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>maven高级</title>
      <link href="/2022/11/24/maven%E9%AB%98%E7%BA%A7/"/>
      <url>/2022/11/24/maven%E9%AB%98%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> maven </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>maven基础</title>
      <link href="/2022/11/24/maven%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/11/24/maven%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Maven基础"><a href="#Maven基础" class="headerlink" title="Maven基础"></a>Maven基础</h1><h2 id="Maven基础概念"><a href="#Maven基础概念" class="headerlink" title="Maven基础概念"></a>Maven基础概念</h2><h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><ul><li><p>仓库：用于存储资源，包含各种jar包</p></li><li><p>仓库分类：</p><ul><li>本地仓库：自己电脑上存储资源的仓库，连接远程仓库获取资源</li><li>远程仓库：非本机电脑上的仓库，为本地仓库提供资源<ul><li>中央仓库：Maven团队维护，存储所有资源的仓库</li><li>私服：部门&#x2F;公司范围内存储资源的仓库，从中央仓库获取资源</li></ul></li></ul></li><li><p>私服的作用：</p><ul><li><p>保存具有版权的资源，包含购买或自主研发的jar</p><ul><li>中央仓库的jar都是开源的，不能存储具有版权的资源</li></ul></li><li><p>一定范围内共享资源，仅对内部开放，不对外共享</p></li></ul></li></ul><img src="/2022/11/24/maven%E5%9F%BA%E7%A1%80/maven01/image-20221124091535464.png" alt="image-20221124091535464" style="zoom:50%;"><h3 id="坐标"><a href="#坐标" class="headerlink" title="坐标"></a>坐标</h3><ul><li><p>什么是坐标</p><p>Maven中的坐标用于描述仓库中资源的位置</p><p><a href="https://repo1.maven.org/maven2/">https://repo1.maven.org/maven2/</a></p></li><li><p>Maven坐标主要组成</p><p>groupld：定义当Maven项目隶属组织名称(通常是域名反写，例如：org.mybatis)</p><p>artifactld：定义当前Maven项目名称(通常是模块名称，例如CMR,SMS)</p><p>version：定义当前项目版本号</p><p>packaging：定义该项目的打包方式</p></li><li><p>Maven坐标的作用</p><p>使用唯一标识，唯一性定位资源位置，通过该标识可以让资源的识别和下载交给电脑完成</p></li></ul><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><h3 id="依赖配置"><a href="#依赖配置" class="headerlink" title="依赖配置"></a>依赖配置</h3><ul><li>依赖指当前项目运行所需的jar，一个项目可以设置多个依赖</li><li>格式：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--设置当前工程所有的依赖--&gt;</span><br><span class="line">  &lt;dependencies&gt;</span><br><span class="line">    &lt;!--具体的依赖--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;!--依赖所属群组id--&gt;</span><br><span class="line">      &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">      &lt;!--依赖所属项目id--&gt;</span><br><span class="line">      &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">      &lt;!--依赖版本号--&gt;</span><br><span class="line">      &lt;version&gt;<span class="number">4.12</span>&lt;/version&gt;</span><br><span class="line">      &lt;!--应用范围，默认再test内生效，注释掉--&gt;</span><br><span class="line">      &lt;!--&lt;scope&gt;test&lt;/scope&gt;--&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">  &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h3 id="依赖传递"><a href="#依赖传递" class="headerlink" title="依赖传递"></a>依赖传递</h3><ul><li>依赖具有传递性<ul><li>直接依赖：在当前项目中通过依赖配置建立的依赖关系</li><li>间接依赖：被依赖的资源如果依赖其他资源，当前项目间接依赖其他资源</li></ul></li></ul><img src="/2022/11/24/maven%E5%9F%BA%E7%A1%80/maven01/image-20221124093242780.png" alt="image-20221124093242780" style="zoom:50%;"><h3 id="依赖传递冲突问题"><a href="#依赖传递冲突问题" class="headerlink" title="依赖传递冲突问题"></a>依赖传递冲突问题</h3><ul><li>路径优先：当依赖中出现相同的资源时，层级越深，优先级越低，层级越浅，优先级越高</li><li>声明优先：当资源在相同层级被依赖时，配置顺序靠前的覆盖配置顺序靠后的</li><li>特殊优先：当同级配置了相同资源的不同版本，后配置的覆盖先配置的</li></ul><img src="/2022/11/24/maven%E5%9F%BA%E7%A1%80/maven01/image-20221124102412537.png" alt="image-20221124102412537" style="zoom:50%;"><h3 id="可选依赖"><a href="#可选依赖" class="headerlink" title="可选依赖"></a>可选依赖</h3><ul><li>可选依赖指对外隐藏当前所依赖的资源–不透明</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;<span class="number">4.11</span>&lt;/version&gt;</span><br><span class="line">      &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">  &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h3 id="排除依赖"><a href="#排除依赖" class="headerlink" title="排除依赖"></a>排除依赖</h3><ul><li>排除依赖指主动断开依赖的资源，被排除的资源无需指定版本–不需要</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;<span class="number">4.11</span>&lt;/version&gt;</span><br><span class="line">      &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">          &lt;groupId&gt;com.itheima&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;java02&lt;/artifactId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">      &lt;/exclusions&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">  &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h3 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h3><ul><li><p>依赖的jar默认情况可以在任何地方使用，可以通过scope标签规定作用范围</p></li><li><p>作用范围</p><ul><li>主程序范围有效(main文件夹范围内)</li><li>测试程序范围有效(test文件夹范围内)</li><li>是否参与打包(package指令)</li></ul><img src="/2022/11/24/maven%E5%9F%BA%E7%A1%80/maven01/image-20221124110738281.png" alt="image-20221124110738281" style="zoom:50%;"></li></ul><h3 id="依赖范围传递性"><a href="#依赖范围传递性" class="headerlink" title="依赖范围传递性"></a>依赖范围传递性</h3><ul><li>带有依赖范围的资源进行传递时，作用范围收到影响</li></ul><img src="/2022/11/24/maven%E5%9F%BA%E7%A1%80/maven01/image-20221124110842789.png" alt="image-20221124110842789" style="zoom:50%;"><h2 id="生命周期与插件"><a href="#生命周期与插件" class="headerlink" title="生命周期与插件"></a>生命周期与插件</h2><h3 id="项目构建生命周期"><a href="#项目构建生命周期" class="headerlink" title="项目构建生命周期"></a>项目构建生命周期</h3><ul><li>Maven构建生命周期描述的是一次构建过程经历了多少个事件</li></ul><p><img src="/2022/11/24/maven%E5%9F%BA%E7%A1%80/maven01/image-20221124123036129.png" alt="image-20221124123036129"></p><ul><li>Maven对项目构建的生命周期划分为3套<ul><li>clean：清理工作</li><li>default：核心工作，例如编译，测试，打包，部署等</li><li>site：产生报告，发布站点等</li></ul></li></ul><h4 id="clean生命周期"><a href="#clean生命周期" class="headerlink" title="clean生命周期"></a>clean生命周期</h4><ul><li>pre-clean     执行一些需要在clean之前完成的工作</li><li>clean             移除所有上一次构建生成的文件</li><li>post-clean    执行一些需要在clean之后立刻完成的工作</li></ul><h4 id="default构建生命周期"><a href="#default构建生命周期" class="headerlink" title="default构建生命周期"></a>default构建生命周期</h4><img src="/2022/11/24/maven%E5%9F%BA%E7%A1%80/maven01/image-20221124124753776.png" alt="image-20221124124753776" style="zoom: 200%;"><h4 id="site构建生命周期"><a href="#site构建生命周期" class="headerlink" title="site构建生命周期"></a>site构建生命周期</h4><ul><li>pre-site        执行一些需要在生成站点文档之前完成的工作</li><li>site                生成项目的站点文档</li><li>post-site       执行一些需要在站点文档之后完成的工作，并且为部署做准备</li><li>site-deploy   将生成的站点文档部署到特定的服务器上</li></ul><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><ul><li>插件与生命周期内的阶段绑定，在执行到对应生命周期时执行对应插件的功能</li><li>默认maven在各个生命周期上绑定有预设功能</li><li>通过插件可以自定义其他功能</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">       &lt;plugins&gt;</span><br><span class="line">           &lt;plugin&gt;</span><br><span class="line">               &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">               &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">               &lt;version&gt;<span class="number">4.13</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">               &lt;executions&gt;</span><br><span class="line">                   &lt;execution&gt;</span><br><span class="line">                       &lt;goals&gt;</span><br><span class="line">                           &lt;goal&gt;jar&lt;/goal&gt;</span><br><span class="line">                       &lt;/goals&gt;</span><br><span class="line">                       &lt;phase&gt;generate-test-resources&lt;/phase&gt;</span><br><span class="line">                   &lt;/execution&gt;</span><br><span class="line">               &lt;/executions&gt;</span><br><span class="line">           &lt;/plugin&gt;</span><br><span class="line">       &lt;/plugins&gt;</span><br><span class="line">   &lt;/build&gt;</span><br></pre></td></tr></table></figure><img src="/2022/11/24/maven%E5%9F%BA%E7%A1%80/maven01/image-20221124130235993.png" alt="image-20221124130235993" style="zoom:50%;">]]></content>
      
      
      <categories>
          
          <category> maven </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二叉树</title>
      <link href="/2022/11/18/%E6%A0%91/"/>
      <url>/2022/11/18/%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="树结构的引入"><a href="#树结构的引入" class="headerlink" title="树结构的引入"></a>树结构的引入</h2><p>树：高效的查找与搜索语义</p><h2 id="关于树的基础概念"><a href="#关于树的基础概念" class="headerlink" title="关于树的基础概念"></a>关于树的基础概念</h2><p>树是一种非线性的数据结构，是由n个有限结点组成的一个具有层次关系的集合</p><h3 id="树的特点"><a href="#树的特点" class="headerlink" title="树的特点"></a>树的特点</h3><ol><li><p>子树不相交</p></li><li><p>除了根结点没有父结点之外，每个结点有且只有一个父结点</p></li><li><p>树，边的个数x以及结点的个数n之间的关系：x &#x3D; n - 1(每个结点都有与父结点相连的点，而根结点没有)</p></li><li><p>结点和树的度：</p><p>结点的度：该结点中包含的子树个数称为该结点的度</p><p>树的度：树中最大的结点的度成为树的度</p></li><li><p>叶子结点：度为0的结点</p><p>非叶子结点：度不为0的结点，说明还存在子树</p></li><li><p>根节点：没有父结点的结点，树中有且只有一个根节点</p></li><li><p>结点的层次：从根节点开始计算，根节点为第一层</p><p>树的高度：当前树中结点层次最大的即为树的高度</p></li></ol><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>树中结点最大的度为2的树称之为二叉树</p><p>二叉树中，一个结点最多有两颗子树，二叉树结点的度小于等于2</p><p>且子树有左右之分，左右的顺序不能颠倒</p><h3 id="二叉树常考的性质"><a href="#二叉树常考的性质" class="headerlink" title="二叉树常考的性质"></a>二叉树常考的性质</h3><ol><li><p>在深度为k的二叉树中，最多存在2^k - 1个结点</p></li><li><p>在第k层，该层最多有2^(k-1)个结点</p></li><li><p>由于任意二叉树都满足结点个数n和边长具备x &#x3D; n - 1</p><p>在二叉树中，度为2的结点和度为0的结点有以下关系：n0 &#x3D; n2 + 1</p><p>度为0度结点个数永远比度为2的结点个数多一个</p></li></ol><h4 id="二叉树中第三种性质的推导"><a href="#二叉树中第三种性质的推导" class="headerlink" title="二叉树中第三种性质的推导"></a>二叉树中第三种性质的推导</h4><p>二叉树中只有三种结点：n0 , n1 , n2</p><p>n0 + n1 +n2 &#x3D; n(三种结点的个数相加就是结点的总个数)</p><p>n1 + 2n2 &#x3D; n - 1(n1 有一条边，n2 有两条边，相加后总共有n - 1条边)</p><p>两个式子化简得到：n0 &#x3D; n2 +1</p><h2 id="常见二叉树"><a href="#常见二叉树" class="headerlink" title="常见二叉树"></a>常见二叉树</h2><p><strong>满二叉树：</strong>在该二叉树中，每一层的结点个数都是最大值</p><p><strong>完全二叉树：</strong>完全二叉树的结点编号和满二叉树完全一致，一一对应</p><p>满二叉树就是一个特殊的完全二叉树</p><p>在完全二叉树中不存在只有右子树而没有左子树的结点</p><p>也就是说，如果存在度为1的结点，这个结点必然只有左树没有右树的结点，这样的结点有且只有一个</p><h3 id="关于完全二叉树的编号"><a href="#关于完全二叉树的编号" class="headerlink" title="关于完全二叉树的编号"></a>关于完全二叉树的编号</h3><ol><li>若根节点从1开始编号，若任意一个结点x，即存在子树也有父节点，则该结点的父结点编号为x&#x2F;2，其左子树编号为2x，右子树编号为2x + 1</li><li>若根节点从0开始编号(“堆”就是基于数组实现的完全二叉树)：则在完全二叉树中，若任意结点既有子树也有父结点，该结点编号为x，则父结点的编号为(x - 1) &#x2F; 2，左子树的结点编号为2x + 1，右子树的结点编号为2x + 2</li></ol><h3 id="二分搜索树-BST"><a href="#二分搜索树-BST" class="headerlink" title="二分搜索树(BST)"></a>二分搜索树(BST)</h3><p>结点的值之间有一个大小关系：左子树结点值 &lt; 根结点值 &lt; 右子树结点值</p><img src="/2022/11/18/%E6%A0%91/树/image-20221122234932426.png" alt="image-20221122234932426" style="zoom:50%;"><p>若在BST中查找一个元素，其实就是二分查找</p><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>该树中任意一个结点的**左右子树高度差 **&lt;&#x3D; 1  最多多出一层</p><p>注意是所有结点都要满足，仅仅是根结点的子树满足情况是不够的，因为子树的子树可能不平衡</p><p>平衡二叉树书详解：<a href="http://t.csdn.cn/j6j2o">http://t.csdn.cn/j6j2o</a></p><h2 id="二叉树的实现"><a href="#二叉树的实现" class="headerlink" title="二叉树的实现"></a>二叉树的实现</h2><p>树节点：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;E&gt; &#123;</span><br><span class="line">    E val;</span><br><span class="line">    TreeNode&lt;E&gt; left;</span><br><span class="line">    TreeNode&lt;E&gt; right;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">(E val)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.val =val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二叉树的手工构建：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">()</span>&#123;</span><br><span class="line">    TreeNode&lt;Character&gt; node = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;&gt;(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    TreeNode&lt;Character&gt; node1 = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;&gt;(<span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">    TreeNode&lt;Character&gt; node2 = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;&gt;(<span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">    TreeNode&lt;Character&gt; node3 = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;&gt;(<span class="string">&#x27;D&#x27;</span>);</span><br><span class="line">    TreeNode&lt;Character&gt; node4 = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;&gt;(<span class="string">&#x27;E&#x27;</span>);</span><br><span class="line">    TreeNode&lt;Character&gt; node5 = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;&gt;(<span class="string">&#x27;F&#x27;</span>);</span><br><span class="line">    TreeNode&lt;Character&gt; node6 = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;&gt;(<span class="string">&#x27;G&#x27;</span>);</span><br><span class="line">    TreeNode&lt;Character&gt; node7 = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;&gt;(<span class="string">&#x27;H&#x27;</span>);</span><br><span class="line">    node.left = node1;</span><br><span class="line">    node.right = node2;</span><br><span class="line">    node1.left = node3;</span><br><span class="line">    node1.right = node4;</span><br><span class="line">    node4.left = node6;</span><br><span class="line">    node6.right = node7;</span><br><span class="line">    node2.right = node5;</span><br><span class="line">    root = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的基本操作"><a href="#二叉树的基本操作" class="headerlink" title="二叉树的基本操作"></a>二叉树的基本操作</h2><p>二叉树的基本操作，或者说二叉树的所有问题的解决思路都是遍历的衍生</p><p>遍历是二叉树问题中的关键</p><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>二叉树的遍历分为四种遍历方式：</p><ul><li>前序遍历</li><li>中序遍历</li><li>后序遍历</li><li>层序遍历</li></ul><p>前三种称为深度优先遍历(DFS),最后一种称为广度优先遍历(BFS)</p><p>深度优先遍历借助栈实现，广度优先遍历借助队列实现</p><p>二叉树图例</p><img src="/2022/11/18/%E6%A0%91/树/image-20221123083320118.png" alt="image-20221123083320118" style="zoom: 50%;"><h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><p>先访问根结点，然后递归访问左子树，再递归访问右子树(根左右)</p><p>上图的遍历结果为：A B D E G H C F</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传入根结点，就能按照前序遍历的方式输出 - 根左右</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    preOrder(root.left);</span><br><span class="line">    preOrder(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>先递归的访问左子树，然后访问根结点，最后访问右子树(左根右)</p><p>当根结点第二次走到时才能访问</p><p>上图遍历结果为：D B E G H A C F</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传入根结点，就能按照中序遍历的方式输出 - 左根右</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inOrder(root.left);</span><br><span class="line">    System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    inOrder(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>先递归访问左子树，再递归访问右子树，最后访问根结点(左右根)</p><p>上图遍历结果为：D H G E B F C A</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">POstOrder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(roof == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PostOrder(root.left);</span><br><span class="line">    POstOrder(root.right);</span><br><span class="line">    System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h4><p>将二叉树一层一层遍历，从上往下，从左往右</p><p>上图遍历结果为：A B C D E F G H</p><p>层序遍历需要借助递归函数和队列来实现</p><h2 id="二叉树基本题"><a href="#二叉树基本题" class="headerlink" title="二叉树基本题"></a>二叉树基本题</h2><h3 id="求结点个数"><a href="#求结点个数" class="headerlink" title="求结点个数"></a>求结点个数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNodes</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//如果根结点不为空，那么返回自身加上左子树的结点个数和右子树的结点个数之和</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + getNodes(root.left) + getNodes(root.right);</span><br><span class="line">    <span class="comment">//可以简化为一句话</span></span><br><span class="line">    <span class="comment">//return root == null ? 0 : 1 + getNodes(root.left) + getNodes(root.right);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求叶子结点个数"><a href="#求叶子结点个数" class="headerlink" title="求叶子结点个数"></a>求叶子结点个数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLeafNode</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getLeafNode(root.left) + getLeafNode(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求第K层结点个数"><a href="#求第K层结点个数" class="headerlink" title="求第K层结点个数"></a>求第K层结点个数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getKLevelNodes</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k &lt; <span class="number">1</span> || root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//当k为1时，说明只有根结点这一层，因此直接返回1即可</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此时k不为1，就继续找下一层</span></span><br><span class="line">    <span class="keyword">return</span> getKLevelNodes(root.left, k - <span class="number">1</span>) + getKLevelNodes(root.right, k - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求二叉树高度"><a href="#求二叉树高度" class="headerlink" title="求二叉树高度"></a>求二叉树高度</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">height</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//树的高度 = 当前层 + 子树中的高度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + Math.max(height(root.left), height(root.right));</span><br><span class="line">    <span class="comment">//最底层有么是左子树要么是右子树要么一样高，取最大值加一就是高度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断二叉树中是否包含值val"><a href="#判断二叉树中是否包含值val" class="headerlink" title="判断二叉树中是否包含值val"></a>判断二叉树中是否包含值val</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(TreeNode&lt;E&gt; root, E val)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.val == val)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> contains(root.left, val) || contains(root.right, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​                                                                                                                                            </p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js003</title>
      <link href="/2022/11/09/js003/"/>
      <url>/2022/11/09/js003/</url>
      
        <content type="html"><![CDATA[<h1 id="javascript基础"><a href="#javascript基础" class="headerlink" title="javascript基础"></a>javascript基础</h1>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>栈和队列</title>
      <link href="/2022/11/08/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
      <url>/2022/11/08/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="栈的基本概念"><a href="#栈的基本概念" class="headerlink" title="栈的基本概念"></a>栈的基本概念</h3><p><strong>栈的定义</strong></p><p>栈(Stack)：是只允许在一端进入插入或删除的线性表。<br>                首先栈是一种线性表，但这种线性表只能在某一端进行插入和删除操作。</p><p><strong>入栈(push)：</strong></p><img src="/2022/11/08/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/栈和队列/image-20221109190612786.png" alt="image-20221109190612786" style="zoom: 67%;"><p><strong>出栈(pop)：</strong></p><img src="/2022/11/08/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/栈和队列/image-20221109190638750.png" alt="image-20221109190638750" style="zoom:67%;"><p><strong>栈顶</strong>(Top)：线性表允许进入插入删除的那一端。<br><strong>栈底</strong>(Bottom)：固定的、不允许进入插入和删除的另一端。<br><strong>空栈</strong>：不含任何元素的空表。</p><p><strong>栈又称为后进先出（Last In First Out）的线性表，简称LIFO结构</strong></p><p>Java标准库中的提供的栈</p><img src="/2022/11/08/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/栈和队列/image-20221115151749078.png" alt="image-20221115151749078" style="zoom:80%;"><p>vector:动态的顺序表，和ArrayLIst类似 </p><h3 id="实现栈的方法"><a href="#实现栈的方法" class="headerlink" title="实现栈的方法"></a>实现栈的方法</h3><p><img src="/2022/11/08/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/image-20221109191132199.png" alt="image-20221109191132199"></p><table><thead><tr><th align="center">Stack()</th><th align="center">构造一个空的栈</th></tr></thead><tbody><tr><td align="center">E push(E e)</td><td align="center">将e入栈，并返回e</td></tr><tr><td align="center">E pop()</td><td align="center">将栈顶元素出栈并返回</td></tr><tr><td align="center">E peek()</td><td align="center">获取栈顶元素</td></tr><tr><td align="center">int size()</td><td align="center">获取栈中有效元素个数</td></tr><tr><td align="center">boolean empty()</td><td align="center">检测栈是否为空</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//入栈</span></span><br><span class="line">        stack.push(<span class="number">1</span>);</span><br><span class="line">        stack.push(<span class="number">2</span>);</span><br><span class="line">        stack.push(<span class="number">3</span>);</span><br><span class="line">        stack.push(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;栈中有效元素个数 : &quot;</span>+ stack.size()); <span class="comment">// 输出 4</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;获取栈顶元素 : &quot;</span>+stack.peek()); <span class="comment">// 获取栈顶元素,但是不出栈,栈中元素不变  4</span></span><br><span class="line"></span><br><span class="line">        stack.pop();   <span class="comment">// 出栈  元素 4 出栈 ,栈中剩余元素 3,2,1</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;获取栈顶元素 : &quot;</span> + stack.pop()); <span class="comment">// 获取栈顶元素,出栈, 此时栈中剩余 2,1两个元素</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;栈中有效元素个数 : &quot;</span>+ stack.size()); <span class="comment">// 输出 2</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;stack是否为空 : &quot;</span>+ stack.isEmpty()); <span class="comment">// 判断栈中是否为空</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="模拟实现一个栈"><a href="#模拟实现一个栈" class="headerlink" title="模拟实现一个栈"></a>模拟实现一个栈</h3><p>栈是一个特殊的顺序表，所以采用链表和数组的方式都可以实现，一般采用数组的方式</p><h4 id="构造方式"><a href="#构造方式" class="headerlink" title="构造方式"></a>构造方式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// size 记录栈中元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 调用无参构造方法 默认最大容量12</span></span><br><span class="line">        <span class="built_in">this</span>(<span class="number">12</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">(<span class="type">int</span> MaxSize)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.arr = <span class="keyword">new</span> <span class="title class_">int</span>[MaxSize];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="入栈-push"><a href="#入栈-push" class="headerlink" title="入栈(push)"></a>入栈(push)</h4><p>入栈时判断栈是否已满，如果满了，给数组扩容</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 入栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.size == arr.length)&#123;</span><br><span class="line">            <span class="comment">// 栈满 ,需要扩容</span></span><br><span class="line"></span><br><span class="line">            <span class="type">int</span>[] copyArr;</span><br><span class="line">            <span class="comment">// 复制arr 数组并扩容一倍</span></span><br><span class="line">            copyArr = Arrays.copyOf(arr,<span class="number">2</span> * arr.length);</span><br><span class="line">            arr = copyArr;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将元素添加到size位置</span></span><br><span class="line">        <span class="built_in">this</span>.arr[size] = value;</span><br><span class="line">        <span class="comment">// 元素个数加一</span></span><br><span class="line">        <span class="built_in">this</span>.size++;</span><br><span class="line">        <span class="comment">// 返回添加元素</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="出栈-pop"><a href="#出栈-pop" class="headerlink" title="出栈(pop)"></a>出栈(pop)</h4><p>出栈时，判断栈中元素是否为空，如果为空，抛出异常</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 出栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.size == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//没有元素</span></span><br><span class="line">            <span class="comment">//抛出运行时异常,此处也可以自定义异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;栈中没有元素,不能出栈....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获得栈顶元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="built_in">this</span>.arr[size - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// size - 1 之后, 下一次插入时会覆盖原数据,利用覆盖替代删除</span></span><br><span class="line">        <span class="built_in">this</span>.size--;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="获取栈顶元素-peek"><a href="#获取栈顶元素-peek" class="headerlink" title="获取栈顶元素(peek)"></a>获取栈顶元素(peek)</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取栈顶元素</span></span><br><span class="line">    public int <span class="title function_">peek</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">size</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//没有元素</span></span><br><span class="line">            <span class="comment">//抛出运行时异常,此处也可以自定义异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;栈中没有元素,不能出栈....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">arr</span>[<span class="variable language_">this</span>.<span class="property">size</span> - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="获取元素个数-get-size"><a href="#获取元素个数-get-size" class="headerlink" title="获取元素个数(get size)"></a>获取元素个数(get size)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取元素个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.size;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="判断栈是否为空-isEmpty"><a href="#判断栈是否为空-isEmpty" class="headerlink" title="判断栈是否为空(isEmpty)"></a>判断栈是否为空(isEmpty)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断元素是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStack</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// size 记录栈中元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 调用无参构造方法 默认最大容量12</span></span><br><span class="line">        <span class="built_in">this</span>(<span class="number">12</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">(<span class="type">int</span> MaxSize)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.arr = <span class="keyword">new</span> <span class="title class_">int</span>[MaxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.size == arr.length)&#123;</span><br><span class="line">            <span class="comment">// 栈满 ,需要扩容</span></span><br><span class="line"></span><br><span class="line">            <span class="type">int</span>[] copyArr;</span><br><span class="line">            <span class="comment">// 复制arr 数组并扩容一倍</span></span><br><span class="line">            copyArr = Arrays.copyOf(arr,<span class="number">2</span> * arr.length);</span><br><span class="line">            arr = copyArr;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将元素添加到size位置</span></span><br><span class="line">        <span class="built_in">this</span>.arr[size] = value;</span><br><span class="line">        <span class="comment">// 元素个数加一</span></span><br><span class="line">        <span class="built_in">this</span>.size++;</span><br><span class="line">        <span class="comment">// 返回添加元素</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="comment">//没有元素</span></span><br><span class="line">            <span class="comment">//抛出运行时异常,此处也可以自定义异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;栈中没有元素,不能出栈....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获得栈顶元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="built_in">this</span>.arr[size - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// size - 1 之后, 下一次插入时会覆盖原数据,利用覆盖替代删除</span></span><br><span class="line">        <span class="built_in">this</span>.size--;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取栈顶元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="comment">//没有元素</span></span><br><span class="line">            <span class="comment">//抛出运行时异常,此处也可以自定义异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;栈中没有元素,不能出栈....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.arr[<span class="built_in">this</span>.size - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取元素个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断元素是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h4 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h4><p>队列：只允许在一端进行插入数据操作，在另一端进行删除数据操作的特殊线性表，队列具有先进先出FIFO(First In First Out)                </p><p>入队列：进行插入操作的一端称为队尾(Tail&#x2F;Rear)<br>出队列：进行删除操作的一端称为对头(Head&#x2F;Front)</p><img src="/2022/11/08/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/栈和队列/image-20221115151536222.png" alt="image-20221115151536222" style="zoom:80%;"><h4 id="队列的使用"><a href="#队列的使用" class="headerlink" title="队列的使用"></a>队列的使用</h4><ol><li>java标准库中的队列</li></ol><img src="/2022/11/08/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/栈和队列/image-20221116153834743.png" alt="image-20221116153834743" style="zoom:80%;"><p>Queue是一个接口，需要通过实现这个接口的类来实例化对象，Linkedlist实现了Queue接口，可以通过Linkedlist实例化，如Queue<Integer> queue &#x3D; new Linkedlist&lt;&gt;();</Integer></p><p>2.实现的方法</p><p><img src="/2022/11/08/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/image-20221116154134433.png" alt="image-20221116154134433"></p><p>注意：Queue中，插入和删除操作都有2个方法可以实现，通常采用offer(E)添加元素和poll删除元素，而不使用add和remove方法</p><table><thead><tr><th align="center">方法</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">boolean offer(E e)</td><td align="center">入队列</td></tr><tr><td align="center">E poll( )</td><td align="center">出队列</td></tr><tr><td align="center">peek( )</td><td align="center">获取对头元素</td></tr><tr><td align="center">int size( )</td><td align="center">获取队列有效元素</td></tr><tr><td align="center">boolean isEmpty( )</td><td align="center">检测队列是否为空</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//插入元素</span></span><br><span class="line">        q.offer(<span class="number">1</span>);</span><br><span class="line">        q.offer(<span class="number">2</span>);</span><br><span class="line">        q.offer(<span class="number">3</span>);</span><br><span class="line">        q.offer(<span class="number">4</span>);</span><br><span class="line">        q.offer(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;元素个数 : &quot;</span>+q.size()); <span class="comment">// 获取元素个数 输出5</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;获取队头元素 : &quot;</span>+q.peek()); <span class="comment">// 获取队头元素,但不删除元素</span></span><br><span class="line">        q.poll();</span><br><span class="line">        System.out.println(<span class="string">&quot;出队列元素 : &quot;</span>+q.poll()); <span class="comment">// 从队头出队列，并将删除的元素返回</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(q.isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列空&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;元素个数 : &quot;</span>+q.size());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="/2022/11/08/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/image-20221116161252522.png" alt="image-20221116161252522"></p><h3 id="模拟实现一个队列"><a href="#模拟实现一个队列" class="headerlink" title="模拟实现一个队列"></a>模拟实现一个队列</h3><p>数组：入队列出队列都相对简单，但是可能会造成大量的空间浪费</p><p><img src="/2022/11/08/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/image-20221116232300654.png" alt="image-20221116232300654"></p><p>当head在3下标时,下标 &lt; 3 的位置无法在利用,上面的例子中,数组的大小为9,而最后队列中只有6个元素就已经无法插入新的元素,导致浪费大量的空间,而链表因为存储空间不连续,很好的避免了这一问题,出队列时就可以释放资源,解决了内存利用率低的问题.</p><p>出去的头元素会往后推，补上的元素会在后面添加，导致存储空间的浪费</p><p><img src="/2022/11/08/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/image-20221116232436227.png" alt="image-20221116232436227"></p><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>public class MyLinkedListQueue {</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 结点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Node head;</span><br><span class="line"><span class="keyword">public</span> Node last;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> useSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全部初始化为空</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MyLinkedListQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    head = <span class="literal">null</span>;</span><br><span class="line">    last = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="入队列-offer"><a href="#入队列-offer" class="headerlink" title="入队列(offer)"></a>入队列(offer)</h4><p>由于是链表，所以入队列时不需要考虑内存扩容问题，代码执行时，动态分配空间</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//入队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">offer</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line"><span class="comment">//构造一个结点</span></span><br><span class="line">       <span class="type">Node</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(val);</span><br><span class="line">       <span class="comment">//当head为空时,说明队列中没有元素,直接让新结点成为头尾结点</span></span><br><span class="line">       <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">           head = tmp;</span><br><span class="line">           last = tmp;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           tmp.next = head;</span><br><span class="line">           head = tmp;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//元素个数加1</span></span><br><span class="line">       useSize++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="出队列-poll"><a href="#出队列-poll" class="headerlink" title="出队列(poll)"></a>出队列(poll)</h4><p>出队列时需要判断队列是否为空</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//如果队列为空,抛出异常</span></span><br><span class="line">       <span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> head.val;</span><br><span class="line">       <span class="comment">// 让队头指向下一个结点</span></span><br><span class="line">       head = head.next;</span><br><span class="line">       <span class="comment">//如果head 为空了,说明开始只有一个元素,把last也置空</span></span><br><span class="line">       <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">           last = <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       useSize--;</span><br><span class="line">       <span class="keyword">return</span> val;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="获取队头元素-peek"><a href="#获取队头元素-peek" class="headerlink" title="获取队头元素(peek)"></a>获取队头元素(peek)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> head.val;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="获取元素个数-getSize"><a href="#获取元素个数-getSize" class="headerlink" title="获取元素个数(getSize)"></a>获取元素个数(getSize)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> useSize;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="判断队列是否为空-isEmpty"><a href="#判断队列是否为空-isEmpty" class="headerlink" title="判断队列是否为空(isEmpty)"></a>判断队列是否为空(isEmpty)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> useSize==<span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLinkedListQueue</span> &#123;</span><br><span class="line">    <span class="comment">// 结点</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> val;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node head;</span><br><span class="line">    <span class="keyword">public</span> Node last;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> useSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedListQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        head = <span class="literal">null</span>;</span><br><span class="line">        last = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">offer</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(val);</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">            head = tmp;</span><br><span class="line">            last = tmp;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            tmp.next = head;</span><br><span class="line">            head = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        useSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> head.val;</span><br><span class="line">        head = head.next;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">            last = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        useSize--;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> useSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> useSize==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="泛型实现"><a href="#泛型实现" class="headerlink" title="泛型实现"></a>泛型实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLinkedListQueue</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结点</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">public</span> T val;</span><br><span class="line">        <span class="keyword">public</span> Node&lt;T&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(T val)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node&lt;T&gt; head;</span><br><span class="line">    <span class="keyword">public</span> Node&lt;T&gt; last;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> useSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedListQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        head = <span class="literal">null</span>;</span><br><span class="line">        last = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">offer</span><span class="params">(T val)</span> &#123;</span><br><span class="line">        Node&lt;T&gt; tmp = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(val);</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">            head = tmp;</span><br><span class="line">            last = tmp;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            tmp.next = head;</span><br><span class="line">            head = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        useSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">T</span> <span class="variable">val</span> <span class="operator">=</span> head.val;</span><br><span class="line">        head = head.next;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">            last = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        useSize--;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> useSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> useSize==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现一个循环队列"><a href="#实现一个循环队列" class="headerlink" title="实现一个循环队列"></a>实现一个循环队列</h3><p>循环队列通常由数组数显，循环队列能解决数组造成的空间资源浪费的问题</p><p><img src="/2022/11/08/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/image-20221117160749324.png" alt="image-20221117160749324"></p><p>循环队列本质是一个数组</p><p><img src="/2022/11/08/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/image-20221117160843182.png" alt="image-20221117160843182"></p><p>当数组小下标有空闲位置时,head一旦&#x3D;&#x3D;数组长度就会循环从0开始,如上图,4,5,63个位置为空闲位置</p><h4 id="入队列"><a href="#入队列" class="headerlink" title="入队列"></a>入队列</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//入队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">offer</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size == elem.length)&#123;</span><br><span class="line">            <span class="comment">//可扩容,此处不实现</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列已满...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        elem[rear] = val;</span><br><span class="line">        <span class="comment">//如果rear到达数组长度,则置0</span></span><br><span class="line">        <span class="keyword">if</span>(rear + <span class="number">1</span> &gt;= elem.length)&#123;</span><br><span class="line">            rear = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            rear++;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="出队列"><a href="#出队列" class="headerlink" title="出队列"></a>出队列</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">poll</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列为空...&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> elem[front];</span><br><span class="line">       <span class="keyword">if</span>(front + <span class="number">1</span> &gt;= elem.length)&#123;</span><br><span class="line">           front = <span class="number">0</span>;</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           front++;</span><br><span class="line">       &#125;</span><br><span class="line">       size--;</span><br><span class="line">       <span class="keyword">return</span> val;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="获取队首元素"><a href="#获取队首元素" class="headerlink" title="获取队首元素"></a>获取队首元素</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取队首元素</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列为空...&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> elem[front];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="获取队列中元素个数"><a href="#获取队列中元素个数" class="headerlink" title="获取队列中元素个数"></a>获取队列中元素个数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断元素个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="判断队列是否为空"><a href="#判断队列是否为空" class="headerlink" title="判断队列是否为空"></a>判断队列是否为空</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">size</span> <span class="operator">=</span>= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="完整代码-2"><a href="#完整代码-2" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCircularQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span>[] elem;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> front;      <span class="comment">//队头下标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rear;       <span class="comment">//队尾下标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyCircularQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        elem = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">24</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">offer</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size == elem.length)&#123;</span><br><span class="line">            <span class="comment">//可扩容,此处不实现</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列已满...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        elem[rear] = val;</span><br><span class="line">        <span class="comment">//如果rear到达数组长度,则置0</span></span><br><span class="line">        <span class="keyword">if</span>(rear + <span class="number">1</span> &gt;= elem.length)&#123;</span><br><span class="line">            rear = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            rear++;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">poll</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列为空...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> elem[front];</span><br><span class="line">        <span class="keyword">if</span>(front + <span class="number">1</span> &gt;= elem.length)&#123;</span><br><span class="line">            front = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            front++;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断元素个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取队首元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列为空...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> elem[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">size</span> <span class="operator">=</span>= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><h3 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h3><p>给定一个只包括 ‘(’，‘)’，‘{’，‘}’，‘[’，‘]’ 的字符串 s ，判断字符串是否有效。<br>有效字符串需满足：</p><blockquote><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。</p></blockquote><p><strong>样例1：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: s = <span class="string">&quot;()&quot;</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>样例2：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: s = <span class="string">&quot;([)]&quot;</span></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure><ul><li>如果传入字符串长度为奇数，直接返回false</li><li>如果第一个元素为右括号，则直接false</li><li>当连续两个元素为不同类型的左右括号，无法再正确完成匹配，返回false，如”((]”</li><li>遍历完成字符串时，还需判断栈中元素是否为空，若不为空，返回false</li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建一个栈,</span></span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环遍历每一个字符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="comment">//如果下一个字符为反括号,进入判断</span></span><br><span class="line">            <span class="keyword">if</span>((ch == <span class="string">&#x27;)&#x27;</span> || ch == <span class="string">&#x27;]&#x27;</span> || ch == <span class="string">&#x27;&#125;&#x27;</span>))&#123;</span><br><span class="line">                <span class="comment">//如果 此时栈中没有元素,反括号在第一个位置,不可能再匹配,返回false</span></span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty())&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">                <span class="comment">//如果前一个元素为对应左括号,则出栈</span></span><br><span class="line">                <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span> &amp;&amp; ch == <span class="string">&#x27;)&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span> &amp;&amp; ch == <span class="string">&#x27;]&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span> &amp;&amp; ch == <span class="string">&#x27;&#125;&#x27;</span>) &#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 否则会出现两种括号交叉出现,无法正确匹配,返回false</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">//如果下一个字符为左括号,入栈</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历完成之后判断栈中元素是否为空,如果为空,说明有多余的括号没有匹配完,返回false</span></span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="逆波兰表达式求值"><a href="#逆波兰表达式求值" class="headerlink" title="逆波兰表达式求值"></a>逆波兰表达式求值</h3><p>根据 逆波兰表示法，求表达式的值。<br>有效的算符包括 +、-、*、&#x2F; 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。<br>注意 两个整数之间的除法只保留整数部分。<br>可以保证给定的逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</p><p><strong>样例1:</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入： tokens = &#123;<span class="string">&quot;2&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;+&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;*&quot;</span>&#125;</span><br><span class="line">输出： <span class="number">9</span></span><br><span class="line">解释：该算式转换为常见的中级算术表达式为：((<span class="number">2</span>+<span class="number">1</span>)*<span class="number">3</span>)=<span class="number">9</span></span><br></pre></td></tr></table></figure><p><strong>样例2：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：tokens = [<span class="string">&quot;10&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;9&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;+&quot;</span>,<span class="string">&quot;-11&quot;</span>,<span class="string">&quot;*&quot;</span>,<span class="string">&quot;/&quot;</span>,<span class="string">&quot;*&quot;</span>,<span class="string">&quot;17&quot;</span>,<span class="string">&quot;+&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;+&quot;</span>]</span><br><span class="line">输出：<span class="number">22</span></span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：</span><br><span class="line">  ((<span class="number">10</span> * (<span class="number">6</span> / ((<span class="number">9</span> + <span class="number">3</span>) * -<span class="number">11</span>))) + <span class="number">17</span>) + <span class="number">5</span></span><br><span class="line">= ((<span class="number">10</span> * (<span class="number">6</span> / (<span class="number">12</span> * -<span class="number">11</span>))) + <span class="number">17</span>) + <span class="number">5</span></span><br><span class="line">= ((<span class="number">10</span> * (<span class="number">6</span> / -<span class="number">132</span>)) + <span class="number">17</span>) + <span class="number">5</span></span><br><span class="line">= ((<span class="number">10</span> * <span class="number">0</span>) + <span class="number">17</span>) + <span class="number">5</span></span><br><span class="line">= (<span class="number">0</span> + <span class="number">17</span>) + <span class="number">5</span></span><br><span class="line">= <span class="number">17</span> + <span class="number">5</span></span><br><span class="line">= <span class="number">22</span></span><br></pre></td></tr></table></figure><ul><li>逆波兰表达式遵循从左到右的运算,所以采用栈来计算</li><li>如果遇到数字,将数字入栈</li><li><strong>如果遇到运算符,将栈内出栈2个元素,通过运算符计算后,将计算结果放入栈中.</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个栈</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 遍历每一个字符串</span></span><br><span class="line">        <span class="keyword">for</span> (String token : tokens) &#123;</span><br><span class="line">            <span class="comment">//判断是否为数字,如果是,加入栈中,如果不是,取出2个元素计算后重新加入栈中</span></span><br><span class="line">            <span class="keyword">if</span> (token.equals(<span class="string">&quot;+&quot;</span>) || token.equals(<span class="string">&quot;-&quot;</span>) || token.equals(<span class="string">&quot;*&quot;</span>) || token.equals(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">pop1</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">pop2</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="keyword">switch</span> (token) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                        stack.push(pop2 + pop1);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                        stack.push(pop2 - pop1);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                        stack.push(pop2 * pop1);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                        stack.push(pop2 / pop1);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(Integer.parseInt(token));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算完毕后,剩下一个元素,即为结果</span></span><br><span class="line">        <span class="keyword">return</span> stack.pop();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="出栈入栈次序匹配"><a href="#出栈入栈次序匹配" class="headerlink" title="出栈入栈次序匹配"></a>出栈入栈次序匹配</h3><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。</p><ol><li>0&lt;&#x3D;pushV.length &#x3D;&#x3D; popV.length &lt;&#x3D;1000</li><li>-1000&lt;&#x3D;pushV[i]&lt;&#x3D;1000</li><li>pushV 的所有数字均不相同</li></ol><p><strong>样例1：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">返回值：<span class="literal">true</span></span><br><span class="line">说明：可以通过push(<span class="number">1</span>)=&gt;push(<span class="number">2</span>)=&gt;push(<span class="number">3</span>)=&gt;push(<span class="number">4</span>)=&gt;pop()=&gt;push(<span class="number">5</span>)=</span><br><span class="line">&gt;pop()=&gt;pop()=&gt;pop()=&gt;pop()</span><br><span class="line">这样的顺序得到[<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]这个序列，返回<span class="literal">true</span>    </span><br></pre></td></tr></table></figure><p><strong>样例2：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">返回值：<span class="literal">false</span></span><br><span class="line">说明：</span><br><span class="line">由于是[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]的压入顺序，[<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>]的弹出顺序，</span><br><span class="line">要求<span class="number">4</span>，<span class="number">3</span>，<span class="number">5</span>必须在<span class="number">1</span>，<span class="number">2</span>前压入，且<span class="number">1</span>，<span class="number">2</span>不能弹出，但是这样压入的顺序，</span><br><span class="line"><span class="number">1</span>又不能在<span class="number">2</span>之前弹出，所以无法形成的，返回<span class="literal">false</span>  </span><br></pre></td></tr></table></figure><p>创建一个辅助栈,和i,j两下标分别记录入栈与出栈序列<br>遍历 入栈数组<br>如果 入栈元素与出栈元素不相等,将入栈元素加入栈中<br>如果 入栈元素与出栈元素相等,出栈下标往后移<br>通过循环,判断栈顶元素与出栈数组是否相等,如果相等,辅助栈出栈,出栈下标加一,如果辅助栈类为空,结束循环<br>如果全部出栈,出栈下标因该等于出栈数组长度</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">IsPopOrder</span><span class="params">(<span class="type">int</span>[] pushA, <span class="type">int</span>[] popA)</span> &#123;</span><br><span class="line">       Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">       <span class="comment">//记录popA下标</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//遍历 入栈数组</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pushA.length; i++) &#123;</span><br><span class="line">           <span class="comment">//如果 入栈元素与出栈元素不相等,将入栈元素加入栈中</span></span><br><span class="line">           <span class="keyword">if</span> (pushA[i] != popA[j]) &#123;</span><br><span class="line">               stack.push(pushA[i]);</span><br><span class="line">           <span class="comment">//如果 入栈元素与出栈元素相等,出栈下标加一    </span></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               j++;</span><br><span class="line">               <span class="comment">//通过循环,判断栈顶元素与出栈数组是否相等,如果相等,辅助栈出栈,出栈下标加一</span></span><br><span class="line">               <span class="comment">//如果辅助栈类为空,结束循环</span></span><br><span class="line">               <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() == popA[j])&#123;</span><br><span class="line">                   stack.pop();</span><br><span class="line">                   j++;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 如果全部出栈,出栈下标因该等于出栈数组长度</span></span><br><span class="line">       <span class="type">return</span> <span class="variable">j</span> <span class="operator">=</span>= popA.length;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="实现一个最小栈"><a href="#实现一个最小栈" class="headerlink" title="实现一个最小栈"></a>实现一个最小栈</h3><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。<br>实现 MinStack 类:</p><p>MinStack() 初始化堆栈对象。<br>void push(int val) 将元素val推入堆栈。<br>void pop() 删除堆栈顶部的元素。<br>int top() 获取堆栈顶部的元素。<br>int getMin() 获取堆栈中的最小元素。</p><p>实例1：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">&quot;MinStack&quot;</span>,<span class="string">&quot;push&quot;</span>,<span class="string">&quot;push&quot;</span>,<span class="string">&quot;push&quot;</span>,<span class="string">&quot;getMin&quot;</span>,<span class="string">&quot;pop&quot;</span>,<span class="string">&quot;top&quot;</span>,<span class="string">&quot;getMin&quot;</span>]</span><br><span class="line">[[],[-<span class="number">2</span>],[<span class="number">0</span>],[-<span class="number">3</span>],[],[],[],[]]</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,-<span class="number">3</span>,<span class="literal">null</span>,<span class="number">0</span>,-<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line"><span class="type">MinStack</span> <span class="variable">minStack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MinStack</span>();</span><br><span class="line">minStack.push(-<span class="number">2</span>);</span><br><span class="line">minStack.push(<span class="number">0</span>);</span><br><span class="line">minStack.push(-<span class="number">3</span>);</span><br><span class="line">minStack.getMin();   --&gt; 返回 -<span class="number">3.</span></span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 <span class="number">0.</span></span><br><span class="line">minStack.getMin();   --&gt; 返回 -<span class="number">2.</span></span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br></pre></td></tr></table></figure><ul><li>当一个元素要入栈时，取当前最小栈的栈顶存储的最小值，与当前元素比较得出最小值，将这个最小值插入最小栈中</li><li>出栈时，把最小栈的栈顶元素也一并弹出</li><li>所以在任意一个时刻，栈内元素的最小值就存储在最小栈的栈顶元素中</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">       Stack&lt;Integer&gt; stack;</span><br><span class="line">       <span class="comment">//维护一个最小栈</span></span><br><span class="line">       Stack&lt;Integer&gt; minStack;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">           stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">           minStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">           minStack.push(Integer.MAX_VALUE);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">           stack.push(x);</span><br><span class="line">           <span class="comment">//将最小值加入最小栈中</span></span><br><span class="line">           minStack.push(Math.min(minStack.peek(), x));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">           stack.pop();</span><br><span class="line">           minStack.pop();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> stack.peek();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> minStack.peek();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>java005</title>
      <link href="/2022/11/03/java005/"/>
      <url>/2022/11/03/java005/</url>
      
        <content type="html"><![CDATA[<h1 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h1><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="方法概念"><a href="#方法概念" class="headerlink" title="方法概念"></a>方法概念</h4><p>方法(method)是程序中最小的执行单元</p><p>​    注意：方法必须创建才可以使用，该过程为<strong>方法定义</strong></p><p>​                方法创建后并不是直接可以运行的，需要手动使用后，才执行，该过程为<strong>方法调用</strong></p><h3 id="方法的定义和调用"><a href="#方法的定义和调用" class="headerlink" title="方法的定义和调用"></a>方法的定义和调用</h3><h4 id="无参数方法定义和调用"><a href="#无参数方法定义和调用" class="headerlink" title="无参数方法定义和调用"></a>无参数方法定义和调用</h4><p>定义格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> 方法名( )&#123;</span><br><span class="line"><span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>范例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">( )</span>&#123;</span><br><span class="line"><span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法名( )</span><br></pre></td></tr></table></figure><p>范例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">method( )</span><br></pre></td></tr></table></figure><p>注意：方法必须先定义，后调用</p><h4 id="无参数方法的练习"><a href="#无参数方法的练习" class="headerlink" title="无参数方法的练习"></a>无参数方法的练习</h4><ul><li><p>需求：设计一个方法用于打印两个数中的较大数</p></li><li><p>思路：</p><p>①定义一个方法，用于打印两个数字中的较大数，例如getMax()</p><p>②方法中定义两个变量，用于保存两个数字</p><p>③使用分支语句分两种情况对两个数字的大小关系进行处理</p><p>④在main()方法中调用定义好的方法</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//在main()方法中调用定义好的方法</span></span><br><span class="line">        getMax();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个方法，用于打印两个数字中的较大数，例如getMax()</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getMax</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//方法中定义两个变量，用于保存两个数字</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用分支语句分两种情况对两个数字的大小关系进行处理</span></span><br><span class="line">        <span class="keyword">if</span>(a &gt; b) &#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="带参数方法定义和调用"><a href="#带参数方法定义和调用" class="headerlink" title="带参数方法定义和调用"></a>带参数方法定义和调用</h3><p>定义格式：</p><p>参数：由数据类型和变量名组成-数据类型 变量名</p><p>参数范例：int a</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> 方法名(参数<span class="number">1</span>)&#123;</span><br><span class="line">方法体;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> 方法名(参数<span class="number">1</span>，参数<span class="number">2</span>，参数<span class="number">3.</span>..)&#123;</span><br><span class="line">方法体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>范例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">isEvenNumber</span><span class="params">(<span class="type">int</span> number)</span>&#123;</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getMax</span><span class="params">(<span class="type">int</span> num1,<span class="type">int</span> num2)</span>&#123;</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意</p><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>js002</title>
      <link href="/2022/11/01/js002/"/>
      <url>/2022/11/01/js002/</url>
      
        <content type="html"><![CDATA[<h1 id="javascript基础"><a href="#javascript基础" class="headerlink" title="javascript基础"></a>javascript基础</h1><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>逻辑与  &amp;&amp;  and  两侧都是true  结果才是true  只要有一侧为false 结果就为false</p><p>逻辑或  ||  or  两侧有一个是true  结果就是true  两侧都为false 结果才是false</p><p>逻辑非  !  not</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">console.log(<span class="number">3</span> &gt; <span class="number">5</span> &amp;&amp; <span class="number">3</span> &gt; <span class="number">2</span>); <span class="comment">// false</span></span><br><span class="line">console.log(<span class="number">3</span> &lt; <span class="number">5</span> &amp;&amp; <span class="number">3</span> &gt; <span class="number">2</span>); <span class="comment">// true</span></span><br><span class="line">console.log(<span class="number">3</span> &gt; <span class="number">5</span> || <span class="number">3</span> &gt; <span class="number">2</span>); <span class="comment">// true </span></span><br><span class="line">console.log(<span class="number">3</span> &gt; <span class="number">5</span> || <span class="number">3</span> &lt; <span class="number">2</span>); <span class="comment">// false</span></span><br><span class="line">console.log(!<span class="literal">true</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="短路运算符"><a href="#短路运算符" class="headerlink" title="短路运算符"></a>短路运算符</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 用我们的布尔值参与的逻辑运算  true &amp;&amp; false  == false </span></span><br><span class="line"><span class="comment">// 2. 123 &amp;&amp; 456  是值 或者是 表达式 参与逻辑运算？ </span></span><br><span class="line"><span class="comment">// 3. 逻辑与短路运算  如果表达式1 结果为真 则返回表达式2  如果表达式1为假 那么返回表达式1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">123</span> &amp;&amp; <span class="number">456</span>); <span class="comment">// 456</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span> &amp;&amp; <span class="number">456</span>); <span class="comment">//  0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span> &amp;&amp; <span class="number">1</span> + <span class="number">2</span> &amp;&amp; <span class="number">456</span> * <span class="number">56789</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;&#x27;</span> &amp;&amp; <span class="number">1</span> + <span class="number">2</span> &amp;&amp; <span class="number">456</span> * <span class="number">56789</span>); <span class="comment">// &#x27;&#x27;</span></span><br><span class="line"><span class="comment">// 如果有空的或者否定的为假 其余是真的  0  &#x27;&#x27;  null undefined  NaN</span></span><br><span class="line"><span class="comment">// 4. 逻辑或短路运算  如果表达式1 结果为真 则返回的是表达式1 如果表达式1 结果为假 则返回表达式2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">123</span> || <span class="number">456</span>); <span class="comment">// 123</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">123</span> || <span class="number">456</span> || <span class="number">456</span> + <span class="number">123</span>); <span class="comment">// 123</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span> || <span class="number">456</span> || <span class="number">456</span> + <span class="number">123</span>); <span class="comment">// 456</span></span><br><span class="line"><span class="comment">// 逻辑中断很重要 它会影响我们程序运行结果思密达</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">123</span> || num++);<span class="comment">//123</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">123</span> || ++num);<span class="comment">//123</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><p>进入网吧案例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//         弹出 prompt 输入框，用户输入年龄， 程序把这个值取过来保存到变量中</span></span><br><span class="line">        <span class="comment">// 使用 if 语句来判断年龄，如果年龄大于18 就执行 if 大括号里面的输出语句</span></span><br><span class="line">        <span class="keyword">var</span> age = <span class="title function_">prompt</span>(<span class="string">&#x27;请输入您的年龄:&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (age &gt;= <span class="number">18</span>) &#123;</span><br><span class="line">            <span class="title function_">alert</span>(<span class="string">&#x27;我想带你去网吧偷耳机&#x27;</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="if-else双分支语句"><a href="#if-else双分支语句" class="headerlink" title="if else双分支语句"></a>if else双分支语句</h3><p>判断闰年案例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//         算法：能被4整除且不能整除100的为闰年（如2004年就是闰年，1901年不是闰年）或者能够被 400 整除的就是闰年</span></span><br><span class="line"><span class="comment">// 弹出prompt 输入框，让用户输入年份，把这个值取过来保存到变量中</span></span><br><span class="line"><span class="comment">// 使用 if 语句来判断是否是闰年，如果是闰年，就执行 if 大括号里面的输出语句，否则就执行 else里面的输出语句</span></span><br><span class="line"><span class="comment">// 一定要注意里面的且 &amp;&amp;  还有或者 || 的写法，同时注意判断整除的方法是取余为 0</span></span><br><span class="line">        <span class="keyword">var</span> year = <span class="title function_">prompt</span>(<span class="string">&#x27;请您输入年份：&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span> || year % <span class="number">400</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="title function_">alert</span>(<span class="string">&#x27;您输入的年份是闰年&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_">alert</span>(<span class="string">&#x27;您输入的年份是平年&#x27;</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="if-else-if多分支语句"><a href="#if-else-if多分支语句" class="headerlink" title="if else if多分支语句"></a>if else if多分支语句</h3><p>判断成绩案例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  伪代码       按照从大到小判断的思路</span></span><br><span class="line"><span class="comment">// 弹出prompt输入框，让用户输入分数（score），把这个值取过来保存到变量中</span></span><br><span class="line"><span class="comment">// 使用多分支 if else if 语句来分别判断输出不同的值</span></span><br><span class="line">        <span class="keyword">var</span> score = <span class="title function_">prompt</span>(<span class="string">&#x27;请您输入分数:&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (score &gt;= <span class="number">90</span>) &#123;</span><br><span class="line">            <span class="title function_">alert</span>(<span class="string">&#x27;宝贝，你是我的骄傲&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">80</span>) &#123;</span><br><span class="line">            <span class="title function_">alert</span>(<span class="string">&#x27;宝贝，你已经很出色了&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">70</span>) &#123;</span><br><span class="line">            <span class="title function_">alert</span>(<span class="string">&#x27;你要继续加油喽&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">            <span class="title function_">alert</span>(<span class="string">&#x27;孩子，你很危险&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_">alert</span>(<span class="string">&#x27;熊孩子，我不想和你说话，我只想用鞭子和你说话&#x27;</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="switch分支语句"><a href="#switch分支语句" class="headerlink" title="switch分支语句"></a>switch分支语句</h3><p>查询水果案例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//         弹出 prompt 输入框，让用户输入水果名称，把这个值取过来保存到变量中。</span></span><br><span class="line"><span class="comment">// 将这个变量作为 switch 括号里面的表达式。</span></span><br><span class="line"><span class="comment">// case 后面的值写几个不同的水果名称，注意一定要加引号 ，因为必须是全等匹配。</span></span><br><span class="line"><span class="comment">// 弹出不同价格即可。同样注意每个 case 之后加上 break ，以便退出 switch 语句。</span></span><br><span class="line"><span class="comment">// 将 default 设置为没有此水果。</span></span><br><span class="line">        <span class="keyword">var</span> fruit = <span class="title function_">prompt</span>(<span class="string">&#x27;请您输入查询的水果:&#x27;</span>);</span><br><span class="line">        <span class="keyword">switch</span> (fruit) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;苹果&#x27;</span>:</span><br><span class="line">                <span class="title function_">alert</span>(<span class="string">&#x27;苹果的价格是 3.5/斤&#x27;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;榴莲&#x27;</span>:</span><br><span class="line">                <span class="title function_">alert</span>(<span class="string">&#x27;榴莲的价格是 35/斤&#x27;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="attr">default</span>:</span><br><span class="line">                <span class="title function_">alert</span>(<span class="string">&#x27;没有此水果&#x27;</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><h4 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h4><ol><li>求1-100之间所有数的平均值  需要一个 sum 和的变量 还需要一个平均值 average 变量</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">var</span> average = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">          sum = sum + i;</span><br><span class="line">      &#125;</span><br><span class="line">      average = sum / <span class="number">100</span>;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(average);</span><br></pre></td></tr></table></figure><ol start="2"><li>求1-100之间所有偶数和奇数的和  我们需要一个偶数的和变量 even  还需要一个奇数 odd</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> even = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">var</span> odd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                even = even + i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                odd = odd + i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1~100 之间所有的偶数和是&#x27;</span> + even);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1~100 之间所有的奇数和是&#x27;</span> + odd);  </span><br></pre></td></tr></table></figure><ol start="3"><li>求1-100之间所有能被3整除的数字的和</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// result = result + i;</span></span><br><span class="line">                result += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1~100之间能够被3整数的数字的和是：&#x27;</span> + result);</span><br></pre></td></tr></table></figure><h4 id="求学生成绩案例："><a href="#求学生成绩案例：" class="headerlink" title="求学生成绩案例："></a>求学生成绩案例：</h4><ol><li>弹出输入框输入总的班级人数(num)</li><li>依次输入学生的成绩（ 保存起来 score）， 此时我们需要用到</li><li>for 循环， 弹出的次数跟班级总人数有关系 条件表达式 i &lt;&#x3D; num</li><li>进行业务处理: 计算成绩。 先求总成绩（ sum）， 之后求平均成绩（ average）</li><li>弹出结果</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="title function_">prompt</span>(<span class="string">&#x27;请输入班级的总人数:&#x27;</span>); <span class="comment">// num 总的班级人数</span></span><br><span class="line">        <span class="keyword">var</span> sum = <span class="number">0</span>; <span class="comment">// 求和的变量</span></span><br><span class="line">        <span class="keyword">var</span> average = <span class="number">0</span>; <span class="comment">// 求平均值的变量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= num; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> score = <span class="title function_">prompt</span>(<span class="string">&#x27;请您输入第&#x27;</span> + i + <span class="string">&#x27;个学生成绩&#x27;</span>);</span><br><span class="line">            <span class="comment">// 因为从prompt取过来的数据是 字符串型的需要转换为数字型</span></span><br><span class="line">            sum = sum + <span class="built_in">parseFloat</span>(score);</span><br><span class="line">        &#125;</span><br><span class="line">        average = sum / num;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&#x27;班级总的成绩是&#x27;</span> + sum);</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&#x27;班级平均分是：&#x27;</span> + average);</span><br></pre></td></tr></table></figure><h4 id="一行打印五个⭐"><a href="#一行打印五个⭐" class="headerlink" title="一行打印五个⭐"></a>一行打印五个⭐</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//直接输出五个⭐</span></span><br><span class="line"><span class="comment">// console.log(&#x27;⭐⭐⭐⭐⭐&#x27;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//for循环输出五个⭐</span></span><br><span class="line"><span class="comment">// for (var i = 1; i &lt;= 5; i++) &#123;</span></span><br><span class="line"><span class="comment">//     console.log(&#x27;⭐&#x27;);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//建立一个空的字符串，在里面用for循环添加五个⭐</span></span><br><span class="line"><span class="comment">// var str = &#x27;&#x27;;</span></span><br><span class="line"><span class="comment">// for (var i = 1; i &lt;= 5; i++) &#123;</span></span><br><span class="line"><span class="comment">//     str = str + &#x27;⭐&#x27;;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// console.log(str);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义⭐的个数，建立空字符串在其中添加</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="title function_">prompt</span>(<span class="string">&#x27;请输入星星的个数&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= num; i++) &#123;</span><br><span class="line">    str = str + <span class="string">&#x27;⭐&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str);</span><br></pre></td></tr></table></figure><h3 id="双重for循环"><a href="#双重for循环" class="headerlink" title="双重for循环"></a>双重for循环</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 双重for循环 语法结构</span></span><br><span class="line"><span class="comment">// for (外层的初始化变量; 外层的条件表达式; 外层的操作表达式) &#123;</span></span><br><span class="line"><span class="comment">//     for (里层的初始化变量; 里层的条件表达式; 里层的操作表达式) &#123;</span></span><br><span class="line"><span class="comment">//         // 执行语句;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// 2. 我们可以把里面的循环看做是外层循环的语句</span></span><br><span class="line"><span class="comment">// 3. 外层循环循环一次， 里面的循环执行全部</span></span><br><span class="line"><span class="comment">// 4. 代码验证</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;这是外层循环第&#x27;</span> + i + <span class="string">&#x27;次&#x27;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">1</span>; j &lt;= <span class="number">3</span>; j++) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;这是里层的循环第&#x27;</span> + j + <span class="string">&#x27;次&#x27;</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>for循环嵌套for循环，按照语法顺序一次运行</p><h4 id="打印五行⭐"><a href="#打印五行⭐" class="headerlink" title="打印五行⭐"></a>打印五行⭐</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打印五行五列星星⭐</span></span><br><span class="line">        <span class="keyword">var</span> str = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123; <span class="comment">// 外层循环负责打印五行</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">1</span>; j &lt;= <span class="number">5</span>; j++) &#123; <span class="comment">// 里层循环负责一行打印五个星星</span></span><br><span class="line">                str = str + <span class="string">&#x27;⭐&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果一行打印完毕5个星星就要另起一行 加 \n</span></span><br><span class="line">            str = str + <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(str);</span><br></pre></td></tr></table></figure><h4 id="打印n行n列⭐"><a href="#打印n行n列⭐" class="headerlink" title="打印n行n列⭐"></a>打印n行n列⭐</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rows = <span class="title function_">prompt</span>(<span class="string">&quot;请输入打印的行数&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> cols = <span class="title function_">prompt</span>(<span class="string">&quot;请输入打印的列数&quot;</span>)；</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(int a = <span class="number">0</span>;a &lt; rows;a++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(int b = <span class="number">0</span>;b &lt; cols;b++)&#123;</span><br><span class="line">            str = str + <span class="string">&#x27;⭐&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        str += <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str);</span><br></pre></td></tr></table></figure><h4 id="打印倒三角形"><a href="#打印倒三角形" class="headerlink" title="打印倒三角形"></a>打印倒三角形</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123; <span class="comment">// 外层循环控制行数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = i; j &lt;= <span class="number">10</span>; j++) &#123; <span class="comment">// 里层循环打印的个数不一样  j = i</span></span><br><span class="line">                str = str + <span class="string">&#x27;⭐&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            str += <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(str);</span><br></pre></td></tr></table></figure><h4 id="九九乘法表"><a href="#九九乘法表" class="headerlink" title="九九乘法表"></a>九九乘法表</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span>(int a = <span class="number">1</span>;a &lt;= <span class="number">10</span>;a++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(int b = <span class="number">1</span>;b &lt;= a;b++)&#123;</span><br><span class="line">        str += a + <span class="string">&#x27;*&#x27;</span> + b + <span class="string">&quot;=&quot;</span> + a*b + <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    str += <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str);</span><br></pre></td></tr></table></figure><h3 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h3><h4 id="案例：-1"><a href="#案例：-1" class="headerlink" title="案例："></a>案例：</h4><h5 id="打印人的一生"><a href="#打印人的一生" class="headerlink" title="打印人的一生"></a>打印人的一生</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=<span class="number">100</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;这个人今年&quot;</span>+i+<span class="string">&quot;岁&quot;</span>);</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="计算1-100之间整数和"><a href="#计算1-100之间整数和" class="headerlink" title="计算1~100之间整数和"></a>计算1~100之间整数和</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=<span class="number">100</span>)&#123;</span><br><span class="line">    sum += i;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sum);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>java004</title>
      <link href="/2022/10/29/java004/"/>
      <url>/2022/10/29/java004/</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA基础"><a href="#JAVA基础" class="headerlink" title="JAVA基础"></a>JAVA基础</h1><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="数组概念："><a href="#数组概念：" class="headerlink" title="数组概念："></a>数组概念：</h4><p>数组是一种容器，可以用来春促同种数据类型的多个值<br>存储数据时需要结合隐式转换考虑</p><p>如果定义int数组，double,boolen这些类型的数组时不可以存入的，<br>但是，byte,shrot,char这些类型因为会自动转换可以存入</p><p>建议：容器的类，和存储的数据类型保持一致。</p><h4 id="数组定义："><a href="#数组定义：" class="headerlink" title="数组定义："></a>数组定义：</h4><h5 id="格式一："><a href="#格式一：" class="headerlink" title="格式一："></a>格式一：</h5><p>数据类型 [] 数组名</p><p>比如：int [] arr   数据类型：int    数组名：arr</p><h5 id="格式二："><a href="#格式二：" class="headerlink" title="格式二："></a>格式二：</h5><p>数据类型 数组名 []</p><p>比如： int arr []   </p><hr><h4 id="数组静态初始化"><a href="#数组静态初始化" class="headerlink" title="数组静态初始化"></a>数组静态初始化</h4><h5 id="完整格式："><a href="#完整格式：" class="headerlink" title="完整格式："></a>完整格式：</h5><p>数据类型 [] 数组名 &#x3D; new 数据类型[]{元素1，元素2，元素3…};</p><p>比如：<br>    int [] arr &#x3D; new int[]{1 , 2 , 3};</p><p>​    double [] arr &#x3D; new double[]{1.1 , 2.2 , 3.3};</p><h5 id="格式详解："><a href="#格式详解：" class="headerlink" title="格式详解："></a>格式详解：</h5><p>数据类型： 限定数组以后可以存放什么类型数据</p><p>方括号： 表示现在定义的是一个数组</p><p>数组名： 给数组命名</p><h5 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h5><p>等号前后数据类型一致，创建完成数组后，长度不得发生改变</p><h5 id="简化格式："><a href="#简化格式：" class="headerlink" title="简化格式："></a>简化格式：</h5><p>数据类型 [] 数组名 &#x3D; {元素1，元素2，元素3…};</p><h6 id="练习1："><a href="#练习1：" class="headerlink" title="练习1："></a>练习1：</h6><p>定义存储3个学生的姓名</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String [] nameArr = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line">String [] nameArr = &#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><h6 id="练习2："><a href="#练习2：" class="headerlink" title="练习2："></a>练习2：</h6><p>定义存储5个学生的年龄</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> [] agesArr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>&#125;;</span><br><span class="line"><span class="type">int</span> [] agesArr = &#123;<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>&#125;;</span><br></pre></td></tr></table></figure><h6 id="练习3："><a href="#练习3：" class="headerlink" title="练习3："></a>练习3：</h6><p>定义存储4个学生的身高</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> [] heightArr = <span class="keyword">new</span> <span class="title class_">double</span>[]&#123;<span class="number">1.77</span>,<span class="number">1.78</span><span class="number">.1</span><span class="number">.79</span>,<span class="number">1.83</span>&#125;;</span><br><span class="line"><span class="type">double</span> [] heightArr = &#123;<span class="number">1.77</span>,<span class="number">1.78</span>,<span class="number">1.79</span>,<span class="number">1.83</span>&#125;;</span><br></pre></td></tr></table></figure><h4 id="地址值"><a href="#地址值" class="headerlink" title="地址值"></a>地址值</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">System.out.println(arr);<span class="comment">//[I@6d03e736</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span>[] arr2 = &#123;<span class="number">1.1</span>,<span class="number">2.2</span>,<span class="number">3.3</span>&#125;;</span><br><span class="line">System.out.println(arr2);<span class="comment">//[D@568db2f2</span></span><br></pre></td></tr></table></figure><p>数组的地址值：表示数组在内存中的位置</p><p>[ ：表示现在打印的是一个数组。<br>I：表示现在打印的数组是int类型的。<br>@：仅仅是一个间隔符号而已。<br>6d03e736：就是数组在内存中真正的地址值。（十六进制的）<br>但是，我们习惯性会把[I@6d03e736这个整体称之为数组的地址值。</p><h4 id="数组元素访问"><a href="#数组元素访问" class="headerlink" title="数组元素访问"></a>数组元素访问</h4><h5 id="格式："><a href="#格式：" class="headerlink" title="格式："></a>格式：</h5><p>数组名 [索引]</p><h5 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h5><p>获取数组中对应索引上的值<br>修改数组中对应索引上的值<br>一旦修改之后，原索引上的值就会被覆盖</p><h5 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrDemo2</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        数组中元素访问的格式：</span></span><br><span class="line"><span class="comment">                数组名[索引];</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         作用：</span></span><br><span class="line"><span class="comment">            1.获取指定索引上对应的元素</span></span><br><span class="line"><span class="comment">            2.修改指定索引上对应的元素</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">       <span class="comment">//需求1：获取arr数组中，3索引上的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> arr[<span class="number">3</span>];</span><br><span class="line">        System.out.println(number);</span><br><span class="line">        System.out.println(arr[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//需求2：将arr数组中，3索引上的值修改为10</span></span><br><span class="line">            arr[<span class="number">3</span>] = <span class="number">10</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;修改之后为:&quot;</span> + arr[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>也叫角标、下标</p><p> 就是数组容器中每一个小格子对应的编号。</p><p>相当于一个标有序号的关键字链</p><h5 id="索引的特点"><a href="#索引的特点" class="headerlink" title="索引的特点"></a>索引的特点</h5><ol><li>索引一定是从0开始的</li><li>索引不间断</li><li>索引依次增加1</li></ol><hr><h4 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">    <span class="comment">//在循环的过程中，i依次表示数组中的每一个索引</span></span><br><span class="line">    sout(arr[i]);<span class="comment">//就可以把数组里面的每一个元素都获取出来，并打印在控制台上了。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="数组的动态初始化"><a href="#数组的动态初始化" class="headerlink" title="数组的动态初始化"></a>数组的动态初始化</h4><h5 id="格式：-1"><a href="#格式：-1" class="headerlink" title="格式："></a>格式：</h5><p>数据类型 [] 数组名 &#x3D; new 数据类型[数组的长度]</p><h5 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.定义一个数组，存3个人的年龄，年龄未知</span></span><br><span class="line"><span class="type">int</span>[] agesArr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.定义一个数组，存班级10名学生的考试成绩，考试成绩暂时未知，考完才知道。</span></span><br><span class="line"><span class="type">int</span>[] scoresArr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><h5 id="数组的默认初始化："><a href="#数组的默认初始化：" class="headerlink" title="数组的默认初始化："></a>数组的默认初始化：</h5><p>整数类型：0</p><p>小数类型：0.0</p><p>布尔类型：false</p><p>字符类型：’\u0000’</p><p>引用类型：null</p><h4 id="数组两种初始化方式的区别"><a href="#数组两种初始化方式的区别" class="headerlink" title="数组两种初始化方式的区别"></a>数组两种初始化方式的区别</h4><p>静态初始化：int [] arr &#x3D; {1,2,3,4,5};</p><p>动态初始化：int [] arr &#x3D; new int [3];</p><p>静态初始化：手动指定数组的元素，系统会根据元素的个数，计算出数组的长度。</p><p>动态初始化：手动指定数组长度，由系统给出默认初始化值。</p><h5 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h5><p>只明确元素个数，但是不明确具体的数据，推荐使用动态初始化。</p><p>已经明确了要操作的所有数据，推荐使用静态初始化。</p><h5 id="举例：-1"><a href="#举例：-1" class="headerlink" title="举例："></a>举例：</h5><p>录入学生成绩，也已知学生成绩</p><p>就用int [] arr &#x3D; { };存放</p><p>如果只知道要录入多少，就动态初始化，给出一个数组的长度</p><p>如 int [] arr &#x3D; new int[5];</p><h4 id="数组常见问题"><a href="#数组常见问题" class="headerlink" title="数组常见问题"></a>数组常见问题</h4><p>当访问了数组中不存在的索引，就会引发索引越界异常</p><p><strong>避免：</strong>针对于任意一个数组，索引的范围，最小索引：0  最大索引：数组的长度 - 1   也就是 数组名.length - 1</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrDemo6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="comment">//用索引来访问数组中的元素</span></span><br><span class="line">        System.out.println(arr[<span class="number">1</span>]);</span><br><span class="line">        System.out.println(arr[<span class="number">10</span>]);<span class="comment">//ArrayIndexOutOfBoundsException</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="数组练习"><a href="#数组练习" class="headerlink" title="数组练习"></a>数组练习</h4><h5 id="练习1：求和"><a href="#练习1：求和" class="headerlink" title="练习1：求和"></a>练习1：求和</h5><p>需求：定义一个数组，存储1,2,3,4,5</p><p>遍历数组得到每一个元素，求数组里面所有的数据和</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分析：</span></span><br><span class="line"><span class="comment">//1.定义一个数组，并添加数据1,2,3,4,5</span></span><br><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求和变量</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//2.遍历数组得到每一个数据，累加求和</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="comment">//i 依次表示数组里面的每一个索引</span></span><br><span class="line">    <span class="comment">//arr[i] 依次表示数组里面的每一个元素</span></span><br><span class="line">    sum = sum + arr[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当循环结束之后，sum的值就是累加之后的结果</span></span><br><span class="line">System.out.println(sum);</span><br></pre></td></tr></table></figure><h5 id="练习2：统计个数"><a href="#练习2：统计个数" class="headerlink" title="练习2：统计个数"></a>练习2：统计个数</h5><p>需求：定义一个数组，存储1,2,3,4,5,6,7,8,9,10</p><p>遍历数组得到每一个元素，统计数组里面一共有多少个能被3整除的数字</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分析：</span></span><br><span class="line"><span class="comment">//1.定义一个数组 存储1,2,3,4,5,6,7,8,9,10</span></span><br><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line"><span class="comment">//定义一个变量，用来统计次数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//2.遍历数组得到每一个元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="comment">//i 表示数组里面的每一个索引</span></span><br><span class="line">    <span class="comment">//arr[i] 表示数组里面的每一个元素</span></span><br><span class="line">    <span class="comment">//3.判断当前的元素是否为3的倍数，如果是那么统计变量就需要自增一次。</span></span><br><span class="line">    <span class="keyword">if</span>(arr[i] % <span class="number">3</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// System.out.println(arr[i]);</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当循环结束之后，就表示数组里面所有的数字都判断完毕了，直接打印count即可</span></span><br><span class="line">System.out.println(<span class="string">&quot;数组中能被3整除的数字有&quot;</span> + count + <span class="string">&quot;个&quot;</span>);</span><br></pre></td></tr></table></figure><h5 id="⭐练习3：变换数据"><a href="#⭐练习3：变换数据" class="headerlink" title="⭐练习3：变换数据"></a>⭐练习3：变换数据</h5><p>需求：</p><p>定义一个数组，存储1,2,3,4,5,6,7,8,9,10</p><p>遍历数组得到每一个元素。</p><p>要求：</p><p>1，如果是奇数，则将当前数字扩大两倍</p><p>2，如果是偶数，则将当前数字变成二分之一</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分析：</span></span><br><span class="line"><span class="comment">//1.定义一个数组，存1,2,3,4,5,6,7,8,9,10</span></span><br><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="comment">//2.遍历数组得到每一个元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="comment">//i 依次表示数组里面的每一个索引</span></span><br><span class="line">    <span class="comment">//arr[i] 依次表示数组里面的每一个元素</span></span><br><span class="line">    <span class="comment">//3.对每一个元素进行判断</span></span><br><span class="line">    <span class="keyword">if</span>(arr[i] % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//偶数 变成二分之一</span></span><br><span class="line">        arr[i] = arr[i] / <span class="number">2</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//奇数 扩大两倍</span></span><br><span class="line">        arr[i] = arr[i] * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历数组</span></span><br><span class="line"><span class="comment">//一个循环尽量只做一件事情。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="练习4：求最值"><a href="#练习4：求最值" class="headerlink" title="练习4：求最值"></a>练习4：求最值</h5><p>需求：求数组中的最大值</p><p>定义数组求最大值：33,5,22,44,55</p><p>扩展问题：<br>1.根据求最大值的思路，自己改写一下求最小智<br>2.为什么max要记录为arr[0],默认值不能为0吗？<br>&#x2F;&#x2F;不能写0<br>max的初始化值一定要是数组中的值。<br>3.循环中开始条件一定是0吗？<br>循环的开始条件如果为0，那么第一次循环的时候是自己跟自己比了一下，对结果没有任何影响，但是效率偏低<br>&#x2F;&#x2F;为了提高效率，减少一次循环的次数，循环开始条件可以写1.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.定义数组用来存储5个值</span></span><br><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">33</span>,<span class="number">5</span>,<span class="number">22</span>,<span class="number">44</span>,<span class="number">55</span>&#125;;</span><br><span class="line"><span class="comment">//2.定义一个变量max用来存储最大值</span></span><br><span class="line"><span class="comment">//临时认为0索引的数据是最大的</span></span><br><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//3.循环获取数组中的每一个元素</span></span><br><span class="line"><span class="comment">//拿着每一个元素跟max进行比较</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="comment">//i 索引  arr[i] 元素</span></span><br><span class="line">    <span class="keyword">if</span>(arr[i] &gt; max)&#123;</span><br><span class="line">        max = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.当循环结束之后，max记录的就是数组中的最大值</span></span><br><span class="line">System.out.println(max);<span class="comment">//55</span></span><br></pre></td></tr></table></figure><h5 id="练习5：统计个数"><a href="#练习5：统计个数" class="headerlink" title="练习5：统计个数"></a>练习5：统计个数</h5><p>需求：生成10个1~100之间的随机数存入数组。</p><p>1）求出所有数据的和</p><p>2）求所有数据的平均数</p><p>3）统计有多少个数据比平均值小</p><p>random  (100)+1    r.nextint(100)+1</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.定义数组</span></span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//2.把随机数存入到数组当中</span></span><br><span class="line"><span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="comment">//每循环一次，就会生成一个新的随机数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> r.nextInt(<span class="number">100</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//把生成的随机数添加的数组当中</span></span><br><span class="line">    <span class="comment">//数组名[索引] = 数据;</span></span><br><span class="line">    arr[i] = number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1）求出所有数据的和</span></span><br><span class="line"><span class="comment">//定义求和变量</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="comment">//循环得到每一个元素</span></span><br><span class="line">    <span class="comment">//并把元素累加到sum当中</span></span><br><span class="line">    sum = sum + arr[i];</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;数组中所有数据的和为：&quot;</span> + sum);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2）求所有数据的平均数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">avg</span> <span class="operator">=</span> sum / arr.length;</span><br><span class="line">System.out.println(<span class="string">&quot;数组中平均数为：&quot;</span> + avg);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//3）统计有多少个数据比平均值小</span></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[i] &lt; avg)&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当循环结束之后，就表示我已经找到了所有的比平均数小的数据</span></span><br><span class="line">System.out.println(<span class="string">&quot;在数组中，一共有&quot;</span> + count + <span class="string">&quot;个数据，比平均数小&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历数组，验证答案</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    System.out.print(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="练习6："><a href="#练习6：" class="headerlink" title="练习6："></a>练习6：</h5><p>需求：定义一个数组，存入1,2,3,4,5。按照要求交换索引对应的元素。</p><p>交换前：1,2,3,4,5</p><p>交换后：5,2,3,4,1</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.定义数组存储数据</span></span><br><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">//2.利用循环去交换数据</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>,j = arr.length - <span class="number">1</span>; i &lt; j; i++,j--)&#123;</span><br><span class="line">    <span class="comment">//交换变量i和变量j指向的元素</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当循环结束之后，那么数组中的数据就实现了头尾交换</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    System.out.print(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="⭐练习7：打乱数据"><a href="#⭐练习7：打乱数据" class="headerlink" title="⭐练习7：打乱数据"></a>⭐练习7：打乱数据</h5><p>需求：定义一个数组，存入1~5。要求打乱数组中所有数据的顺序。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.定义数组存储1~5</span></span><br><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">//2.循环遍历数组，从0索引开始打乱数据的顺序</span></span><br><span class="line"><span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="comment">//⭐生成一个随机索引</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">randomIndex</span> <span class="operator">=</span> r.nextInt(arr.length);</span><br><span class="line">    <span class="comment">//拿着随机索引指向的元素 跟 i 指向的元素进行交换</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[randomIndex];</span><br><span class="line">    arr[randomIndex] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当循环结束之后，那么数组中所有的数据已经打乱顺序了</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    System.out.print(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Brute-Force算法</title>
      <link href="/2022/10/26/Brute-Force%E7%AE%97%E6%B3%95/"/>
      <url>/2022/10/26/Brute-Force%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Brute-Force算法"><a href="#Brute-Force算法" class="headerlink" title="Brute-Force算法"></a>Brute-Force算法</h1><h3 id="Brute-Force算法原理："><a href="#Brute-Force算法原理：" class="headerlink" title="Brute-Force算法原理："></a>Brute-Force算法原理：</h3><p><strong>Brute-Force匹配算法</strong>，翻译过来可以叫<strong>暴力匹配算法</strong>，典型应用场景就是字符串的匹配问题，比如寻找一个子串在主串中第一次出现的下标。这种匹配算法的逻辑是这样的：选取主串中指定位置作为匹配的起点(这篇文章使用的是首位作为起点)，将子串起点与该起点对比，比对成功后起点后移一位，子串的起点同样后移一位继续比较，直到将子串与主串中全部匹配；若是中途出现比对失败的情况，则将主串从原起点的下一位开始继续这种比较。</p><p>概括来说，<strong>主串先选中起点，子串起点开始与之对比，比对成功则字串后移，而此时主串将从起点的后一位开始比对，以此内推直到完成匹配</strong></p><hr><h3 id="while循环实现BF"><a href="#while循环实现BF" class="headerlink" title="while循环实现BF"></a>while循环实现BF</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Brute-Force匹配算法，该算法性能比较低----使用while实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">indexFirst</span><span class="params">(String strMain,String strSub)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(strMain.isEmpty() || strSub.isEmpty() || strSub.length()&gt;strMain.length() )&#123;</span><br><span class="line">            System.out.println(-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] mainChars = strMain.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] subChars = strSub.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;mainChars.length &amp;&amp; j&lt;subChars.length)&#123;</span><br><span class="line">            <span class="comment">//匹配成功，继续匹配下一位</span></span><br><span class="line">            <span class="keyword">if</span>(mainChars[i]==subChars[j])&#123;</span><br><span class="line">                <span class="keyword">if</span>(j==subChars.length-<span class="number">1</span>)&#123;</span><br><span class="line">                    System.out.println(i-j);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//匹配不成功,从下一位从新开始匹配</span></span><br><span class="line">                i=i-j+<span class="number">1</span>;</span><br><span class="line">                j=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="for循环实现BF"><a href="#for循环实现BF" class="headerlink" title="for循环实现BF"></a>for循环实现BF</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">indexFirstFor</span><span class="params">(String strMain,String strSub)</span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(strMain.isEmpty() || strSub.isEmpty() || strSub.length()&gt;strMain.length() )&#123;</span><br><span class="line">           System.out.println(-<span class="number">1</span>);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">char</span>[] mainChars = strMain.toCharArray();</span><br><span class="line">       <span class="type">char</span>[] subChars = strSub.toCharArray();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;mainChars.length-subChars.length+<span class="number">1</span>;i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;subChars.length;j++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(mainChars[i]==subChars[j])&#123;</span><br><span class="line">                   <span class="keyword">if</span>(j==subChars.length-<span class="number">1</span>)&#123;</span><br><span class="line">                       System.out.println(i-j);</span><br><span class="line">                       <span class="keyword">return</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   i++;</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(-<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归算法</title>
      <link href="/2022/10/26/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95/"/>
      <url>/2022/10/26/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h1><h3 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h3><p>递归算法是一种直接或间接调用自身函数或者方法的算法<br>也就是 程序自身的调用</p><h3 id="算法实质"><a href="#算法实质" class="headerlink" title="算法实质"></a>算法实质</h3><p>递归算法就是将原问题不断分解为规模缩小的子问题，然后递归调用方法来表示问题的解</p><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>递和归  递去 和 归来</p><p><strong>递去</strong>：将递归问题分为若干个规模较小，与原问题形式相同的子问题，这些子问题可以用相同的方法去解</p><p><strong>归来</strong>：问题不断缩小规模递去，必须有一个明确的结束递去的临界点（递归的出口），一旦到达该点就从该点原路返回到原点，解决问题</p><h4 id="图解分析"><a href="#图解分析" class="headerlink" title="图解分析"></a>图解分析</h4><img src="/2022/10/26/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95/递归算法/image-20221108141221675.png" alt="image-20221108141221675" style="zoom: 67%;"><h3 id="递归算法设计要素"><a href="#递归算法设计要素" class="headerlink" title="递归算法设计要素"></a>递归算法设计要素</h3><p>递归算法时一种从下向上的思维方式，递归算法的难点在于它的逻辑性</p><p><strong>注意：</strong></p><ul><li>明确递归的终止条件</li><li>提取重复的逻辑，缩小问题的规模不断递去</li><li>给出递归终止时的处理办法</li></ul><h3 id="递归算法的经典实例"><a href="#递归算法的经典实例" class="headerlink" title="递归算法的经典实例"></a>递归算法的经典实例</h3><p><strong>问题定义即为递归定义</strong></p><ul><li>阶乘</li><li>斐波那契数列</li><li>杨辉三角的取值</li></ul><p><strong>问题应用递归算法来解决</strong></p><ul><li>Hanoi塔问题⭐</li></ul><p><strong>部分数据结构也是用递归来定义的</strong></p><ul><li>树</li></ul><h4 id="问题递归定义"><a href="#问题递归定义" class="headerlink" title="问题递归定义"></a>问题递归定义</h4><h5 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)<span class="comment">//递归终止条件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> n*f(n-<span class="number">1</span>);<span class="comment">//缩小问题规模，依次递归</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非递归实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">Fac</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> n;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        n--;</span><br><span class="line">        result = result * n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>阶乘递归图解-例求f(4)</p><img src="/2022/10/26/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95/递归算法/image-20221108143333595.png" alt="image-20221108143333595"><h5 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h5><p>斐波那契数列，又称黄金分割数列，指的是这样一个数列：1、1、2、3、5、8、13…</p><p>在数学上，斐波那契数列以如下被以递归的方法定义：F0&#x3D;0,F1&#x3D;1,Fn&#x3D;F(n-1)+F(n-2)     (n&gt;2,n为正整数)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fibonacci(n-<span class="number">1</span>) + fibonacci(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="杨辉三角的取值"><a href="#杨辉三角的取值" class="headerlink" title="杨辉三角的取值"></a>杨辉三角的取值</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y &lt;= x &amp;&amp; y &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y == <span class="number">0</span> || x == y)<span class="comment">//递归终止条件</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> getValue(x-<span class="number">1</span> , y-<span class="number">1</span>) + getValue(x-<span class="number">1</span> , y);<span class="comment">//缩小问题规模，依次不断递归</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="应用递归算法解决问题"><a href="#应用递归算法解决问题" class="headerlink" title="应用递归算法解决问题"></a>应用递归算法解决问题</h4><ul><li>Hanoi塔</li></ul><h4 id="数据结构中的递归定义"><a href="#数据结构中的递归定义" class="headerlink" title="数据结构中的递归定义"></a>数据结构中的递归定义</h4><ul><li>树</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯算法</title>
      <link href="/2022/10/26/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
      <url>/2022/10/26/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>KMP算法</title>
      <link href="/2022/10/26/KMP%E7%AE%97%E6%B3%95/"/>
      <url>/2022/10/26/KMP%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><h3 id="BF算法-不提倡"><a href="#BF算法-不提倡" class="headerlink" title="BF算法(不提倡)"></a>BF算法(不提倡)</h3><p>如果用暴力匹配的思路，并假设现在 str1 匹配到 i 位置，子串 str2 匹配到 j 位置，则有:</p><ol><li>如果当前字符匹配成功(即str1[i]&#x3D;&#x3D;str2[j])，则i++，j++，继续匹配下一个字符</li><li>如果失配(即str1[i]!&#x3D;str2[j])，令i&#x3D;i-(j-1)，j&#x3D;0。相当于每次匹配失败时，i回溯，j被置为0。</li><li><strong>用暴力方法解决的话就会有大量的回溯，每次只移动一位，若是不匹配，移动到下一位接着判断，浪费了大量</strong><br><strong>的时间。(不可行!)</strong></li><li>暴力匹配算法实现.</li><li>代码</li></ol><p><strong>BF算法会浪费大量时间，低效</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ViolenceMatch</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;硅硅谷 尚硅谷你尚硅 尚硅谷你尚硅谷你尚硅你好&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;尚硅谷你尚硅你~&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> violenceMatch(str1, str2);</span><br><span class="line">        System.out.println(<span class="string">&quot;index=&quot;</span> + index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">violenceMatch</span><span class="params">(String str1, String str2)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] s1 = str1.toCharArray();<span class="comment">//将字符出遍历数组</span></span><br><span class="line">        <span class="type">char</span>[] s2 = str2.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">s1Len</span> <span class="operator">=</span> s1.length;<span class="comment">//数组的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">s2Len</span> <span class="operator">=</span> s2.length;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// i索引指向s1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// j索引指向s2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; s1Len &amp;&amp; j &lt; s2Len) &#123;<span class="comment">// 保证匹配时，不越界</span></span><br><span class="line">            <span class="keyword">if</span> (s1[i] == s2[j]) &#123;<span class="comment">//匹配 ok</span></span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//没有匹配成功</span></span><br><span class="line">                <span class="comment">//如果失配(即 str1[i]! = str2[j])，令 i = i - (j - 1)，j = 0。</span></span><br><span class="line">                i = i - (j - <span class="number">1</span>);</span><br><span class="line">                j = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否匹配成功</span></span><br><span class="line">        <span class="keyword">if</span> (j == s2Len) &#123;</span><br><span class="line">            <span class="keyword">return</span> i - j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里的i &#x3D; i - ( j + 1 ) :                0    1    2     3    4    5    6    7    8     9   10  11  12 13<br>首先假设两行字符串： str1:   a    b    c     d    e     f     g    h     i     j     k    l    m    n<br>                                       str2:    A    B    C    D    E    F    G    H    I     J     K    L   M    N</p><p>假设str1索引第一个指向a,那么从str2第一个数值开始，即A开始比对，每次只移动一位逐一比对</p><p>假设前面均比对成功，当str1索引指向e时，str2对应的E没有匹配成功，那么str2索引回到第一位重新配对，而这时因为时str2索引先动匹配，所以str1索引位置时( j - 1 )个长度，即为 i - ( j - 1 )</p><h3 id="KMP算法介绍"><a href="#KMP算法介绍" class="headerlink" title="KMP算法介绍"></a>KMP算法介绍</h3><p>Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP 算法”，常用于在一个文本串 S 内查找一个模式串 P 的 出现位置</p><h4 id="KMP算法原理："><a href="#KMP算法原理：" class="headerlink" title="KMP算法原理："></a>KMP算法原理：</h4><p>KMP 方法算法就利用之前判断过信息，通过一个 next 数组，保存模式串中前后最长公共子序列的长度，每次回溯时，通过 next 数组找到，前面匹配过的位置，省去了大量的计算时间</p><h3 id="KMP算法最佳应用-字符串匹配问题"><a href="#KMP算法最佳应用-字符串匹配问题" class="headerlink" title="KMP算法最佳应用-字符串匹配问题"></a>KMP算法最佳应用-字符串匹配问题</h3><h4 id="字符串匹配问题："><a href="#字符串匹配问题：" class="headerlink" title="字符串匹配问题："></a>字符串匹配问题：</h4><ol><li>有一个字符串str1&#x3D;“BBCABCDABABCDABCDABDE”，和一个子串str2&#x3D;“ABCDABD”</li><li>现在要判断 str1 是否含有 str2, 如果存在，就返回第一次出现的位置, 如果没有，则返回-1</li><li>要求:使用KMP算法完成判断，不能使用简单的暴力匹配算法.</li></ol><h4 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h4><p>现在有两串字符串:str1&#x3D;“BBCABCDABABCDABCDABDE”<br>                                str2&#x3D;“ABCDABD”</p><p>现在开始匹配str2，首先A 与str1中第一个字符B不相等，str1索引指向第二位，依旧不相等，继续后移直到索引指向A,开始匹配str2第二个字符，而刚刚str1索引指向的A的下一位恰好也和B相等，继续匹配，在匹配失败时，str1第一次的索引要后移（已经完成配对的个数 - 部分匹配值)(部分匹配值在后面有解释)个，这里因为是连续配对，所以前面的就不存在还可行的情况，索引移到新的位置开始配对</p><h3 id="图解："><a href="#图解：" class="headerlink" title="图解："></a>图解：</h3><p>1.首先，用 Str1 的第一个字符和 Str2 的第一个字符去比较，不符合，关键词向后移动一位</p><p><img src="/2022/10/26/KMP%E7%AE%97%E6%B3%95/image-20221027155119643.png" alt="image-20221027155119643"></p><ol start="2"><li>重复第一步，还是不符合，再后移</li></ol><p><img src="/2022/10/26/KMP%E7%AE%97%E6%B3%95/image-20221027155131273.png" alt="image-20221027155131273"></p><ol start="3"><li>一直重复，直到Str1有一个字符与Str2的第一个字符符合为止</li></ol><p><img src="/2022/10/26/KMP%E7%AE%97%E6%B3%95/image-20221027155214400.png" alt="image-20221027155214400"></p><ol start="4"><li>接着比较字符串和搜索词的下一个字符，还是符合。</li></ol><p><img src="/2022/10/26/KMP%E7%AE%97%E6%B3%95/image-20221027155228279.png" alt="image-20221027155228279"></p><p>5.遇到 Str1 有一个字符与 Str2 对应的字符不符合。</p><p><img src="/2022/10/26/KMP%E7%AE%97%E6%B3%95/image-20221027155238116.png" alt="image-20221027155238116"></p><p>6.这时候，想到的是继续遍历 Str1 的下一个字符，重复第 1 步。(其实是很不明智的，因为此时 BCD 已经比较过了， 没有必要再做重复的工作，一个基本事实是，当空格与 D 不匹配时，你其实知道前面六个字符是”ABCDAB”。 KMP 算法的想法是，<strong>设法利用这个已知信息，不要把”搜索位置”移回已经比较过的位置，继续把它向后移</strong>，这样就提高了效率。)</p><p><img src="/2022/10/26/KMP%E7%AE%97%E6%B3%95/image-20221027155746561.png" alt="image-20221027155746561"></p><p>7.对照表  str2索引移动的长度减去最后一位对应出现的次数</p><p><img src="/2022/10/26/KMP%E7%AE%97%E6%B3%95/image-20221027155942911.png" alt="image-20221027155942911"></p><p>8.已知空格与 D 不匹配时，前面六个字符”ABCDAB”是匹配的。查表可知，最后一个匹配字符 B 对应的”部分 匹配值”为 2，因此按照下面的公式算出向后移动的位数:<br><strong>移动位数 &#x3D; 已匹配的字符数 - 对应的部分匹配值</strong>因为 6 - 2 等于 4，所以将搜索词向后移动 4 位。</p><p>也就是str2索引移动的长度  -  对应部分匹配值</p><p>9.因为空格与C不匹配，搜索词还要继续往后移。这时，已匹配的字符数为 2(”AB”)，对应的”部分匹配值” 为 0。所以，移动位数 &#x3D; 2 - 0，结果为 2，于是将搜索词向后移 2 位。</p><p><img src="/2022/10/26/KMP%E7%AE%97%E6%B3%95/image-20221027160057459.png" alt="image-20221027160057459"></p><p>10.因为空格与 A 不匹配，继续后移一位。</p><p><img src="/2022/10/26/KMP%E7%AE%97%E6%B3%95/image-20221027160114963.png" alt="image-20221027160114963"></p><p>11.逐位比较，直到发现 C 与 D 不匹配。于是，移动位数 &#x3D; 6 - 2，继续将搜索词向后移动 4 位。</p><p><img src="/2022/10/26/KMP%E7%AE%97%E6%B3%95/image-20221027160127685.png" alt="image-20221027160127685"></p><p>12.逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索(即找出全部匹配)， 移动位数 &#x3D; 7 - 0，再将搜索词向后移动 7 位，这里就不再重复了。</p><p><img src="/2022/10/26/KMP%E7%AE%97%E6%B3%95/image-20221027160552443.png" alt="image-20221027160552443"></p><h3 id="部分匹配表"><a href="#部分匹配表" class="headerlink" title="部分匹配表"></a>部分匹配表</h3><h4 id="前缀，后缀"><a href="#前缀，后缀" class="headerlink" title="前缀，后缀"></a>前缀，后缀</h4><p><img src="/2022/10/26/KMP%E7%AE%97%E6%B3%95/image-20221027160805559.png" alt="image-20221027160805559"></p><h4 id="部分匹配值"><a href="#部分匹配值" class="headerlink" title="部分匹配值"></a>部分匹配值</h4><p>部分匹配值就是前缀和后缀最长的共有元素的长度</p><p><strong>以”ABCDABD”为例</strong>， </p><p>-”A”的前缀和后缀都为空集，共有元素的长度为 0; -”AB”的前缀为[A]，后缀为[B]，共有元素的长度为 0;<br>-”ABC”的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度 0;<br>-”ABCD”的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为 0;<br>-”ABCDA”的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为”A”，长度为 1; -”ABCDAB”的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为”AB”， 长度为 2;<br>-”ABCDABD”的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为 0。</p><h3 id="代码实现KMP算法"><a href="#代码实现KMP算法" class="headerlink" title="代码实现KMP算法"></a>代码实现KMP算法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> kmp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KMPAlgorithm</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;BBC ABCDAB ABCDABCDABDE&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;ABCDABD&quot;</span>;</span><br><span class="line">        <span class="comment">//String str2 = &quot;BBC&quot;;</span></span><br><span class="line">        <span class="type">int</span>[] next = kmpNext(<span class="string">&quot;ABCDABD&quot;</span>); <span class="comment">//[0, 1, 2, 0]</span></span><br><span class="line">        System.out.println(<span class="string">&quot;next=&quot;</span> + Arrays.toString(next));</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> kmpSearch(str1, str2, next);</span><br><span class="line">        System.out.println(<span class="string">&quot;index=&quot;</span> + index); <span class="comment">// 15 了</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str1 源字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str2 子串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> next 部分匹配表, 是子串对应的部分匹配表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果是-1 就是没有匹配到，否则返回第一个匹配的位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">kmpSearch</span><span class="params">(String str1, String str2, <span class="type">int</span>[] next)</span> &#123;</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; i &lt; str1.length(); i++) &#123;</span><br><span class="line">            <span class="comment">//需要处理 str1.charAt(i) != str2.charAt(j), 去调整 j 的大小</span></span><br><span class="line">            <span class="comment">//KMP 算法核心点, 可以验证...</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; str1.charAt(i) != str2.charAt(j)) &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (str1.charAt(i) == str2.charAt(j)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == str2.length()) &#123;<span class="comment">//找到了 // j = 3 i</span></span><br><span class="line">                <span class="keyword">return</span> i - j + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取到一个字符串(子串) 的部分匹配值表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] kmpNext(String dest) &#123;</span><br><span class="line">        <span class="comment">//创建一个 next 数组保存部分匹配值</span></span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[dest.length()];</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//如果字符串是长度为 1 部分匹配值就是 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, j = <span class="number">0</span>; i &lt; dest.length(); i++) &#123;</span><br><span class="line">            <span class="comment">//当 dest.charAt(i) != dest.charAt(j) ，我们需要从 next[j-1]获取新的 j</span></span><br><span class="line">            <span class="comment">//直到我们发现 有 dest.charAt(i) == dest.charAt(j)成立才退出</span></span><br><span class="line">            <span class="comment">//这时 kmp 算法的核心点</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; dest.charAt(i) != dest.charAt(j)) &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当 dest.charAt(i) == dest.charAt(j) 满足时，部分匹配值就是+1</span></span><br><span class="line">            <span class="keyword">if</span>(dest.charAt(i) == dest.charAt(j)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="NEXT"><a href="#NEXT" class="headerlink" title="NEXT[]"></a>NEXT[]</h3><p>next数组：</p><p>**next[i]**（i从1开始算）代表着，除去第i个数，在一个字符串里面从第一个数到第（i-1）字符串前缀与后缀最长重复的个数。</p><h3 id="KMP核心代码-j-x3D-next-j-1"><a href="#KMP核心代码-j-x3D-next-j-1" class="headerlink" title="KMP核心代码 j &#x3D; next[j-1]"></a>KMP核心代码 j &#x3D; next[j-1]</h3><p><img src="/2022/10/26/KMP%E7%AE%97%E6%B3%95/image-20221029133533330.png" alt="image-20221029133533330"></p><p>当i&#x3D;8时，此时j&#x3D;3,发现dest.charAt(i) !&#x3D; dest.charAt(j)，j向前移一位，上图我们已经将j向前移了一位,即j&#x3D;2，（根据结论逆推）此时比较2与8，但前提确保2前面的字符 （0-1）是否是与8前面的字符（6-7）相等， 此时 next[2]&#x3D;2，表示黄色部分前两个字符与后两个字符相等（0-1与1-2相等），而在上次遍历（i&#x3D;7）时我们已经确认蓝色部分与黄色部分匹配（j&#x3D;3），故1-2与6-7相等，所以0-1与6-7相等，此时我们只需比较2与8是否相等就可以求出最大公共前后缀了。</p><p> j&#x3D;next[j-1]代表j从0开始移动next[j-1]下，此时j前面的字符（0-1）已经与i前面的字符（6-7）相等了。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java003</title>
      <link href="/2022/10/26/java003/"/>
      <url>/2022/10/26/java003/</url>
      
        <content type="html"><![CDATA[<h1 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h1><h3 id="循环高级"><a href="#循环高级" class="headerlink" title="循环高级"></a>循环高级</h3><h4 id="逢七过"><a href="#逢七过" class="headerlink" title="逢七过"></a>逢七过</h4><p>需求：</p><p> 朋友聚会的时候可能会玩一个游戏：逢7过</p><p> 游戏规则：从任意一个数字开始报数，当你要报的数字是包含7或者是7的倍数时都要说过：过</p><p> 使用程序在控制台打印出1-100之间的满足逢七必过规则的数据</p><p>举例：</p><p> 1 2 3 4 5 6 过 8 9 10 11 12 13 过 15 16 过 18 …</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*朋友聚会的时候可能会玩一个游戏：逢7过</span></span><br><span class="line"><span class="comment">        游戏规则：从任意一个数字开始报数，当你要报的数字是包含7或者是7的倍数时都要说过：过</span></span><br><span class="line"><span class="comment">        需求：使用程序在控制台打印出1-100之间的满足逢七必过规则的数据*/</span></span><br><span class="line"><span class="comment">//分析：</span></span><br><span class="line"><span class="comment">//个位7  十位7   7倍数</span></span><br><span class="line"><span class="comment">//1 2 3 4 5 6 过 8 9 10 11 12 13 过 15 16 过 18 19 20 过....</span></span><br><span class="line"><span class="comment">//69 过 过 过 过 过 过... 80</span></span><br><span class="line"><span class="comment">//1.得到1~100之间的每一个数字</span></span><br><span class="line"><span class="comment">//开始：1</span></span><br><span class="line"><span class="comment">//结束：100</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">    <span class="comment">//2.判断每一个数字，如果符合规则，就打印过，如果不符合规则就打印真实的数字</span></span><br><span class="line">    <span class="keyword">if</span>(i % <span class="number">10</span> == <span class="number">7</span> || i / <span class="number">10</span> % <span class="number">10</span> == <span class="number">7</span>  ||  i % <span class="number">7</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;过&quot;</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="平方根"><a href="#平方根" class="headerlink" title="平方根"></a>平方根</h4><p>需求：</p><p> 键盘录入一个大于等于2的整数 x ，计算并返回 x 的 平方根 。结果只保留整数部分 ，小数部分将被舍去 。</p><p>需求：键盘录入一个大于等于2的整数 x ，计算并返回 x 的 平方根 。<br>        结果只保留整数部分 ，小数部分将被舍去 。</p><p>分析：<br>平方根   16的平方根4<br>         4的平方根2</p><p> 10<br> 1 * 1 &#x3D; 1 &lt; 10<br> 2 * 2 &#x3D; 4 &lt; 10<br> 3 * 3 &#x3D; 9 &lt; 10<br> 4 * 4 &#x3D; 16 &gt; 10<br>推断：10的平方根是在3~4之间。</p><p> 20<br> 1 * 1 &#x3D; 1 &lt; 20<br> 2 * 2 &#x3D; 4 &lt; 20<br> 3 * 3 &#x3D; 9 &lt; 20<br> 4 * 4 &#x3D; 16 &lt; 20<br> 5 * 5 &#x3D; 25 &gt; 20<br>推断：20的平方根是在4~5之间。</p><p>在代码当中<br>从1开始循环，拿着数字的平方跟原来的数字进行比较<br>如果小于的，那么继续往后判断<br>如果相等，那么当前数字就是平方根<br>如果大于的，那么前一个数字就是平方跟的整数部分</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.键盘录入一个整数</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入一个整数&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="comment">//2.从1开始循环判断</span></span><br><span class="line"><span class="comment">//开始：1 结束: number</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= number; i++) &#123;</span><br><span class="line">    <span class="comment">//用i * i 再跟number进行比较</span></span><br><span class="line">    <span class="keyword">if</span>(i * i == number)&#123;</span><br><span class="line">        System.out.println(i + <span class="string">&quot;就是&quot;</span> + number + <span class="string">&quot;的平方根&quot;</span>);</span><br><span class="line">        <span class="comment">//一旦找到了，循环就可以停止了，后面的数字就不需要再找了，提高代码的运行效率。</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i * i &gt; number)&#123;</span><br><span class="line">        System.out.println((i - <span class="number">1</span>) + <span class="string">&quot;就是&quot;</span> + number + <span class="string">&quot;平方根的整数部分&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果刚好i的平方与number相等，则i为number的平方根；如果恰好number比i的平方要大，那么i平方是第一个比number大的数，所以i-1是number平方根的整数部分</span></span><br></pre></td></tr></table></figure><h4 id="判断是否为质数"><a href="#判断是否为质数" class="headerlink" title="判断是否为质数"></a>判断是否为质数</h4><p>需求：</p><p> 键盘录入一个正整数 x ，判断该整数是否为一个质数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需求：键盘录入一个正整数 x ，判断该整数是否为一个质数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//质数：</span></span><br><span class="line"><span class="comment">//如果一个整数只能被1和本身整除，那么这个数就是质数。否则这个数叫做合数</span></span><br><span class="line"><span class="comment">//7 = 1 * 7 质数</span></span><br><span class="line"><span class="comment">//8 = 1 * 8  2 * 4 合数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//分析：</span></span><br><span class="line"><span class="comment">//1.键盘录入一个正整数</span></span><br><span class="line"><span class="comment">//number</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入一个正整数&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> sc.nextInt();<span class="comment">//9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个变量，表示标记</span></span><br><span class="line"><span class="comment">//标记着number是否为一个质数</span></span><br><span class="line"><span class="comment">//true： 是一个质数</span></span><br><span class="line"><span class="comment">//false : 不是一个质数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//表示最初就认为number是一个质数</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.判断</span></span><br><span class="line"><span class="comment">//写一个循环，从2开始判断，一直判断到number-1为止</span></span><br><span class="line"><span class="comment">//看这个范围之内，有没有数字可以被number整除</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; number; i++) &#123;</span><br><span class="line">    <span class="comment">//i 依次表示这个范围之内的每一个数字</span></span><br><span class="line">    <span class="comment">//看number是否能被i整除就可以了</span></span><br><span class="line">    <span class="keyword">if</span>(number % i == <span class="number">0</span>)&#123;<span class="comment">// 9 % 2 = 1</span></span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//System.out.println(number + &quot;不是一个质数&quot;);</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;<span class="comment">/*else&#123;</span></span><br><span class="line"><span class="comment">                System.out.println(number + &quot;是一个质数&quot;);</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只有当这个循环结束了，表示这个范围之内所有的数字都判断完毕了</span></span><br><span class="line"><span class="comment">//此时才能断定number是一个质数</span></span><br><span class="line"><span class="keyword">if</span>(flag)&#123;</span><br><span class="line">    System.out.println(number + <span class="string">&quot;是一个质数&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(number + <span class="string">&quot;不是一个质数&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="猜数字小游戏"><a href="#猜数字小游戏" class="headerlink" title="猜数字小游戏"></a>猜数字小游戏</h4><p>需求：</p><p> 程序自动生成一个1-100之间的随机数，在代码中使用键盘录入去猜出这个数字是多少？</p><p>要求：</p><p> 使用循环猜，一直猜中为止。</p><p>思路分析：</p><ol><li>生成一个1-100之间的随机数</li><li>使用键盘录入去猜出这个数字是多少</li><li>把反复猜的代码写在循环中</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.生成一个1-100之间的随机数</span></span><br><span class="line"><span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> r.nextInt(<span class="number">100</span>) + <span class="number">1</span>;<span class="comment">// 0 ~ 99 + 1 --- 1 ~ 100</span></span><br><span class="line">System.out.println(number);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.使用键盘录入去猜出这个数字是多少？</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入一个整数&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">guessNumber</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">    <span class="comment">//3.比较</span></span><br><span class="line">    <span class="keyword">if</span>(guessNumber &gt; number)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;您猜的数字大了&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(guessNumber &lt; number)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;您猜的数字小了&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;恭喜你，猜中了&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;<span class="number">0</span> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>java002</title>
      <link href="/2022/10/26/java002/"/>
      <url>/2022/10/26/java002/</url>
      
        <content type="html"><![CDATA[<h1 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h1><h3 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h3><h5 id="流程控制语句分类"><a href="#流程控制语句分类" class="headerlink" title="流程控制语句分类"></a>流程控制语句分类</h5><p>顺序结构</p><p>判断和选择结构(if , switch)</p><p>循环结构(for , while , do…while)</p><h5 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h5><p><img src="https://thumbnail1.baidupcs.com/thumbnail/fe3e12568u7de2fad4539c0c3e2d35e6?fid=1103005553467-250528-77055408700127&rt=pr&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-RmJU/GbJVaA2Q50zAKtAGGonjlY=&expires=8h&chkbd=0&chkv=0&dp-logid=5008051728761383&dp-callid=0&time=1666753200&size=c1707_u960&quality=90&vuk=1103005553467&ft=image&autopolicy=1" alt="img"></p><hr><h3 id="判断语句-if语句"><a href="#判断语句-if语句" class="headerlink" title="判断语句: if语句"></a>判断语句: if语句</h3><h4 id="if语句格式-1："><a href="#if语句格式-1：" class="headerlink" title="if语句格式 1："></a>if语句格式 1：</h4><p>格式：<br>if (关系表达式) {<br>    语句体;<br>}</p><p><strong>执行流程：</strong></p><p>①首先计算关系表达式的值</p><p>②如果关系表达式的值为true就执行语句体</p><p>③如果关系表达式的值为false就不执行语句体</p><p>④继续执行后面的语句内容</p><img src="https://thumbnail1.baidupcs.com/thumbnail/804683b13qeabdc789b82b6d7593bd97?fid=1103005553467-250528-808889076163316&rt=pr&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-C1OKyswwEunVFhX3q54uD%2bktu1g%3d&expires=8h&chkbd=0&chkv=0&dp-logid=5124272328361749&dp-callid=0&time=1666753200&size=c1707_u960&quality=90&vuk=1103005553467&ft=image&autopolicy=1" alt="img" style="zoom:67%;"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IfDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line"><span class="comment">//定义两个变量</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="comment">//需求：判断a和b的值是否相等，如果相等，就在控制台输出：a等于b</span></span><br><span class="line"><span class="keyword">if</span>(a == b) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;a等于b&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//需求：判断a和c的值是否相等，如果相等，就在控制台输出：a等于c</span></span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(a == c) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;a等于c&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h5><p><strong>练习1：老丈人选女婿</strong></p><p>需求：</p><p> 键盘录入女婿的酒量，如果大于2斤，老丈人给出回应，否则没有任何回应</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分析：</span></span><br><span class="line"><span class="comment">//1.键盘录入女婿的酒量</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入女婿的酒量&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">wine</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="comment">//2.对酒量进行一个判断即可</span></span><br><span class="line"><span class="keyword">if</span>(wine &gt; <span class="number">2</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;不错哟，小伙子&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>练习2：考试奖励</strong></p><p>需求：</p><p> 键盘录入一个整数，表示小明的考试名次，如果名次为1，小红可以当小明的女朋友捏。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分析：</span></span><br><span class="line"><span class="comment">//1.键盘录入一个整数，表示小明的考试名次</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入小明的名次&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">rank</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="comment">//2.对小明的考试成绩进行判断即可</span></span><br><span class="line"><span class="keyword">if</span>(rank == <span class="number">1</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;小红成为了小明的女朋友&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="if语句格式-2："><a href="#if语句格式-2：" class="headerlink" title="if语句格式 2："></a>if语句格式 2：</h4><p>格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (关系表达式) &#123;</span><br><span class="line">    语句体<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    语句体<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行流程：</p><p>①首先计算关系表达式的值</p><p>②如果关系表达式的值为true就执行语句体1</p><p>③如果关系表达式的值为false就执行语句体2</p><p>④继续执行后面的语句内容</p><p><img src="https://thumbnail1.baidupcs.com/thumbnail/804683b13qeabdc789b82b6d7593bd97?fid=1103005553467-250528-808889076163316&rt=pr&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-rLftAHtLe+2PfqOV3NhQ9Tprl10=&expires=8h&chkbd=0&chkv=0&dp-logid=12650489569965617&dp-callid=0&time=1666782000&size=c1707_u960&quality=90&vuk=1103005553467&ft=image&autopolicy=1" alt="img"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IfDemo02</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line"><span class="comment">//定义两个变量</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="comment">//需求：判断a是否大于b，如果是，在控制台输出：a的值大于b，否则，在控制台输出：a的值不大于b</span></span><br><span class="line"><span class="keyword">if</span>(a &amp;gt; b) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;a的值大于b&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;a的值不大于b&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="练习：-1"><a href="#练习：-1" class="headerlink" title="练习："></a>练习：</h5><p><strong>练习1：吃饭</strong></p><p>需求：</p><p> 键盘录入一个整数，表示身上的钱。</p><p> 如果大于等于100块，就是网红餐厅。</p><p> 否则，就吃经济实惠的沙县小吃。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分析：</span></span><br><span class="line"><span class="comment">//1.键盘录入一个整数。表示身上的钱。</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入一个整数表示身上的钱&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="comment">//2.对钱进行判断</span></span><br><span class="line"><span class="keyword">if</span>(money &gt;= <span class="number">100</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;吃网红餐厅&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;沙县小吃&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>练习2：影院选座</strong></p><p>需求：</p><p> 在实际开发中，电影院选座也会使用到if判断。</p><p> 假设某影院售卖了100张票，票的序号为1~100。</p><p> 其中奇数票号坐左侧，偶数票号坐右侧。</p><p> 键盘录入一个整数表示电影票的票号。</p><p> 根据不同情况，给出不同的提示：</p><p> 如果票号为奇数，那么打印坐左边。</p><p> 如果票号为偶数，那么打印坐右边。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分析：</span></span><br><span class="line"><span class="comment">//1.键盘录入票号</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入票号&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="keyword">if</span>(ticket &gt;= <span class="number">1</span> &amp;&amp; ticket &lt;= <span class="number">100</span>)&#123;</span><br><span class="line">    <span class="comment">//合法</span></span><br><span class="line">    <span class="comment">//2.对票号进行判断</span></span><br><span class="line">    <span class="keyword">if</span> (ticket % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//偶数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;坐右边&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//奇数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;坐左边&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//票号不合法</span></span><br><span class="line">    System.out.println(<span class="string">&quot;票号不合法&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="if语句格式-3"><a href="#if语句格式-3" class="headerlink" title="if语句格式 3:"></a>if语句格式 3:</h4><p>格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (关系表达式<span class="number">1</span>) &#123;</span><br><span class="line">    语句体<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (关系表达式<span class="number">2</span>) &#123;</span><br><span class="line">    语句体<span class="number">2</span>;</span><br><span class="line">&#125; </span><br><span class="line">…</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    语句体n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行流程：</p><p>①首先计算关系表达式1的值</p><p>②如果值为true就执行语句体1；如果值为false就计算关系表达式2的值</p><p>③如果值为true就执行语句体2；如果值为false就计算关系表达式3的值</p><p>④…</p><p>⑤如果没有任何关系表达式为true，就执行语句体n+1。</p><img src="https://thumbnail0.baidupcs.com/thumbnail/48bf5f736ic5c61ef9f54815fbd8635f?fid=1103005553467-250528-948121161798466&rt=pr&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-qp6Ni9%2fx%2bp2ReCV7%2fNVR0bolUvA%3d&expires=8h&chkbd=0&chkv=0&dp-logid=7178055935343333&dp-callid=0&time=1666760400&size=c1999_u1999&quality=100&vuk=1103005553467&ft=image" alt="img" style="zoom:67%;"><h5 id="练习：-2"><a href="#练习：-2" class="headerlink" title="练习："></a>练习：</h5><p><strong>练习1：考试奖励</strong></p><p>需求：</p><p> 小明快要期末考试了，小明爸爸对他说，会根据他不同的考试成绩，送他不同的礼物，</p><p>假如你可以控制小明的得分，请用程序实现小明到底该获得什么样的礼物，并在控制台输出。</p><p>分析：</p><p> ①小明的考试成绩未知，可以使用键盘录入的方式获取值</p><p> ②由于奖励种类较多，属于多种判断，采用if…else…if格式实现</p><p> ③为每种判断设置对应的条件</p><p> ④为每种判断设置对应的奖励</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//95~100 自行车一辆</span></span><br><span class="line"><span class="comment">//90~94   游乐场玩一天</span></span><br><span class="line"><span class="comment">//80 ~ 89 变形金刚一个</span></span><br><span class="line"><span class="comment">//80 以下  胖揍一顿</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.键盘录入一个值表示小明的分数</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入小明的成绩&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="comment">//2.对分数的有效性进行判断</span></span><br><span class="line"><span class="keyword">if</span>(score &gt;= <span class="number">0</span> &amp;&amp; score &lt;= <span class="number">100</span>)&#123;</span><br><span class="line">    <span class="comment">//有效的分数</span></span><br><span class="line">    <span class="comment">//3.对小明的分数进行判断，不同情况执行不同的代码</span></span><br><span class="line">    <span class="keyword">if</span>(score &gt;= <span class="number">95</span> &amp;&amp; score &lt;= <span class="number">100</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;送自行车一辆&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(score &gt;= <span class="number">90</span> &amp;&amp; score &lt;= <span class="number">94</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;游乐场玩一天&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(score &gt;= <span class="number">80</span> &amp;&amp; score &lt;= <span class="number">89</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;变形金刚一个&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;胖揍一顿&quot;</span>);<span class="comment">//范围内剩下分数都运行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//无效的分数</span></span><br><span class="line">    System.out.println(<span class="string">&quot;分数不合法&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><h4 id="格式："><a href="#格式：" class="headerlink" title="格式："></a><strong>格式：</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (表达式) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">语句体<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">语句体<span class="number">2</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">语句体n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="执行流程："><a href="#执行流程：" class="headerlink" title="执行流程："></a>执行流程：</h4><ul><li><p>首先计算出表达式的值</p></li><li><p>其次，和case依次比较，一旦有对应的值，就会执行相应的语句，在执行的过程中，遇到break就会结 束。</p></li><li><p>最后，如果所有的case都和表达式的值不匹配，就会执行default语句体部分，然后程序结束掉。</p><p>逐个筛选，若有对应值就运行对应的语句，都没有的话执行default语句体</p></li></ul><h4 id="练习：-3"><a href="#练习：-3" class="headerlink" title="练习："></a>练习：</h4><p><strong>运动计划：</strong></p><p>需求：键盘录入星期数，显示今天的减肥活动。</p><p>周一：跑步</p><p>周二：游泳</p><p>周三：慢走</p><p>周四：动感单车</p><p>周五：拳击</p><p>周六：爬山</p><p>周日：好好吃一顿</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//1.键盘录入一个整数表示星期</span></span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入一个整数表示星期&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">week</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.书写一个switch语句去跟week进行匹配</span></span><br><span class="line">    <span class="keyword">switch</span> (week)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;跑步&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;游泳&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;慢走&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;动感单车&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;拳击&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;爬山&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;好好吃一顿&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;输入错误，没有这个星期&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="拓展知识："><a href="#拓展知识：" class="headerlink" title="拓展知识："></a>拓展知识：</h4><p>default可以放在任何位置，也可以省略；<br>在case完成后要加上break ，不然会引发case穿透现象(不会在运行完当前case语句停止，一直向下运行直到遇到break或者结束)</p><h4 id="练习：-4"><a href="#练习：-4" class="headerlink" title="练习："></a>练习：</h4><p><strong>休息日和工作日</strong></p><p>需求：键盘录入星期数，输出工作日、休息日。</p><p>(1-5) 工作日，(6-7)休息日。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.键盘录入星期数</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入星期&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">week</span> <span class="operator">=</span> sc.nextInt();<span class="comment">//3</span></span><br><span class="line"><span class="comment">//2.利用switch进行匹配</span></span><br><span class="line">----------------------------------------------------</span><br><span class="line"><span class="comment">//利用case穿透简化代码(没有break会一直运行直到遇到break或者结束)</span></span><br><span class="line"><span class="keyword">switch</span> (week)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;工作日&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;休息日&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;没有这个星期&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------</span><br><span class="line"><span class="comment">//利用JDK12简化代码书写</span></span><br><span class="line"><span class="keyword">switch</span> (week) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> -&gt; System.out.println(<span class="string">&quot;工作日&quot;</span>);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>, <span class="number">7</span> -&gt; System.out.println(<span class="string">&quot;休息日&quot;</span>);</span><br><span class="line">            <span class="keyword">default</span> -&gt; System.out.println(<span class="string">&quot;没有这个星期&quot;</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><h4 id="for循环结构："><a href="#for循环结构：" class="headerlink" title="for循环结构："></a>for循环结构：</h4><h5 id="for循环格式："><a href="#for循环格式：" class="headerlink" title="for循环格式："></a>for循环格式：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (初始化语句;条件判断语句;条件控制语句) &#123;</span><br><span class="line">循环体语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="执行流程：-1"><a href="#执行流程：-1" class="headerlink" title="执行流程："></a><strong>执行流程：</strong></h5><p>①执行初始化语句</p><p>②执行条件判断语句，看其结果是true还是false</p><p> 如果是false，循环结束</p><p> 如果是true，继续执行</p><p>③执行循环体语句</p><p>④执行条件控制语句</p><p>⑤回到②继续</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.确定循环的开始条件</span></span><br><span class="line"><span class="comment">//2.确定循环的结束条件</span></span><br><span class="line"><span class="comment">//3.确定要重复执行的代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//需求：打印5次HelloWorld</span></span><br><span class="line"><span class="comment">//开始条件：1</span></span><br><span class="line"><span class="comment">//结束条件：5</span></span><br><span class="line"><span class="comment">//重复代码：打印语句</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &amp;lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    System.out.println(&amp;quot;HelloWorld&amp;quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="for循环练习："><a href="#for循环练习：" class="headerlink" title="for循环练习："></a>for循环练习：</h4><h5 id="输出数据："><a href="#输出数据：" class="headerlink" title="输出数据："></a>输出数据：</h5><ul><li>需求：在控制台输出1-5和5-1的数据</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//需求：输出数据1-5</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&gt;;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&amp;quot;--------&amp;quot;);</span><br><span class="line"><span class="comment">//需求：输出数据5-1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">5</span>; i&gt;=<span class="number">1</span>; i--) &#123;</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="求和："><a href="#求和：" class="headerlink" title="求和："></a>求和：</h5><ul><li>需求：求1-5之间的数据和，并把求和结果在控制台输出</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//求和的最终结果必须保存起来，需要定义一个变量，用于保存求和的结果，初始值为0</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//从1开始到5结束的数据，使用循环结构完成</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&gt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line"><span class="comment">//将反复进行的事情写入循环结构内部</span></span><br><span class="line">             <span class="comment">// 此处反复进行的事情是将数据 i 加到用于保存最终求和的变量 sum 中</span></span><br><span class="line">sum = sum + i;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sum += i;sum = sum + i;</span></span><br><span class="line"><span class="comment">第一次：sum = sum + i = 0 + 1 = 1;</span></span><br><span class="line"><span class="comment">第二次：sum = sum + i = 1 + 2 = 3;</span></span><br><span class="line"><span class="comment">第三次：sum = sum + i = 3 + 3 = 6;</span></span><br><span class="line"><span class="comment">第四次：sum = sum + i = 6 + 4 = 10;</span></span><br><span class="line"><span class="comment">第五次：sum = sum + i = 10 + 5 = 15;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当循环执行完毕时，将最终数据打印出来</span></span><br><span class="line">System.out.println(<span class="string">&quot;1-5之间的数据和是:&quot;</span> + sum);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="求偶数和："><a href="#求偶数和：" class="headerlink" title="求偶数和："></a>求偶数和：</h5><ul><li>需求：求1-100之间的偶数和，并把求和结果在控制台输出</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//求和的最终结果必须保存起来，需要定义一个变量，用于保存求和的结果，初始值为0</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//对1-100的数据求和与1-5的数据求和几乎完全一样，仅仅是结束条件不同</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&gt;;=<span class="number">100</span>; i++) &#123;</span><br><span class="line"><span class="comment">//对1-100的偶数求和，需要对求和操作添加限制条件，判断是否是偶数</span></span><br><span class="line"><span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//sum += i；</span></span><br><span class="line">sum = sum + i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当循环执行完毕时，将最终数据打印出来</span></span><br><span class="line">System.out.println(<span class="string">&quot;1-100之间的偶数和是&quot;</span>： + sum);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="统计次数："><a href="#统计次数：" class="headerlink" title="统计次数："></a>统计次数：</h5><p>需求：</p><p> 键盘录入两个数字，表示一个范围。</p><p> 统计这个范围中。</p><p> 既能被3整除，又能被5整除数字有多少个？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;输入数字&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a;c &lt;= b;c++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (c%<span class="number">3</span> == <span class="number">0</span> &amp;&amp; c % <span class="number">5</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                sum = sum + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;范围内既能被3整除，又能被5整除数字有&quot;</span>+sum+<span class="string">&quot;个&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><h5 id="while循环格式："><a href="#while循环格式：" class="headerlink" title="while循环格式："></a>while循环格式：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">初始化语句;</span><br><span class="line"><span class="keyword">while</span>(条件判断语句)&#123;</span><br><span class="line">循环体;</span><br><span class="line">条件控制语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="while循环练习："><a href="#while循环练习：" class="headerlink" title="while循环练习："></a>while循环练习：</h4><p><strong>打印5次HelloWorld:</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt;= <span class="number">5</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(i);</span><br></pre></td></tr></table></figure><p><strong>珠穆朗玛峰:</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.定义一个变量表示珠穆朗玛峰的高度</span></span><br><span class="line"><span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> <span class="number">8844430</span>;</span><br><span class="line"><span class="comment">//2.定义一个变量表示纸张的厚度</span></span><br><span class="line"><span class="type">double</span> <span class="variable">paper</span> <span class="operator">=</span> <span class="number">0.1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个计数器（变量），用来统计折叠的次数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.循环折叠纸张</span></span><br><span class="line"><span class="comment">//只有纸张的厚度 &lt; 穆朗玛峰的高度 循环才继续，否则循环就停止</span></span><br><span class="line"><span class="comment">//坑：只有判断为真，循环才会继续</span></span><br><span class="line"><span class="keyword">while</span>(paper &lt; height)&#123;</span><br><span class="line">    <span class="comment">//折叠纸张</span></span><br><span class="line">    paper = paper * <span class="number">2</span>;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.打印一下纸张的厚度</span></span><br><span class="line">System.out.println(count);<span class="comment">//27</span></span><br></pre></td></tr></table></figure><h4 id="do…while循环"><a href="#do…while循环" class="headerlink" title="do…while循环"></a>do…while循环</h4><h5 id="do…while循环格式："><a href="#do…while循环格式：" class="headerlink" title="do…while循环格式："></a>do…while循环格式：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">初始化语句;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    循环体;</span><br><span class="line">    条件控制语句;</span><br><span class="line">&#125;<span class="keyword">while</span>(条件判断语句);</span><br></pre></td></tr></table></figure><p>执行流程:<br>①执行初始化语句<br>②执行循环体语句<br>③执行条件控制语句<br>④执行条件判断语句，看其结果是true还是false如果是false，循环结束<br>如果是true，继续执行<br>⑤回到②继续</p><p><strong>特点：</strong></p><p>先运行，在判断，至少运行一次</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;<span class="comment">//初始化语句</span></span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;三月15日&quot;</span>);<span class="comment">//循环体语句</span></span><br><span class="line">            i++;<span class="comment">//条件控制语句</span></span><br><span class="line">        &#125;<span class="keyword">while</span> (i&lt;=<span class="number">5</span>);<span class="comment">//条件判断语句</span></span><br></pre></td></tr></table></figure><h4 id="三种循环格式的区别"><a href="#三种循环格式的区别" class="headerlink" title="三种循环格式的区别"></a>三种循环格式的区别</h4><p> for和while循环，是先判断，再执行。</p><p> do…while是先执行，再判断。</p><p> 当知道循环次数或者循环范围的时候，用for循环。</p><p> 当不知道循环次数，也不知道循环范围，但是知道循环的结束条件时，用while循环。</p><h4 id="死循环"><a href="#死循环" class="headerlink" title="死循环"></a>死循环</h4><p><strong>for死循环</strong>写法:<br>for ( ; ; ){<br>    }</p><p><strong>while死循环</strong>写法:<br>while(true){<br>    }</p><p><strong>do while死循环</strong>写法:<br>do {<br>    }while(true) ;</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;今天是星期二&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;今天是星期二&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;今天是星期二&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">while</span> (<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>java001</title>
      <link href="/2022/10/26/java001/"/>
      <url>/2022/10/26/java001/</url>
      
        <content type="html"><![CDATA[<h1 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h1><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>Java的算术运算符有+ - * &#x2F;<br>其中+ - * 和数学中的运算一样    <strong>但是 &#x2F; 有区别</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>整数相除结果只能得到整除，如果结果想要是小数，必须要有小数参数。</span><br><span class="line"><span class="number">2.</span>小数直接参与运算，得到的结果有可能是不精确的。</span><br><span class="line">案例：</span><br><span class="line">System.out.println( <span class="number">10</span> / <span class="number">3</span>);<span class="comment">//3</span></span><br><span class="line">System.out.println(<span class="number">10.0</span> / <span class="number">3</span>);<span class="comment">//3.3333333333333335</span></span><br></pre></td></tr></table></figure><p><strong>取模、取余</strong>用 <strong>%<strong>来运算  得到的结果为</strong>余数</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="number">10</span> % <span class="number">2</span>);<span class="comment">//0</span></span><br><span class="line">System.out.println(<span class="number">10</span> % <span class="number">3</span>);<span class="comment">//1</span></span><br><span class="line">应用场景：</span><br><span class="line"><span class="comment">//可以利用取模来判断一个数是奇数还是偶数</span></span><br><span class="line">System.out.println(<span class="number">15</span> % <span class="number">2</span>);<span class="comment">//1  奇数</span></span><br></pre></td></tr></table></figure><h4 id="数值拆分"><a href="#数值拆分" class="headerlink" title="数值拆分"></a>数值拆分</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.键盘录入一个三位数</span></span><br><span class="line"><span class="comment">//导包 --- 创建对象 --- 接收数据</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个三位数&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> sc.nextInt();<span class="comment">//123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.获取这个三位数的个位、十位、百位并打印出来</span></span><br><span class="line"><span class="comment">//公式：</span></span><br><span class="line"><span class="comment">//针对于任意的一个数而言</span></span><br><span class="line"><span class="comment">//个位： 数字 % 10</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ones</span> <span class="operator">=</span> number % <span class="number">10</span>;</span><br><span class="line"><span class="comment">//十位： 数字 / 10 % 10</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">tens</span> <span class="operator">=</span> number / <span class="number">10</span> % <span class="number">10</span>;</span><br><span class="line"><span class="comment">//百位： 数字 / 100 % 10</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">hundreds</span> <span class="operator">=</span> number / <span class="number">100</span>  % <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">        System.out.println(ones);</span><br><span class="line">        System.out.println(tens);</span><br><span class="line">        System.out.println(hundreds);</span><br></pre></td></tr></table></figure><p>先录入数字，<strong>int</strong>定义每个位置的数，分别除以他的位数(个位&#x2F;1；十位&#x2F;10；百位&#x2F;100……),对10取模得到每一位数字</p><hr><h3 id="隐式转换、强制转换"><a href="#隐式转换、强制转换" class="headerlink" title="隐式转换、强制转换"></a>隐式转换、强制转换</h3><p><strong>隐式转换</strong></p><p>不同变量类型在参与运算时，会将自己的变量提升为最大的变量值</p><p>short , char , byte 在参与运算时会自动转换为int型参与计算</p><p><strong>强制转换</strong></p><p>把<strong>取值范围大的数据或者变量</strong>赋值给另一个<strong>范围较小的变量</strong>，是不被允许的<br>如果一定这么做需要加入<strong>强制转化</strong></p><p><strong>书写格式：</strong></p><p> 目标数据类型 变量名 &#x3D; （目标数据类型）被强转的数据；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperatorDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">12.3</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">int</span>) a;</span><br><span class="line">        System.out.println(b);<span class="comment">//12</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>强制转换可能会导致数据发生错误(数据的精度丢失)</p><hr><h3 id="自增自减运算符"><a href="#自增自减运算符" class="headerlink" title="自增自减运算符"></a>自增自减运算符</h3><p><strong>分类：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">++  自增运算符</span><br><span class="line">--  自减运算符</span><br></pre></td></tr></table></figure><p>++：就是把变量里面的值+1</p><p>–：就是把变量里面的值-1</p><p><strong>注意点：</strong></p><p> 不管是先++，还是后++。单独写在一行的时候，运算结果是一模一样的。</p><p>在同一行，  ++i 运算先取加1后的i    i++先取i的原值，但是后面引用时i值也为原值+1</p><hr><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>又叫比较运算符，其实就是拿着左边跟右边进行了判断而已。</p><h5 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h5><table><thead><tr><th>符号</th><th>解释</th></tr></thead><tbody><tr><td>&#x3D;&#x3D;</td><td>就是判断左边跟右边是否相等，如果成立就是true，如果不成立就是false</td></tr><tr><td>!&#x3D;</td><td>就是判断左边跟右边是否不相等，如果成立就是true，如果不成立就是false</td></tr><tr><td>&gt;</td><td>就是判断左边是否大于右边，如果成立就是true，如果不成立就是false</td></tr><tr><td>&gt;&#x3D;</td><td>就是判断左边是否大于等于右边，如果成立就是true，如果不成立就是false</td></tr><tr><td>&lt;</td><td>就是判断左边是否小于右边，如果成立就是true，如果不成立就是false</td></tr><tr><td>&lt;&#x3D;</td><td>就是判断左边是否小于等于右边，如果成立就是true，如果不成立就是false</td></tr></tbody></table><h5 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h5><ul><li><p>关系运算符最终的结果一定是布尔类型的。要么是true，要么是false</p></li><li><p>在写&#x3D;&#x3D;的时候，千万不要写成&#x3D;</p></li></ul><p><strong>&amp; 和 |的使用</strong></p><p>&amp;：逻辑与（而且）</p><p> <strong>两边都为真，结果才是真</strong>，只要有一个为假，那么结果就是假。</p><p>|：逻辑或（或者）</p><p> <strong>两边都为假，结果才是假</strong>，只要有一个为真，那么结果就是真。</p><p><strong>^ 异或</strong><br><strong>如果两边相同，结果为false，如果两边不同，结果为true</strong></p><p><strong>| 取反</strong><br>false取反就是true，true取反就是false</p><hr><h3 id="短路逻辑运算符"><a href="#短路逻辑运算符" class="headerlink" title="短路逻辑运算符"></a>短路逻辑运算符</h3><p>分类： &amp;&amp; ||</p><p><strong>&amp;&amp;：</strong></p><p> 运算结果跟&amp;是一模一样的，只不过具有短路效果。</p><p><strong>||：</strong></p><p> 运算结果跟|是一模一样的。只不过具有短路效果。</p><p><strong>逻辑核心：</strong></p><p> 当左边不能确定整个表达式的结果，右边才会执行。</p><p> 当左边能确定整个表达式的结果，那么右边就不会执行了。从而提高了代码的运行效率。</p><p><strong>短路逻辑运算符可以提高程序的运行效率</strong></p><hr><h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><h5 id="格式："><a href="#格式：" class="headerlink" title="格式："></a>格式：</h5><p> <strong>关系表达式 ？ 表达式1 ：表达式2</strong> ；</p><h5 id="计算规则："><a href="#计算规则：" class="headerlink" title="计算规则："></a>计算规则：</h5><ul><li>计算关系表达式的值。</li><li>如果关系表达式的值为真，那么执行表达式1。</li><li>如果关系表达式的值为假，那么执行表达式2。</li></ul><h5 id="注意点：-1"><a href="#注意点：-1" class="headerlink" title="注意点："></a>注意点：</h5><p> 三元运算符的最终结果一定要被使用，要么赋值给一个变量，要么直接打印出来。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperatorDemo12</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//需求：求两个数的较大值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//格式：关系表达式 ？ 表达式1 ： 表达式2 ；</span></span><br><span class="line">        <span class="comment">//注意点：</span></span><br><span class="line">        <span class="comment">//三元运算符的最终结果一定要被使用。</span></span><br><span class="line">        <span class="comment">//要么赋值给一个变量，要么直接输出。</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span>  a &gt; b ? a : b ;</span><br><span class="line">        System.out.println(max);</span><br><span class="line">        System.out.println(a &gt; b ? a : b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h3><p>小括号优先于所有</p><hr><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><h5 id="练习1-两只老虎"><a href="#练习1-两只老虎" class="headerlink" title="练习1-两只老虎"></a>练习1-两只老虎</h5><p>需求：</p><p> 动物园里有两只老虎，两只老虎的体重分别为通过键盘录入获得，</p><p> 请用程序实现判断两只老虎的体重是否相同。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.获取两只老虎的体重</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入第一只老虎的体重&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">weight1</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">System.out.println(<span class="string">&quot;请输入第二只老虎的体重&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">weight2</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.利用三元运算符求出最终结果</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> weight1 == weight2 ? <span class="string">&quot;相同&quot;</span> : <span class="string">&quot;不相同&quot;</span>;</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure><h5 id="练习2-求三个数的最大值"><a href="#练习2-求三个数的最大值" class="headerlink" title="练习2-求三个数的最大值"></a>练习2-求三个数的最大值</h5><p>需求：</p><p> 一座寺庙里住着三个和尚，已知他们的身高分别为150cm、210cm、165cm。</p><p> 请用程序实现获取这三个和尚的最高身高。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.定义三个变量记录和尚的身高</span></span><br><span class="line"><span class="type">int</span> <span class="variable">height1</span> <span class="operator">=</span> <span class="number">150</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">height2</span> <span class="operator">=</span> <span class="number">210</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">height3</span> <span class="operator">=</span> <span class="number">165</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.利用三元运算符求出两个数中的较大值。</span></span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> height1 &gt; height2 ? height1 : height2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.求出最终的结果</span></span><br><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> temp &gt; height3 ? temp : height3;</span><br><span class="line"></span><br><span class="line">System.out.println(max);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/10/23/js001/"/>
      <url>/2022/10/23/js001/</url>
      
        <content type="html"><![CDATA[<h1 id="javascript基础"><a href="#javascript基础" class="headerlink" title="javascript基础"></a>javascript基础</h1><h3 id="输入输出语法"><a href="#输入输出语法" class="headerlink" title="输入输出语法"></a>输入输出语法</h3><p>两种输出方式：</p><ol><li><strong>网页内容输出</strong></li><li><strong>控制台输出</strong></li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是一个输入框</span></span><br><span class="line"><span class="title function_">prompt</span>(<span class="string">&#x27;请输入您的年龄&#x27;</span>);</span><br><span class="line"><span class="comment">// alert 弹出警示框 输出的 展示给用户的</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;计算的结果是&#x27;</span>);</span><br><span class="line"><span class="comment">// console 控制台输出 给程序员测试用的  </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我是程序员能看到的&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>alert</strong>：弹出警示框</p><p>输入：<strong>prompt</strong>(“输入内容”)</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> uname = <span class="title function_">prompt</span>(<span class="string">&#x27;请您输入姓名：&#x27;</span>)</span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">write</span>(uname)</span><br></pre></td></tr></table></figure><p>这里先赋值uname为输入(prompt内容)<br>页面输出内容</p><hr><h3 id="数组、字符串拼接"><a href="#数组、字符串拼接" class="headerlink" title="数组、字符串拼接"></a>数组、字符串拼接</h3><p>数组 arr[n]   :   有n个元素的数组，第一个为第0个开始计数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;马超&#x27;</span>, <span class="string">&#x27;黄忠&#x27;</span>, <span class="string">&#x27;关羽&#x27;</span>, <span class="string">&#x27;张飞&#x27;</span>, <span class="string">&#x27;貂蝉&#x27;</span>]</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(arr)</span><br><span class="line">        <span class="comment">// 取值  数组名[索引]</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(arr[<span class="number">0</span>])</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(arr[<span class="number">4</span>])</span><br></pre></td></tr></table></figure><p>arr[0]  为第一个元素，马超<br>arr[4]  为第五个元素，貂蝉</p><p>字符串拼接：’字符串’ + ‘拼接’<br>输出结果为  ‘字符串拼接’</p><hr><h3 id="数字型、isNaN"><a href="#数字型、isNaN" class="headerlink" title="数字型、isNaN"></a>数字型、isNaN</h3><p>八进制  0 ~ 7  我们程序里面数字前面加0 表示八进制<br>十六进制  0 ~ 9  a ~ f   #ffffff  数字的前面加 0x 表示十六进制  10<br>数字型的最大值：<em>Number</em>.MAX_VALUE</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>; <span class="comment">// num 数字型 </span></span><br><span class="line">        <span class="keyword">var</span> <span class="variable constant_">PI</span> = <span class="number">3.14</span> <span class="comment">// PI 数字型</span></span><br><span class="line">            <span class="comment">// 1. 八进制  0 ~ 7  我们程序里面数字前面加0 表示八进制</span></span><br><span class="line">        <span class="keyword">var</span> num1 = <span class="number">010</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(num1); <span class="comment">//  010  八进制 转换为 10进制 就是  8 </span></span><br><span class="line">        <span class="keyword">var</span> num2 = <span class="number">012</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(num2);</span><br><span class="line">        <span class="comment">// 2. 十六进制  0 ~ 9  a ~ f    #ffffff  数字的前面加 0x 表示十六进制   10</span></span><br><span class="line">        <span class="keyword">var</span> num3 = <span class="number">0x9</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(num3);    <span class="comment">//9</span></span><br><span class="line">        <span class="keyword">var</span> num4 = <span class="number">0xa</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(num4);    <span class="comment">//10</span></span><br><span class="line">        <span class="comment">// 3. 数字型的最大值</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="property">MAX_VALUE</span>);</span><br><span class="line">        <span class="comment">// 4. 数字型的最小值</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="property">MIN_VALUE</span>);</span><br><span class="line">        <span class="comment">// 5. 无穷大</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="property">MAX_VALUE</span> * <span class="number">2</span>); <span class="comment">// Infinity 无穷大  </span></span><br><span class="line">        <span class="comment">// 6. 无穷小</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(-<span class="title class_">Number</span>.<span class="property">MAX_VALUE</span> * <span class="number">2</span>); <span class="comment">// -Infinity 无穷大</span></span><br><span class="line">        <span class="comment">// 7. 非数字</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;pink老师&#x27;</span> - <span class="number">100</span>); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><p><strong>NaN 是 Not a Number(不是一个数值</strong></p><p><strong>isNaN( )</strong>:<br>这个方法用来判断非数字<br>并且返回一个值   如果是数字返回的是 false    如果不是数字返回的是true</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(<span class="number">12</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(<span class="string">&#x27;pink老师&#x27;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><hr><h3 id="布尔型boolean"><a href="#布尔型boolean" class="headerlink" title="布尔型boolean"></a>布尔型boolean</h3><p><strong>true</strong>参与加减法运算当<strong>1</strong>来看；<br><strong>false</strong>参与加减法运算当<strong>0</strong>来看</p><p>如果一个变量<strong>没有赋值</strong>，那么输出结果就是  <strong>underfind</strong>未定义数据类型</p><p><strong>undefined</strong> 和数字相加 最后的结果是 <strong>NaN</strong></p><p><strong>null</strong>空值在<strong>字符串运算</strong>中<strong>直接运算</strong>，在<strong>数字运算</strong>中<strong>当作0空值运算</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> flag = <span class="literal">true</span>; <span class="comment">// flag 布尔型 </span></span><br><span class="line">        <span class="keyword">var</span> flag1 = <span class="literal">false</span>; <span class="comment">// flag1 布尔型</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(flag + <span class="number">1</span>); <span class="comment">// true 参与加法运算当1来看</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(flag1 + <span class="number">1</span>); <span class="comment">// false 参与加法运算当 0来看</span></span><br><span class="line">        <span class="comment">// 如果一个变量声明未赋值 就是 undefined 未定义数据类型</span></span><br><span class="line">        <span class="keyword">var</span> str;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(str);</span><br><span class="line">        <span class="keyword">var</span> variable = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(variable + <span class="string">&#x27;pink&#x27;</span>); <span class="comment">// undefinedpink</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(variable + <span class="number">1</span>); <span class="comment">// NaN  undefined 和数字相加 最后的结果是 NaN</span></span><br><span class="line">        <span class="comment">// null 空值</span></span><br><span class="line">        <span class="keyword">var</span> space = <span class="literal">null</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(space + <span class="string">&#x27;pink&#x27;</span>); <span class="comment">// nullpink</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(space + <span class="number">1</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><hr><h3 id="获取变量数据类型、字面量"><a href="#获取变量数据类型、字面量" class="headerlink" title="获取变量数据类型、字面量"></a>获取变量数据类型、字面量</h3><p><strong>typeof</strong>  +  变量名   ：   数据类型</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> num); <span class="comment">// number</span></span><br><span class="line">        <span class="keyword">var</span> str = <span class="string">&#x27;pink&#x27;</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> str); <span class="comment">// string</span></span><br><span class="line">        <span class="keyword">var</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> flag); <span class="comment">// boolean</span></span><br><span class="line">        <span class="keyword">var</span> vari = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> vari); <span class="comment">// undefined</span></span><br><span class="line">        <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> timer); <span class="comment">// object</span></span><br><span class="line">        <span class="comment">// prompt 取过来的值是 字符型的</span></span><br><span class="line">        <span class="keyword">var</span> age = <span class="title function_">prompt</span>(<span class="string">&#x27;请输入您的年龄&#x27;</span>);</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&#x27;你的年龄是&#x27;</span>+age+<span class="string">&#x27;岁&#x27;</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(age);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> age);</span><br></pre></td></tr></table></figure><p>console.log(18)       <strong>18   数字型    蓝色</strong><br>console.log(‘18’)     <strong>‘18’ 字符串型   黑色</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">18</span>);<span class="comment">//数字型</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;18&#x27;</span>);<span class="comment">//字符串型</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">true</span>);<span class="comment">//布尔型</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">undefined</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><img src="/2022/10/23/js001/字面量截图.png" alt="字面量截图" style="zoom:25%;"><hr><h3 id="转换为字符型、数字型、布尔型"><a href="#转换为字符型、数字型、布尔型" class="headerlink" title="转换为字符型、数字型、布尔型"></a>转换为字符型、数字型、布尔型</h3><p><strong>转换为字符串型的三种方法：</strong></p><ol><li>把数字型转换为<strong>字符串型变量.toString()</strong>       </li><li>我们利用 <strong>String(变量)</strong>    </li><li>利用 <strong>+ 拼接字符串</strong>的方法实现转换效果 隐式转换</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 把数字型转换为字符串型 变量.toString()</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> str = num.<span class="title function_">toString</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> str);</span><br><span class="line"><span class="comment">// 2. 我们利用 String(变量)   </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>(num));</span><br><span class="line"><span class="comment">// 3. 利用 + 拼接字符串的方法实现转换效果 隐式转换</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num + <span class="string">&#x27;&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num);</span><br></pre></td></tr></table></figure><p>如果没有转换，输出的就是数字型，控制台是蓝色；<br>字符型输出为黑色</p><p><strong>转换数字型的方法：</strong></p><p>​    <strong>parse</strong>  +  <strong>数字类型</strong>  转化为对应数字类型</p><ol><li><strong>parseInt(变量)</strong>  可以把 字符型的转换为数字型 得到是整数</li><li><strong>parseFloat(变量)</strong> 可以把 字符型的转换为数字型 得到是小数 浮点数</li><li>利用 <strong>Number(变量)</strong>     和String(变量)一样   转换为数字型</li><li>利用了算数运算 <strong>-  *  &#x2F;</strong>  隐式转换</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(age)); <span class="comment">// NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(<span class="string">&#x27;3.14&#x27;</span>)); <span class="comment">// 3 取整</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(<span class="string">&#x27;3.94&#x27;</span>)); <span class="comment">// 3 取整</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(<span class="string">&#x27;120px&#x27;</span>)); <span class="comment">// 120 会去到这个px单位</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(<span class="string">&#x27;rem120px&#x27;</span>)); <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseFloat</span>(<span class="string">&#x27;3.14&#x27;</span>)); <span class="comment">// 3.14</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseFloat</span>(<span class="string">&#x27;120px&#x27;</span>)); <span class="comment">// 120 会去掉这个px单位</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseFloat</span>(<span class="string">&#x27;rem120px&#x27;</span>)); <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(str)); <span class="comment">// 123</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="string">&#x27;12&#x27;</span>)); <span class="comment">// 12</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;12&#x27;</span> - <span class="number">0</span>); <span class="comment">// 12</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;123&#x27;</span> - <span class="string">&#x27;120&#x27;</span>); <span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;123&#x27;</span> * <span class="number">1</span>); <span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p><strong>转换为布尔型：</strong><br>    <strong><em>Boolean</em>(变量)</strong>     转换为布尔型  输出值为false&#x2F;true</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Boolean</span>(<span class="string">&#x27;&#x27;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Boolean</span>(<span class="number">0</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Boolean</span>(<span class="title class_">NaN</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Boolean</span>(<span class="literal">null</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Boolean</span>(<span class="literal">undefined</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;------------------------------&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Boolean</span>(<span class="string">&#x27;123&#x27;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Boolean</span>(<span class="string">&#x27;你好吗&#x27;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Boolean</span>(<span class="string">&#x27;我很好&#x27;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
